ca65 V2.18 - Git fa17dc6
Main file   : functional_test.ca65
Current file: functional_test.ca65

000000r 1               ;
000000r 1               ; 6 5 0 2   F U N C T I O N A L   T E S T
000000r 1               ;
000000r 1               ; Copyright (C) 2012-2015  Klaus Dormann
000000r 1               ;
000000r 1               ; This program is free software: you can redistribute it and/or modify
000000r 1               ; it under the terms of the GNU General Public License as published by
000000r 1               ; the Free Software Foundation, either version 3 of the License, or
000000r 1               ; (at your option) any later version.
000000r 1               ;
000000r 1               ; This program is distributed in the hope that it will be useful,
000000r 1               ; but WITHOUT ANY WARRANTY; without even the implied warranty of
000000r 1               ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
000000r 1               ; GNU General Public License for more details.
000000r 1               ;
000000r 1               ; You should have received a copy of the GNU General Public License
000000r 1               ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
000000r 1               
000000r 1               
000000r 1               ; This program is designed to test all opcodes of a 6502 emulator using all
000000r 1               ; addressing modes with focus on propper setting of the processor status
000000r 1               ; register bits.
000000r 1               ;
000000r 1               ; version 01-aug-2019
000000r 1               ; contact info at http://2m5.de or email K@2m5.de
000000r 1               ;
000000r 1               ; assembled with CA65, linked with LD65 (cc65.github.io):
000000r 1               ;  ca65 -l 6502_functional_test.lst 6502_functional_test.ca65
000000r 1               ;  ld65 6502_functional_test.o -o 6502_functional_test.bin \
000000r 1               ;   -m 6502_functional_test.map -C example.cfg
000000r 1               ; example linker config (example.cfg):
000000r 1               ;  MEMORY {
000000r 1               ;  RAM: start = $0000, size=$8000, type = rw, fill = yes, \
000000r 1               ;   fillval = $FF, file = %O;
000000r 1               ;  ROM: start = $8000, size=$7FFA, type = ro, fill = yes, \
000000r 1               ;   fillval = $FF, file = %O;
000000r 1               ;  ROM_VECTORS: start = $FFFA, size=6, type = ro, fill = yes, \
000000r 1               ;   fillval = $FF, file = %O;
000000r 1               ;  }
000000r 1               ;  SEGMENTS {
000000r 1               ;  ZEROPAGE: load=RAM, type=rw;
000000r 1               ;  DATA: load=RAM, type=rw, offset=$0200;
000000r 1               ;  CODE: load=RAM, type=rw, offset=$0400;
000000r 1               ;  VECTORS: load=ROM_VECTORS, type=ro;
000000r 1               ;  }
000000r 1               ;
000000r 1               ; No IO - should be run from a monitor with access to registers.
000000r 1               ; To run load intel hex image with a load command, than alter PC to 400 hex
000000r 1               ; (code_segment) and enter a go command.
000000r 1               ; Loop on program counter determines error or successful completion of test.
000000r 1               ; Check listing for relevant traps (jump/branch *).
000000r 1               ; Please note that in early tests some instructions will have to be used before
000000r 1               ; they are actually tested!
000000r 1               ;
000000r 1               ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
000000r 1               ; Tests documented behavior of the original NMOS 6502 only! No unofficial
000000r 1               ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
000000r 1               ; not be tested. Decimal ops will only be tested with valid BCD operands and
000000r 1               ; N V Z flags will be ignored.
000000r 1               ;
000000r 1               ; Debugging hints:
000000r 1               ;     Most of the code is written sequentially. if you hit a trap, check the
000000r 1               ;   immediately preceeding code for the instruction to be tested. Results are
000000r 1               ;   tested first, flags are checked second by pushing them onto the stack and
000000r 1               ;   pulling them to the accumulator after the result was checked. The "real"
000000r 1               ;   flags are no longer valid for the tested instruction at this time!
000000r 1               ;     If the tested instruction was indexed, the relevant index (X or Y) must
000000r 1               ;   also be checked. Opposed to the flags, X and Y registers are still valid.
000000r 1               ;
000000r 1               ; versions:
000000r 1               ;   28-jul-2012  1st version distributed for testing
000000r 1               ;   29-jul-2012  fixed references to location 0, now #0
000000r 1               ;                added license - GPLv3
000000r 1               ;   30-jul-2012  added configuration options
000000r 1               ;   01-aug-2012  added trap macro to allow user to change error handling
000000r 1               ;   01-dec-2012  fixed trap in branch field must be a branch
000000r 1               ;   02-mar-2013  fixed PLA flags not tested
000000r 1               ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
000000r 1               ;                added test sequence check to detect if tests jump their fence
000000r 1               ;   23-jul-2013  added RAM integrity check option
000000r 1               ;   16-aug-2013  added error report to standard output option
000000r 1               ;   13-dec-2014  added binary/decimal opcode table switch test
000000r 1               ;   14-dec-2014  improved relative address test
000000r 1               ;   23-aug-2015  added option to disable self modifying tests
000000r 1               ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
000000r 1               ;                added small branch offset pretest
000000r 1               ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
000000r 1               ;   04-dec-2017  fixed BRK only tested with interrupts enabled
000000r 1               ;                added option to skip the remainder of a failing test
000000r 1               ;                in report.i65
000000r 1               
000000r 1               
000000r 1               ; C O N F I G U R A T I O N
000000r 1               
000000r 1               ;ROM_vectors writable (0=no, 1=yes)
000000r 1               ;if ROM vectors can not be used interrupts will not be trapped
000000r 1               ;as a consequence BRK can not be tested but will be emulated to test RTI
000000r 1               ROM_vectors = 0
000000r 1               
000000r 1               ;load_data_direct (0=move from code segment, 1=load directly)
000000r 1               ;loading directly is preferred but may not be supported by your platform
000000r 1               ;0 produces only consecutive object code, 1 is not suitable for a binary image
000000r 1               load_data_direct = 1
000000r 1               
000000r 1               ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
000000r 1               ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
000000r 1               ;tested if you allow changing the interrupt status (I_flag = 3)
000000r 1               I_flag = 3
000000r 1               
000000r 1               ;configure memory - try to stay away from memory used by the system
000000r 1               ;zero_page memory start address, $50 (80) consecutive Bytes required
000000r 1               ;                                add 2 if I_flag = 2
000000r 1               zero_page = $0
000000r 1               
000000r 1               ;data_segment memory start address, $6A (106) consecutive Bytes required
000000r 1               ; check that this matches the linker configuration file
000000r 1               data_segment = $200
000000r 1                   .if (data_segment & $ff) <> 0
000000r 1                       .error "low byte of data_segment MUST be $00 !!"
000000r 1                   .endif
000000r 1               
000000r 1               ;code_segment memory start address, 13kB of consecutive space required
000000r 1               ;                                   add 2.5 kB if I_flag = 2
000000r 1               ; check that this matches the linker configuration file
000000r 1               code_segment = $600
000000r 1               
000000r 1               ;self modifying code may be disabled to allow running in ROM
000000r 1               ;0=part of the code is self modifying and must reside in RAM
000000r 1               ;1=tests disabled: branch range
000000r 1               disable_selfmod = 0
000000r 1               
000000r 1               ;report errors through I/O channel (0=use standard self trap loops, 1=include
000000r 1               ;report.i65 as I/O channel, add 3.5 kB)
000000r 1               report = 0
000000r 1               
000000r 1               ;RAM integrity test option. Checks for undesired RAM writes.
000000r 1               ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
000000r 1               ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
000000r 1               ram_top = -1
000000r 1               
000000r 1               ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
000000r 1               ;2=disable including decimal flag in processor status
000000r 1               disable_decimal = 1
000000r 1               
000000r 1               ;macros for error & success traps to allow user modification
000000r 1               ;example:
000000r 1               ;        .macro  trap
000000r 1               ;        jsr my_error_handler
000000r 1               ;        .endmacro
000000r 1               ;        .macro  trap_eq
000000r 1               ;        bne :+
000000r 1               ;        trap           ;failed equal (zero)
000000r 1               ;:
000000r 1               ;        .endmacro
000000r 1               ;
000000r 1               ; my_error_handler should pop the calling address from the stack and report it.
000000r 1               ; putting larger portions of code (more than 3 bytes) inside the trap macro
000000r 1               ; may lead to branch range problems for some tests.
000000r 1                   .if report = 0
000000r 1                       .macro  trap
000000r 1                       jmp *           ;failed anyway
000000r 1                       .endmacro
000000r 1                       .macro  trap_eq
000000r 1                       beq *           ;failed equal (zero)
000000r 1                       .endmacro
000000r 1                       .macro  trap_ne
000000r 1                       bne *           ;failed not equal (non zero)
000000r 1                       .endmacro
000000r 1                       .macro  trap_cs
000000r 1                       bcs *           ;failed carry set
000000r 1                       .endmacro
000000r 1                       .macro  trap_cc
000000r 1                       bcc *           ;failed carry clear
000000r 1                       .endmacro
000000r 1                       .macro  trap_mi
000000r 1                       bmi *           ;failed minus (bit 7 set)
000000r 1                       .endmacro
000000r 1                       .macro  trap_pl
000000r 1                       bpl *           ;failed plus (bit 7 clear)
000000r 1                       .endmacro
000000r 1                       .macro  trap_vs
000000r 1                       bvs *           ;failed overflow set
000000r 1                       .endmacro
000000r 1                       .macro  trap_vc
000000r 1                       bvc *           ;failed overflow clear
000000r 1                       .endmacro
000000r 1               ; please observe that during the test the stack gets invalidated
000000r 1               ; therefore a RTS inside the success macro is not possible
000000r 1                       .macro  success
000000r 1                       jmp *           ;test passed, no errors
000000r 1                       .endmacro
000000r 1                   .endif
000000r 1                   .if report = 1
000000r 1                       .macro  trap
000000r 1                       jsr report_error
000000r 1                       .endmacro
000000r 1                       .macro  trap_eq
000000r 1                       bne :+
000000r 1                       trap           ;failed equal (zero)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_ne
000000r 1                       beq :+
000000r 1                       trap            ;failed not equal (non zero)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_cs
000000r 1                       bcc :+
000000r 1                       trap            ;failed carry set
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_cc
000000r 1                       bcs :+
000000r 1                       trap            ;failed carry clear
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_mi
000000r 1                       bpl :+
000000r 1                       trap            ;failed minus (bit 7 set)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_pl
000000r 1                       bmi :+
000000r 1                       trap            ;failed plus (bit 7 clear)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_vs
000000r 1                       bvc :+
000000r 1                       trap            ;failed overflow set
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_vc
000000r 1                       bvs :+
000000r 1                       trap            ;failed overflow clear
000000r 1               :
000000r 1                       .endmacro
000000r 1               ; please observe that during the test the stack gets invalidated
000000r 1               ; therefore a RTS inside the success macro is not possible
000000r 1                       .macro  success
000000r 1                       jsr report_success
000000r 1                       .endmacro
000000r 1                   .endif
000000r 1               
000000r 1                   .define equ =
000000r 1               
000000r 1               carry   equ %00000001   ;flag bits in status
000000r 1               zero    equ %00000010
000000r 1               intdis  equ %00000100
000000r 1               decmode equ %00001000
000000r 1               break   equ %00010000
000000r 1               reserv  equ %00100000
000000r 1               overfl  equ %01000000
000000r 1               minus   equ %10000000
000000r 1               
000000r 1               fc      equ carry
000000r 1               fz      equ zero
000000r 1               fzc     equ carry+zero
000000r 1               fv      equ overfl
000000r 1               fvz     equ overfl+zero
000000r 1               fn      equ minus
000000r 1               fnc     equ minus+carry
000000r 1               fnz     equ minus+zero
000000r 1               fnzc    equ minus+zero+carry
000000r 1               fnv     equ minus+overfl
000000r 1               
000000r 1               fao     equ break+reserv    ;bits always on after PHP, BRK
000000r 1               fai     equ fao+intdis      ;+ forced interrupt disable
000000r 1               faod    equ fao+decmode     ;+ ignore decimal
000000r 1               faid    equ fai+decmode     ;+ ignore decimal
000000r 1               m8      equ $ff             ;8 bit mask
000000r 1               m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
000000r 1               
000000r 1               ;macros to allow masking of status bits.
000000r 1               ;masking test of decimal bit
000000r 1               ;masking of interrupt enable/disable on load and compare
000000r 1               ;masking of always on bits after PHP or BRK (unused & break) on compare
000000r 1                   .if disable_decimal < 2
000000r 1                       .if I_flag = 0
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1&m8i          ;force enable interrupts (mask I)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           cmp #(p1|fao)&m8i   ;I_flag is always enabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor #(p1&m8i|fao)   ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 1
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1|intdis      ;force disable interrupts
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           cmp #(p1|fai)&m8    ;I_flag is always disabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor #(p1|fai)       ;invert expected flags + always on bits + I
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 2
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1
000000r 1                           ora flag_I_on       ;restore I-flag
000000r 1                           and flag_I_off
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           cmp #(p1|fao)&m8i   ;expected flags + always on bits, mask I
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           eor #(p1&m8i|fao)   ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 3
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1             ;allow test to change I-flag (no mask)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           cmp #(p1|fao)&m8    ;expected flags + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor #p1|fao         ;invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                   .else
000000r 1                       .if I_flag = 0
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1&m8i         ;force enable interrupts (mask I)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faod)&m8i  ;I_flag is always enabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(p1&m8i|faod)  ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 1
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1|intdis      ;force disable interrupts
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faid)&m8   ;I_flag is always disabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(p1|faid)      ;invert expected flags + always on bits + I
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 2
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1
000000r 1                           ora flag_I_on       ;restore I-flag
000000r 1                           and flag_I_off
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faod)&m8i  ;expected flags + always on bits, mask I
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(p1&m8i|faod)  ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 3
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1             ;allow test to change I-flag (no mask)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faod)&m8   ;expected flags + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #p1|faod        ;invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                   .endif
000000r 1               
000000r 1               ;macros to set (register|memory|zeropage) & status
000000r 1                           .macro      set_stat    p1          ;setting flags in the processor status register
000000r 1                           load_flag p1
000000r 1                           pha         ;use stack to load status
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_a       p1,p2       ;precharging accu & status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda #p1     ;precharge accu
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_x       p1,p2       ;precharging index & status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           ldx #p1     ;precharge index x
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_y       p1,p2       ;precharging index & status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           ldy #p1     ;precharge index y
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_ax      p1,p2       ;precharging indexed accu & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;precharge accu
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_ay      p1,p2       ;precharging indexed accu & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,y    ;precharge accu
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_z       p1,p2       ;precharging indexed zp & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to zeropage
000000r 1                           sta zpt
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_zx      p1,p2       ;precharging zp,x & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to indexed zeropage
000000r 1                           sta zpt,x
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_abs     p1,p2       ;precharging indexed memory & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to memory
000000r 1                           sta abst
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_absx    p1,p2       ;precharging abs,x & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to indexed memory
000000r 1                           sta abst,x
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1               ;macros to test (register|memory|zeropage) & status & (mask)
000000r 1                           .macro      tst_stat    p1          ;testing flags in the processor status register
000000r 1                           php         ;save status
000000r 1                           pla         ;use stack to retrieve status
000000r 1                           pha
000000r 1                           cmp_flag p1
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_a       p1,p2        ;testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp #p1     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag p2
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_x       p1,p2       ;testing result in x index & flags
000000r 1                           php         ;save flags
000000r 1                           cpx #p1     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag p2
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_y       p1,p2       ;testing result in y index & flags
000000r 1                           php         ;save flags
000000r 1                           cpy #p1     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag p2
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_ax      p1,p2,p3    ;indexed testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne     ;
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_ay      p1,p2,p3    ;indexed testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp p1,y    ;test result
000000r 1                           trap_ne     ;
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,y    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_z       p1,p2,p3    ;indexed testing result in zp & flags
000000r 1                           php         ;save flags
000000r 1                           lda zpt
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_zx      p1,p2,p3    ;testing result in zp,x & flags
000000r 1                           php         ;save flags
000000r 1                           lda zpt,x
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_abs     p1,p2,p3    ;indexed testing result in memory & flags
000000r 1                           php         ;save flags
000000r 1                           lda abst
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_absx    p1,p2,p3    ;testing result in abs,x & flags
000000r 1                           php         ;save flags
000000r 1                           lda abst,x
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1               ; RAM integrity test
000000r 1               ;   verifies that none of the previous tests has altered RAM outside of the
000000r 1               ;   designated write areas.
000000r 1               ;   uses zpt word as indirect pointer, zpt+2 word as checksum
000000r 1                       .if ram_top > -1
000000r 1               check_ram   macro
000000r 1                           cld
000000r 1                           lda #0
000000r 1                           sta zpt         ;set low byte of indirect pointer
000000r 1                           sta zpt+3       ;checksum high byte
000000r 1                         .if disable_selfmod = 0
000000r 1                           sta range_adr   ;reset self modifying code
000000r 1                         .endif
000000r 1                           clc
000000r 1                           ldx #zp_bss-zero_page ;zeropage - write test area
000000r 1               ccs3:       adc zero_page,x
000000r 1                           bcc ccs2
000000r 1                           inc zpt+3       ;carry to high byte
000000r 1                           clc
000000r 1               ccs2:       inx
000000r 1                           bne ccs3
000000r 1                           ldx #hi(abs1)   ;set high byte of indirect pointer
000000r 1                           stx zpt+1
000000r 1                           ldy #lo(abs1)   ;data after write & execute test area
000000r 1               ccs5:       adc (zpt),y
000000r 1                           bcc ccs4
000000r 1                           inc zpt+3       ;carry to high byte
000000r 1                           clc
000000r 1               ccs4:       iny
000000r 1                           bne ccs5
000000r 1                           inx             ;advance RAM high address
000000r 1                           stx zpt+1
000000r 1                           cpx #ram_top
000000r 1                           bne ccs5
000000r 1                           sta zpt+2       ;checksum low is
000000r 1                           cmp ram_chksm   ;checksum low expected
000000r 1                           trap_ne         ;checksum mismatch
000000r 1                           lda zpt+3       ;checksum high is
000000r 1                           cmp ram_chksm+1 ;checksum high expected
000000r 1                           trap_ne         ;checksum mismatch
000000r 1                           .endmacro
000000r 1                       .else
000000r 1                           .macro  check_ram
000000r 1                           ;RAM check disabled - RAM size not set
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1               
000000r 1                           .macro  next_test   ;make sure, tests don't jump the fence
000000r 1                           lda test_case   ;previous test
000000r 1                           cmp #test_num
000000r 1                           trap_ne         ;test is out of sequence
000000r 1               test_num .set test_num + 1
000000r 1                           lda #test_num   ;*** next tests' number
000000r 1                           sta test_case
000000r 1                           ;check_ram       ;uncomment to find altered RAM after each test
000000r 1                           .endmacro
000000r 1               
000000r 1                       .ZEROPAGE
000000r 1               		.res zero_page, 0
000000r 1                       .org zero_page
000000  1               
000000  1               ;break test interrupt save
000000  1  00           irq_a:  .res    1,0             ;a register
000001  1  00           irq_x:  .res    1,0             ;x register
000002  1                   .if I_flag = 2
000002  1               ;masking for I bit in status
000002  1               flag_I_on:  .res    1,0         ;or mask to load flags
000002  1               flag_I_off: .res    1,0         ;and mask to load flags
000002  1                   .endif
000002  1               zpt:                        ;5 bytes store/modify test area
000002  1               ;add/subtract operand generation and result/flag prediction
000002  1  00           adfc:   .res    1,0             ;carry flag before op
000003  1  00           ad1:    .res    1,0             ;operand 1 - accumulator
000004  1  00           ad2:    .res    1,0             ;operand 2 - memory / immediate
000005  1  00           adrl:   .res    1,0             ;expected result bits 0-7
000006  1  00           adrh:   .res    1,0             ;expected result bit 8 (carry)
000007  1  00           adrf:   .res    1,0             ;expected flags NV0000ZC (only binary mode)
000008  1  00           sb2:    .res    1,0             ;operand 2 complemented for subtract
000009  1               zp_bss:
000009  1  C3 82 41 00  zp1:    .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
00000D  1  7F           zp7f:   .byte   $7f             ;test pattern for compare
00000E  1               ;logical zeropage operands
00000E  1  00 1F 71 80  zpOR:   .byte   0,$1f,$71,$80   ;test pattern for OR
000012  1  0F FF 7F 80  zpAN:   .byte   $0f,$ff,$7f,$80 ;test pattern for AND
000016  1  FF 0F 8F 8F  zpEO:   .byte   $ff,$0f,$8f,$8f ;test pattern for EOR
00001A  1               ;indirect addressing pointers
00001A  1  17 02        ind1:   .word   abs1            ;indirect pointer to pattern in absolute memory
00001C  1  18 02                .word   abs1+1
00001E  1  19 02                .word   abs1+2
000020  1  1A 02                .word   abs1+3
000022  1  1B 02                .word   abs7f
000024  1  1F 01        inw1:   .word   abs1-$f8        ;indirect pointer for wrap-test pattern
000026  1  03 02        indt:   .word   abst            ;indirect pointer to store area in absolute memory
000028  1  04 02                .word   abst+1
00002A  1  05 02                .word   abst+2
00002C  1  06 02                .word   abst+3
00002E  1  0B 01        inwt:   .word   abst-$f8        ;indirect pointer for wrap-test store
000030  1  4E 02        indAN:  .word   absAN           ;indirect pointer to AND pattern in absolute memory
000032  1  4F 02                .word   absAN+1
000034  1  50 02                .word   absAN+2
000036  1  51 02                .word   absAN+3
000038  1  52 02        indEO:  .word   absEO           ;indirect pointer to EOR pattern in absolute memory
00003A  1  53 02                .word   absEO+1
00003C  1  54 02                .word   absEO+2
00003E  1  55 02                .word   absEO+3
000040  1  4A 02        indOR:  .word   absOR           ;indirect pointer to OR pattern in absolute memory
000042  1  4B 02                .word   absOR+1
000044  1  4C 02                .word   absOR+2
000046  1  4D 02                .word   absOR+3
000048  1               ;add/subtract indirect pointers
000048  1  03 02        adi2:   .word   ada2            ;indirect pointer to operand 2 in absolute memory
00004A  1  04 02        sbi2:   .word   sba2            ;indirect pointer to complemented operand 2 (SBC)
00004C  1  04 01        adiy2:  .word   ada2-$ff        ;with offset for indirect indexed
00004E  1  05 01        sbiy2:  .word   sba2-$ff
000050  1               zp_bss_end:
000050  1               
000050  1                       .DATA
000050  1                       .org data_segment
000200  1               
000200  1  00           test_case:  .res    1,0         ;current test number
000201  1  00 00        ram_chksm:  .res    2,0         ;checksum for RAM integrity test
000203  1               ;add/subtract operand copy - abs tests write area
000203  1               abst:                       ;5 bytes store/modify test area
000203  1  00           ada2:   .res    1,0             ;operand 2
000204  1  00           sba2:   .res    1,0             ;operand 2 complemented for subtract
000205  1  00 00 00             .res    3,0             ;fill remaining bytes
000208  1               data_bss:
000208  1                   .if load_data_direct = 1
000208  1  29 00        ex_andi:and #0              ;execute immediate opcodes
00020A  1  60                   rts
00020B  1  49 00        ex_eori:eor #0              ;execute immediate opcodes
00020D  1  60                   rts
00020E  1  09 00        ex_orai:ora #0              ;execute immediate opcodes
000210  1  60                   rts
000211  1  69 00        ex_adci:adc #0              ;execute immediate opcodes
000213  1  60                   rts
000214  1  E9 00        ex_sbci:sbc #0              ;execute immediate opcodes
000216  1  60                   rts
000217  1                   .else
000217  1               ex_andi:.res    3
000217  1               ex_eori:.res    3
000217  1               ex_orai:.res    3
000217  1               ex_adci:.res    3
000217  1               ex_sbci:.res    3
000217  1                   .endif
000217  1  C3 82 41 00  abs1:   .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
00021B  1  7F           abs7f:  .byte   $7f             ;test pattern for compare
00021C  1               ;loads
00021C  1  80 80 00 02  fLDx:   .byte   fn,fn,0,fz      ;expected flags for load
000220  1               ;shifts
000220  1               rASL:                       ;expected result ASL & ROL -carry
000220  1  86 04 82 00  rROL:   .byte   $86,$04,$82,0   ; "
000224  1  87 05 83 01  rROLc:  .byte   $87,$05,$83,1   ;expected result ROL +carry
000228  1               rLSR:                       ;expected result LSR & ROR -carry
000228  1  61 41 20 00  rROR:   .byte   $61,$41,$20,0   ; "
00022C  1  E1 C1 A0 80  rRORc:  .byte   $e1,$c1,$a0,$80 ;expected result ROR +carry
000230  1               fASL:                       ;expected flags for shifts
000230  1  81 01 80 02  fROL:   .byte   fnc,fc,fn,fz    ;no carry in
000234  1  81 01 80 00  fROLc:  .byte   fnc,fc,fn,0     ;carry in
000238  1               fLSR:
000238  1  01 00 01 02  fROR:   .byte   fc,0,fc,fz      ;no carry in
00023C  1  81 80 81 80  fRORc:  .byte   fnc,fn,fnc,fn   ;carry in
000240  1               ;increments (decrements)
000240  1  7F 80 FF 00  rINC:   .byte   $7f,$80,$ff,0,1 ;expected result for INC/DEC
000244  1  01           
000245  1  00 80 80 02  fINC:   .byte   0,fn,fn,fz,0    ;expected flags for INC/DEC
000249  1  00           
00024A  1               ;logical memory operand
00024A  1  00 1F 71 80  absOR:  .byte   0,$1f,$71,$80   ;test pattern for OR
00024E  1  0F FF 7F 80  absAN:  .byte   $0f,$ff,$7f,$80 ;test pattern for AND
000252  1  FF 0F 8F 8F  absEO:  .byte   $ff,$0f,$8f,$8f ;test pattern for EOR
000256  1               ;logical accu operand
000256  1  00 F1 1F 00  absORa: .byte   0,$f1,$1f,0     ;test pattern for OR
00025A  1  F0 FF FF FF  absANa: .byte   $f0,$ff,$ff,$ff ;test pattern for AND
00025E  1  FF F0 F0 0F  absEOa: .byte   $ff,$f0,$f0,$0f ;test pattern for EOR
000262  1               ;logical results
000262  1  00 FF 7F 80  absrlo: .byte   0,$ff,$7f,$80
000266  1  02 80 00 80  absflo: .byte   fz,fn,0,fn
00026A  1               data_bss_end:
00026A  1               
00026A  1               
00026A  1                       .CODE
00026A  1                       .org code_segment
000600  1                       .P02            ; disable 65SC02, 65C02 and 65816 instructions
000600  1  D8           start:  cld
000601  1  A2 FF                ldx #$ff
000603  1  9A                   txs
000604  1  A9 00                lda #0          ;*** test 0 = initialize
000606  1  8D 00 02             sta test_case
000609  1               test_num .set 0
000609  1               
000609  1               ;stop interrupts before initializing BSS
000609  1                   .if I_flag = 1
000609  1                       sei
000609  1                   .endif
000609  1               
000609  1               ;initialize I/O for report channel
000609  1                   .if report = 1
000609  1                       jsr report_init
000609  1                   .endif
000609  1               
000609  1               ;pretest small branch offset
000609  1  A2 05                ldx #5
00060B  1  4C 33 06             jmp psb_test
00060E  1               psb_bwok:
00060E  1  A0 05                ldy #5
000610  1  D0 08                bne psb_forw
000612  1  4C 12 06             trap        ;branch should be taken
000615  1  88                   dey         ;forward landing zone
000616  1  88                   dey
000617  1  88                   dey
000618  1  88                   dey
000619  1  88                   dey
00061A  1               psb_forw:
00061A  1  88                   dey
00061B  1  88                   dey
00061C  1  88                   dey
00061D  1  88                   dey
00061E  1  88                   dey
00061F  1  F0 17                beq psb_fwok
000621  1  4C 21 06             trap        ;forward offset
000624  1               
000624  1  CA                   dex         ;backward landing zone
000625  1  CA                   dex
000626  1  CA                   dex
000627  1  CA                   dex
000628  1  CA                   dex
000629  1               psb_back:
000629  1  CA                   dex
00062A  1  CA                   dex
00062B  1  CA                   dex
00062C  1  CA                   dex
00062D  1  CA                   dex
00062E  1  F0 DE                beq psb_bwok
000630  1  4C 30 06             trap        ;backward offset
000633  1               psb_test:
000633  1  D0 F4                bne psb_back
000635  1  4C 35 06             trap        ;branch should be taken
000638  1               psb_fwok:
000638  1               
000638  1               ;initialize BSS segment
000638  1                   .if load_data_direct <> 1
000638  1                       ldx #zp_end-zp_init-1
000638  1               ld_zp:  lda zp_init,x
000638  1                       sta zp_bss,x
000638  1                       dex
000638  1                       bpl ld_zp
000638  1                       ldx #data_end-data_init-1
000638  1               ld_data:lda data_init,x
000638  1                       sta data_bss,x
000638  1                       dex
000638  1                       bpl ld_data
000638  1                     .if ROM_vectors = 1
000638  1                       ldx #5
000638  1               ld_vect:lda vec_init,x
000638  1                       sta vec_bss,x
000638  1                       dex
000638  1                       bpl ld_vect
000638  1                     .endif
000638  1                   .endif
000638  1               
000638  1               ;retain status of interrupt flag
000638  1                   .if I_flag = 2
000638  1                       php
000638  1                       pla
000638  1                       and #4          ;isolate flag
000638  1                       sta flag_I_on   ;or mask
000638  1                       eor #lo(~4)     ;reverse
000638  1                       sta flag_I_off  ;and mask
000638  1                   .endif
000638  1               
000638  1               ;generate checksum for RAM integrity test
000638  1                   .if ram_top > -1
000638  1                       lda #0
000638  1                       sta zpt         ;set low byte of indirect pointer
000638  1                       sta ram_chksm+1 ;checksum high byte
000638  1                     .if disable_selfmod = 0
000638  1                       sta range_adr   ;reset self modifying code
000638  1                     .endif
000638  1                       clc
000638  1                       ldx #zp_bss-zero_page ;zeropage - write test area
000638  1               gcs3:   adc zero_page,x
000638  1                       bcc gcs2
000638  1                       inc ram_chksm+1 ;carry to high byte
000638  1                       clc
000638  1               gcs2:   inx
000638  1                       bne gcs3
000638  1                       ldx #hi(abs1)   ;set high byte of indirect pointer
000638  1                       stx zpt+1
000638  1                       ldy #lo(abs1)   ;data after write & execute test area
000638  1               gcs5:   adc (zpt),y
000638  1                       bcc gcs4
000638  1                       inc ram_chksm+1 ;carry to high byte
000638  1                       clc
000638  1               gcs4:   iny
000638  1                       bne gcs5
000638  1                       inx             ;advance RAM high address
000638  1                       stx zpt+1
000638  1                       cpx #ram_top
000638  1                       bne gcs5
000638  1                       sta ram_chksm   ;checksum complete
000638  1                   .endif
000638  1  AD 00 02 C9          next_test
00063C  1  00 D0 FE A9  
000640  1  01 8D 00 02  
000644  1               
000644  1                   .if disable_selfmod = 0
000644  1               ;testing relative addressing with BEQ
000644  1  A0 FE                ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
000646  1               range_loop:
000646  1  88                   dey             ;next relative address
000647  1  98                   tya
000648  1  AA                   tax             ;precharge count to end of loop
000649  1  10 08                bpl range_fw    ;calculate relative address
00064B  1  18                   clc             ;avoid branch self or to relative address of branch
00064C  1  69 02                adc #2
00064E  1  EA                   nop             ;offset landing zone - tolerate +/-5 offset to branch
00064F  1  EA                   nop
000650  1  EA                   nop
000651  1  EA                   nop
000652  1  EA                   nop
000653  1               range_fw:
000653  1  EA                   nop
000654  1  EA                   nop
000655  1  EA                   nop
000656  1  EA                   nop
000657  1  EA                   nop
000658  1  49 7F                eor #$7f        ;complement except sign
00065A  1  8D E6 06             sta range_adr   ;load into test target
00065D  1  A9 00                lda #0          ;should set zero flag in status register
00065F  1  4C E5 06             jmp range_op
000662  1               
000662  1  CA                   dex             ; offset landing zone - backward branch too far
000663  1  CA                   dex
000664  1  CA                   dex
000665  1  CA                   dex
000666  1  CA                   dex
000667  1                       ;relative address target field with branch under test in the middle
000667  1  CA                   dex             ;-128 - max backward
000668  1  CA                   dex
000669  1  CA                   dex
00066A  1  CA                   dex
00066B  1  CA                   dex
00066C  1  CA                   dex
00066D  1  CA                   dex
00066E  1  CA                   dex
00066F  1  CA                   dex             ;-120
000670  1  CA                   dex
000671  1  CA                   dex
000672  1  CA                   dex
000673  1  CA                   dex
000674  1  CA                   dex
000675  1  CA                   dex
000676  1  CA                   dex
000677  1  CA                   dex
000678  1  CA                   dex
000679  1  CA                   dex             ;-110
00067A  1  CA                   dex
00067B  1  CA                   dex
00067C  1  CA                   dex
00067D  1  CA                   dex
00067E  1  CA                   dex
00067F  1  CA                   dex
000680  1  CA                   dex
000681  1  CA                   dex
000682  1  CA                   dex
000683  1  CA                   dex             ;-100
000684  1  CA                   dex
000685  1  CA                   dex
000686  1  CA                   dex
000687  1  CA                   dex
000688  1  CA                   dex
000689  1  CA                   dex
00068A  1  CA                   dex
00068B  1  CA                   dex
00068C  1  CA                   dex
00068D  1  CA                   dex             ;-90
00068E  1  CA                   dex
00068F  1  CA                   dex
000690  1  CA                   dex
000691  1  CA                   dex
000692  1  CA                   dex
000693  1  CA                   dex
000694  1  CA                   dex
000695  1  CA                   dex
000696  1  CA                   dex
000697  1  CA                   dex             ;-80
000698  1  CA                   dex
000699  1  CA                   dex
00069A  1  CA                   dex
00069B  1  CA                   dex
00069C  1  CA                   dex
00069D  1  CA                   dex
00069E  1  CA                   dex
00069F  1  CA                   dex
0006A0  1  CA                   dex
0006A1  1  CA                   dex             ;-70
0006A2  1  CA                   dex
0006A3  1  CA                   dex
0006A4  1  CA                   dex
0006A5  1  CA                   dex
0006A6  1  CA                   dex
0006A7  1  CA                   dex
0006A8  1  CA                   dex
0006A9  1  CA                   dex
0006AA  1  CA                   dex
0006AB  1  CA                   dex             ;-60
0006AC  1  CA                   dex
0006AD  1  CA                   dex
0006AE  1  CA                   dex
0006AF  1  CA                   dex
0006B0  1  CA                   dex
0006B1  1  CA                   dex
0006B2  1  CA                   dex
0006B3  1  CA                   dex
0006B4  1  CA                   dex
0006B5  1  CA                   dex             ;-50
0006B6  1  CA                   dex
0006B7  1  CA                   dex
0006B8  1  CA                   dex
0006B9  1  CA                   dex
0006BA  1  CA                   dex
0006BB  1  CA                   dex
0006BC  1  CA                   dex
0006BD  1  CA                   dex
0006BE  1  CA                   dex
0006BF  1  CA                   dex             ;-40
0006C0  1  CA                   dex
0006C1  1  CA                   dex
0006C2  1  CA                   dex
0006C3  1  CA                   dex
0006C4  1  CA                   dex
0006C5  1  CA                   dex
0006C6  1  CA                   dex
0006C7  1  CA                   dex
0006C8  1  CA                   dex
0006C9  1  CA                   dex             ;-30
0006CA  1  CA                   dex
0006CB  1  CA                   dex
0006CC  1  CA                   dex
0006CD  1  CA                   dex
0006CE  1  CA                   dex
0006CF  1  CA                   dex
0006D0  1  CA                   dex
0006D1  1  CA                   dex
0006D2  1  CA                   dex
0006D3  1  CA                   dex             ;-20
0006D4  1  CA                   dex
0006D5  1  CA                   dex
0006D6  1  CA                   dex
0006D7  1  CA                   dex
0006D8  1  CA                   dex
0006D9  1  CA                   dex
0006DA  1  CA                   dex
0006DB  1  CA                   dex
0006DC  1  CA                   dex
0006DD  1  CA                   dex             ;-10
0006DE  1  CA                   dex
0006DF  1  CA                   dex
0006E0  1  CA                   dex
0006E1  1  CA                   dex
0006E2  1  CA                   dex
0006E3  1  CA                   dex
0006E4  1  CA                   dex             ;-3
0006E5  1               range_op:               ;test target with zero flag=0, z=1 if previous dex
0006E5  1               range_adr   = *+1       ;modifiable relative address
0006E5  1  F0 3E                beq *+64        ;+64 if called without modification
0006E7  1  CA                   dex             ;+0
0006E8  1  CA                   dex
0006E9  1  CA                   dex
0006EA  1  CA                   dex
0006EB  1  CA                   dex
0006EC  1  CA                   dex
0006ED  1  CA                   dex
0006EE  1  CA                   dex
0006EF  1  CA                   dex
0006F0  1  CA                   dex
0006F1  1  CA                   dex             ;+10
0006F2  1  CA                   dex
0006F3  1  CA                   dex
0006F4  1  CA                   dex
0006F5  1  CA                   dex
0006F6  1  CA                   dex
0006F7  1  CA                   dex
0006F8  1  CA                   dex
0006F9  1  CA                   dex
0006FA  1  CA                   dex
0006FB  1  CA                   dex             ;+20
0006FC  1  CA                   dex
0006FD  1  CA                   dex
0006FE  1  CA                   dex
0006FF  1  CA                   dex
000700  1  CA                   dex
000701  1  CA                   dex
000702  1  CA                   dex
000703  1  CA                   dex
000704  1  CA                   dex
000705  1  CA                   dex             ;+30
000706  1  CA                   dex
000707  1  CA                   dex
000708  1  CA                   dex
000709  1  CA                   dex
00070A  1  CA                   dex
00070B  1  CA                   dex
00070C  1  CA                   dex
00070D  1  CA                   dex
00070E  1  CA                   dex
00070F  1  CA                   dex             ;+40
000710  1  CA                   dex
000711  1  CA                   dex
000712  1  CA                   dex
000713  1  CA                   dex
000714  1  CA                   dex
000715  1  CA                   dex
000716  1  CA                   dex
000717  1  CA                   dex
000718  1  CA                   dex
000719  1  CA                   dex             ;+50
00071A  1  CA                   dex
00071B  1  CA                   dex
00071C  1  CA                   dex
00071D  1  CA                   dex
00071E  1  CA                   dex
00071F  1  CA                   dex
000720  1  CA                   dex
000721  1  CA                   dex
000722  1  CA                   dex
000723  1  CA                   dex             ;+60
000724  1  CA                   dex
000725  1  CA                   dex
000726  1  CA                   dex
000727  1  CA                   dex
000728  1  CA                   dex
000729  1  CA                   dex
00072A  1  CA                   dex
00072B  1  CA                   dex
00072C  1  CA                   dex
00072D  1  CA                   dex             ;+70
00072E  1  CA                   dex
00072F  1  CA                   dex
000730  1  CA                   dex
000731  1  CA                   dex
000732  1  CA                   dex
000733  1  CA                   dex
000734  1  CA                   dex
000735  1  CA                   dex
000736  1  CA                   dex
000737  1  CA                   dex             ;+80
000738  1  CA                   dex
000739  1  CA                   dex
00073A  1  CA                   dex
00073B  1  CA                   dex
00073C  1  CA                   dex
00073D  1  CA                   dex
00073E  1  CA                   dex
00073F  1  CA                   dex
000740  1  CA                   dex
000741  1  CA                   dex             ;+90
000742  1  CA                   dex
000743  1  CA                   dex
000744  1  CA                   dex
000745  1  CA                   dex
000746  1  CA                   dex
000747  1  CA                   dex
000748  1  CA                   dex
000749  1  CA                   dex
00074A  1  CA                   dex
00074B  1  CA                   dex             ;+100
00074C  1  CA                   dex
00074D  1  CA                   dex
00074E  1  CA                   dex
00074F  1  CA                   dex
000750  1  CA                   dex
000751  1  CA                   dex
000752  1  CA                   dex
000753  1  CA                   dex
000754  1  CA                   dex
000755  1  CA                   dex             ;+110
000756  1  CA                   dex
000757  1  CA                   dex
000758  1  CA                   dex
000759  1  CA                   dex
00075A  1  CA                   dex
00075B  1  CA                   dex
00075C  1  CA                   dex
00075D  1  CA                   dex
00075E  1  CA                   dex
00075F  1  CA                   dex             ;+120
000760  1  CA                   dex
000761  1  CA                   dex
000762  1  CA                   dex
000763  1  CA                   dex
000764  1  CA                   dex
000765  1  CA                   dex
000766  1  EA                   nop             ;offset landing zone - forward branch too far
000767  1  EA                   nop
000768  1  EA                   nop
000769  1  EA                   nop
00076A  1  EA                   nop
00076B  1  F0 08                beq range_ok    ;+127 - max forward
00076D  1  4C 6D 07             trap            ; bad range
000770  1  EA                   nop             ;offset landing zone - tolerate +/-5 offset to branch
000771  1  EA                   nop
000772  1  EA                   nop
000773  1  EA                   nop
000774  1  EA                   nop
000775  1               range_ok:
000775  1  EA                   nop
000776  1  EA                   nop
000777  1  EA                   nop
000778  1  EA                   nop
000779  1  EA                   nop
00077A  1  C0 00                cpy #0
00077C  1  F0 03                beq range_end
00077E  1  4C 46 06             jmp range_loop
000781  1               range_end:              ;range test successful
000781  1                   .endif
000781  1  AD 00 02 C9          next_test
000785  1  01 D0 FE A9  
000789  1  02 8D 00 02  
00078D  1               
00078D  1               ;partial test BNE & CMP, CPX, CPY immediate
00078D  1  C0 01                cpy #1          ;testing BNE true
00078F  1  D0 03                bne test_bne
000791  1  4C 91 07             trap
000794  1               test_bne:
000794  1  A9 00                lda #0
000796  1  C9 00                cmp #0          ;test compare immediate
000798  1  D0 FE                trap_ne
00079A  1  90 FE                trap_cc
00079C  1  30 FE                trap_mi
00079E  1  C9 01                cmp #1
0007A0  1  F0 FE                trap_eq
0007A2  1  B0 FE                trap_cs
0007A4  1  10 FE                trap_pl
0007A6  1  AA                   tax
0007A7  1  E0 00                cpx #0          ;test compare x immediate
0007A9  1  D0 FE                trap_ne
0007AB  1  90 FE                trap_cc
0007AD  1  30 FE                trap_mi
0007AF  1  E0 01                cpx #1
0007B1  1  F0 FE                trap_eq
0007B3  1  B0 FE                trap_cs
0007B5  1  10 FE                trap_pl
0007B7  1  A8                   tay
0007B8  1  C0 00                cpy #0          ;test compare y immediate
0007BA  1  D0 FE                trap_ne
0007BC  1  90 FE                trap_cc
0007BE  1  30 FE                trap_mi
0007C0  1  C0 01                cpy #1
0007C2  1  F0 FE                trap_eq
0007C4  1  B0 FE                trap_cs
0007C6  1  10 FE                trap_pl
0007C8  1  AD 00 02 C9          next_test
0007CC  1  02 D0 FE A9  
0007D0  1  03 8D 00 02  
0007D4  1               ;testing stack operations PHA PHP PLA PLP
0007D4  1               
0007D4  1  A2 FF                ldx #$ff        ;initialize stack
0007D6  1  9A                   txs
0007D7  1  A9 55                lda #$55
0007D9  1  48                   pha
0007DA  1  A9 AA                lda #$aa
0007DC  1  48                   pha
0007DD  1  CD FE 01             cmp $1fe        ;on stack ?
0007E0  1  D0 FE                trap_ne
0007E2  1  BA                   tsx
0007E3  1  8A                   txa             ;overwrite accu
0007E4  1  C9 FD                cmp #$fd        ;sp decremented?
0007E6  1  D0 FE                trap_ne
0007E8  1  68                   pla
0007E9  1  C9 AA                cmp #$aa        ;successful retreived from stack?
0007EB  1  D0 FE                trap_ne
0007ED  1  68                   pla
0007EE  1  C9 55                cmp #$55
0007F0  1  D0 FE                trap_ne
0007F2  1  CD FF 01             cmp $1ff        ;remains on stack?
0007F5  1  D0 FE                trap_ne
0007F7  1  BA                   tsx
0007F8  1  E0 FF                cpx #$ff        ;sp incremented?
0007FA  1  D0 FE                trap_ne
0007FC  1  AD 00 02 C9          next_test
000800  1  03 D0 FE A9  
000804  1  04 8D 00 02  
000808  1               
000808  1               ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
000808  1  A9 FF 48 28          set_stat $ff    ;all on
00080C  1  10 1A                bpl nbr1        ;branches should not be taken
00080E  1  50 1B                bvc nbr2
000810  1  90 1C                bcc nbr3
000812  1  D0 1D                bne nbr4
000814  1  30 03                bmi br1         ;branches should be taken
000816  1  4C 16 08             trap
000819  1  70 03        br1:    bvs br2
00081B  1  4C 1B 08             trap
00081E  1  B0 03        br2:    bcs br3
000820  1  4C 20 08             trap
000823  1  F0 0F        br3:    beq br4
000825  1  4C 25 08             trap
000828  1               nbr1:
000828  1  4C 28 08             trap            ;previous bpl taken
00082B  1               nbr2:
00082B  1  4C 2B 08             trap            ;previous bvc taken
00082E  1               nbr3:
00082E  1  4C 2E 08             trap            ;previous bcc taken
000831  1               nbr4:
000831  1  4C 31 08             trap            ;previous bne taken
000834  1  08           br4:    php
000835  1  BA                   tsx
000836  1  E0 FE                cpx #$fe        ;sp after php?
000838  1  D0 FE                trap_ne
00083A  1  68                   pla
00083B  1  C9 FF                cmp_flag $ff    ;returned all flags on?
00083D  1  D0 FE                trap_ne
00083F  1  BA                   tsx
000840  1  E0 FF                cpx #$ff        ;sp after php?
000842  1  D0 FE                trap_ne
000844  1  A9 00 48 28          set_stat 0      ;all off
000848  1  30 1A                bmi nbr11       ;branches should not be taken
00084A  1  70 1B                bvs nbr12
00084C  1  B0 1C                bcs nbr13
00084E  1  F0 1D                beq nbr14
000850  1  10 03                bpl br11        ;branches should be taken
000852  1  4C 52 08             trap
000855  1  50 03        br11:   bvc br12
000857  1  4C 57 08             trap
00085A  1  90 03        br12:   bcc br13
00085C  1  4C 5C 08             trap
00085F  1  D0 0F        br13:   bne br14
000861  1  4C 61 08             trap
000864  1               nbr11:
000864  1  4C 64 08             trap            ;previous bmi taken
000867  1               nbr12:
000867  1  4C 67 08             trap            ;previous bvs taken
00086A  1               nbr13:
00086A  1  4C 6A 08             trap            ;previous bcs taken
00086D  1               nbr14:
00086D  1  4C 6D 08             trap            ;previous beq taken
000870  1  08           br14:   php
000871  1  68                   pla
000872  1  C9 30                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
000874  1  D0 FE                trap_ne
000876  1                       ;crosscheck flags
000876  1  A9 02 48 28          set_stat zero
00087A  1  D0 02                bne brzs1
00087C  1  F0 03                beq brzs2
00087E  1               brzs1:
00087E  1  4C 7E 08             trap            ;branch zero/non zero
000881  1  B0 02        brzs2:  bcs brzs3
000883  1  90 03                bcc brzs4
000885  1               brzs3:
000885  1  4C 85 08             trap            ;branch carry/no carry
000888  1  30 02        brzs4:  bmi brzs5
00088A  1  10 03                bpl brzs6
00088C  1               brzs5:
00088C  1  4C 8C 08             trap            ;branch minus/plus
00088F  1  70 02        brzs6:  bvs brzs7
000891  1  50 03                bvc brzs8
000893  1               brzs7:
000893  1  4C 93 08             trap            ;branch overflow/no overflow
000896  1               brzs8:
000896  1  A9 01 48 28          set_stat carry
00089A  1  F0 02                beq brcs1
00089C  1  D0 03                bne brcs2
00089E  1               brcs1:
00089E  1  4C 9E 08             trap            ;branch zero/non zero
0008A1  1  90 02        brcs2:  bcc brcs3
0008A3  1  B0 03                bcs brcs4
0008A5  1               brcs3:
0008A5  1  4C A5 08             trap            ;branch carry/no carry
0008A8  1  30 02        brcs4:  bmi brcs5
0008AA  1  10 03                bpl brcs6
0008AC  1               brcs5:
0008AC  1  4C AC 08             trap            ;branch minus/plus
0008AF  1  70 02        brcs6:  bvs brcs7
0008B1  1  50 03                bvc brcs8
0008B3  1               brcs7:
0008B3  1  4C B3 08             trap            ;branch overflow/no overflow
0008B6  1               
0008B6  1               brcs8:
0008B6  1  A9 80 48 28          set_stat minus
0008BA  1  F0 02                beq brmi1
0008BC  1  D0 03                bne brmi2
0008BE  1               brmi1:
0008BE  1  4C BE 08             trap            ;branch zero/non zero
0008C1  1  B0 02        brmi2:  bcs brmi3
0008C3  1  90 03                bcc brmi4
0008C5  1               brmi3:
0008C5  1  4C C5 08             trap            ;branch carry/no carry
0008C8  1  10 02        brmi4:  bpl brmi5
0008CA  1  30 03                bmi brmi6
0008CC  1               brmi5:
0008CC  1  4C CC 08             trap            ;branch minus/plus
0008CF  1  70 02        brmi6:  bvs brmi7
0008D1  1  50 03                bvc brmi8
0008D3  1               brmi7:
0008D3  1  4C D3 08             trap            ;branch overflow/no overflow
0008D6  1               brmi8:
0008D6  1  A9 40 48 28          set_stat overfl
0008DA  1  F0 02                beq brvs1
0008DC  1  D0 03                bne brvs2
0008DE  1               brvs1:
0008DE  1  4C DE 08             trap            ;branch zero/non zero
0008E1  1  B0 02        brvs2:  bcs brvs3
0008E3  1  90 03                bcc brvs4
0008E5  1               brvs3:
0008E5  1  4C E5 08             trap            ;branch carry/no carry
0008E8  1  30 02        brvs4:  bmi brvs5
0008EA  1  10 03                bpl brvs6
0008EC  1               brvs5:
0008EC  1  4C EC 08             trap            ;branch minus/plus
0008EF  1  50 02        brvs6:  bvc brvs7
0008F1  1  70 03                bvs brvs8
0008F3  1               brvs7:
0008F3  1  4C F3 08             trap            ;branch overflow/no overflow
0008F6  1               brvs8:
0008F6  1  A9 FD 48 28          set_stat $ff-zero
0008FA  1  F0 02                beq brzc1
0008FC  1  D0 03                bne brzc2
0008FE  1               brzc1:
0008FE  1  4C FE 08             trap            ;branch zero/non zero
000901  1  90 02        brzc2:  bcc brzc3
000903  1  B0 03                bcs brzc4
000905  1               brzc3:
000905  1  4C 05 09             trap            ;branch carry/no carry
000908  1  10 02        brzc4:  bpl brzc5
00090A  1  30 03                bmi brzc6
00090C  1               brzc5:
00090C  1  4C 0C 09             trap            ;branch minus/plus
00090F  1  50 02        brzc6:  bvc brzc7
000911  1  70 03                bvs brzc8
000913  1               brzc7:
000913  1  4C 13 09             trap            ;branch overflow/no overflow
000916  1               brzc8:
000916  1  A9 FE 48 28          set_stat $ff-carry
00091A  1  D0 02                bne brcc1
00091C  1  F0 03                beq brcc2
00091E  1               brcc1:
00091E  1  4C 1E 09             trap            ;branch zero/non zero
000921  1  B0 02        brcc2:  bcs brcc3
000923  1  90 03                bcc brcc4
000925  1               brcc3:
000925  1  4C 25 09             trap            ;branch carry/no carry
000928  1  10 02        brcc4:  bpl brcc5
00092A  1  30 03                bmi brcc6
00092C  1               brcc5:
00092C  1  4C 2C 09             trap            ;branch minus/plus
00092F  1  50 02        brcc6:  bvc brcc7
000931  1  70 03                bvs brcc8
000933  1               brcc7:
000933  1  4C 33 09             trap            ;branch overflow/no overflow
000936  1               brcc8:
000936  1  A9 7F 48 28          set_stat $ff-minus
00093A  1  D0 02                bne brpl1
00093C  1  F0 03                beq brpl2
00093E  1               brpl1:
00093E  1  4C 3E 09             trap            ;branch zero/non zero
000941  1  90 02        brpl2:  bcc brpl3
000943  1  B0 03                bcs brpl4
000945  1               brpl3:
000945  1  4C 45 09             trap            ;branch carry/no carry
000948  1  30 02        brpl4:  bmi brpl5
00094A  1  10 03                bpl brpl6
00094C  1               brpl5:
00094C  1  4C 4C 09             trap            ;branch minus/plus
00094F  1  50 02        brpl6:  bvc brpl7
000951  1  70 03                bvs brpl8
000953  1               brpl7:
000953  1  4C 53 09             trap            ;branch overflow/no overflow
000956  1               brpl8:
000956  1  A9 BF 48 28          set_stat $ff-overfl
00095A  1  D0 02                bne brvc1
00095C  1  F0 03                beq brvc2
00095E  1               brvc1:
00095E  1  4C 5E 09             trap            ;branch zero/non zero
000961  1  90 02        brvc2:  bcc brvc3
000963  1  B0 03                bcs brvc4
000965  1               brvc3:
000965  1  4C 65 09             trap            ;branch carry/no carry
000968  1  10 02        brvc4:  bpl brvc5
00096A  1  30 03                bmi brvc6
00096C  1               brvc5:
00096C  1  4C 6C 09             trap            ;branch minus/plus
00096F  1  70 02        brvc6:  bvs brvc7
000971  1  50 03                bvc brvc8
000973  1               brvc7:
000973  1  4C 73 09             trap            ;branch overflow/no overflow
000976  1               brvc8:
000976  1  AD 00 02 C9          next_test
00097A  1  04 D0 FE A9  
00097E  1  05 8D 00 02  
000982  1               
000982  1               ; test PHA does not alter flags or accumulator but PLA does
000982  1  A2 55                ldx #$55        ;x & y protected
000984  1  A0 AA                ldy #$aa
000986  1  A9 FF 48 A9          set_a 1,$ff     ;push
00098A  1  01 28        
00098C  1  48                   pha
00098D  1  08 C9 01 D0          tst_a 1,$ff
000991  1  FE 68 48 C9  
000995  1  FF D0 FE 28  
000999  1  A9 00 48 A9          set_a 0,0
00099D  1  00 28        
00099F  1  48                   pha
0009A0  1  08 C9 00 D0          tst_a 0,0
0009A4  1  FE 68 48 C9  
0009A8  1  30 D0 FE 28  
0009AC  1  A9 FF 48 A9          set_a $ff,$ff
0009B0  1  FF 28        
0009B2  1  48                   pha
0009B3  1  08 C9 FF D0          tst_a $ff,$ff
0009B7  1  FE 68 48 C9  
0009BB  1  FF D0 FE 28  
0009BF  1  A9 00 48 A9          set_a 1,0
0009C3  1  01 28        
0009C5  1  48                   pha
0009C6  1  08 C9 01 D0          tst_a 1,0
0009CA  1  FE 68 48 C9  
0009CE  1  30 D0 FE 28  
0009D2  1  A9 FF 48 A9          set_a 0,$ff
0009D6  1  00 28        
0009D8  1  48                   pha
0009D9  1  08 C9 00 D0          tst_a 0,$ff
0009DD  1  FE 68 48 C9  
0009E1  1  FF D0 FE 28  
0009E5  1  A9 00 48 A9          set_a $ff,0
0009E9  1  FF 28        
0009EB  1  48                   pha
0009EC  1  08 C9 FF D0          tst_a $ff,0
0009F0  1  FE 68 48 C9  
0009F4  1  30 D0 FE 28  
0009F8  1  A9 FF 48 A9          set_a 0,$ff     ;pull
0009FC  1  00 28        
0009FE  1  68                   pla
0009FF  1  08 C9 FF D0          tst_a $ff,$ff-zero
000A03  1  FE 68 48 C9  
000A07  1  FD D0 FE 28  
000A0B  1  A9 00 48 A9          set_a $ff,0
000A0F  1  FF 28        
000A11  1  68                   pla
000A12  1  08 C9 00 D0          tst_a 0,zero
000A16  1  FE 68 48 C9  
000A1A  1  32 D0 FE 28  
000A1E  1  A9 FF 48 A9          set_a $fe,$ff
000A22  1  FE 28        
000A24  1  68                   pla
000A25  1  08 C9 01 D0          tst_a 1,$ff-zero-minus
000A29  1  FE 68 48 C9  
000A2D  1  7D D0 FE 28  
000A31  1  A9 00 48 A9          set_a 0,0
000A35  1  00 28        
000A37  1  68                   pla
000A38  1  08 C9 FF D0          tst_a $ff,minus
000A3C  1  FE 68 48 C9  
000A40  1  B0 D0 FE 28  
000A44  1  A9 FF 48 A9          set_a $ff,$ff
000A48  1  FF 28        
000A4A  1  68                   pla
000A4B  1  08 C9 00 D0          tst_a 0,$ff-minus
000A4F  1  FE 68 48 C9  
000A53  1  7F D0 FE 28  
000A57  1  A9 00 48 A9          set_a $fe,0
000A5B  1  FE 28        
000A5D  1  68                   pla
000A5E  1  08 C9 01 D0          tst_a 1,0
000A62  1  FE 68 48 C9  
000A66  1  30 D0 FE 28  
000A6A  1  E0 55                cpx #$55        ;x & y unchanged?
000A6C  1  D0 FE                trap_ne
000A6E  1  C0 AA                cpy #$aa
000A70  1  D0 FE                trap_ne
000A72  1  AD 00 02 C9          next_test
000A76  1  05 D0 FE A9  
000A7A  1  06 8D 00 02  
000A7E  1               
000A7E  1               ; partial pretest EOR #
000A7E  1  A9 00 48 A9          set_a $3c,0
000A82  1  3C 28        
000A84  1  49 C3                eor #$c3
000A86  1  08 C9 FF D0          tst_a $ff,fn
000A8A  1  FE 68 48 C9  
000A8E  1  B0 D0 FE 28  
000A92  1  A9 00 48 A9          set_a $c3,0
000A96  1  C3 28        
000A98  1  49 C3                eor #$c3
000A9A  1  08 C9 00 D0          tst_a 0,fz
000A9E  1  FE 68 48 C9  
000AA2  1  32 D0 FE 28  
000AA6  1  AD 00 02 C9          next_test
000AAA  1  06 D0 FE A9  
000AAE  1  07 8D 00 02  
000AB2  1               
000AB2  1               ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
000AB2  1               ; testing NOP
000AB2  1  A2 24                ldx #$24
000AB4  1  A0 42                ldy #$42
000AB6  1  A9 00 48 A9          set_a $18,0
000ABA  1  18 28        
000ABC  1  EA                   nop
000ABD  1  08 C9 18 D0          tst_a $18,0
000AC1  1  FE 68 48 C9  
000AC5  1  30 D0 FE 28  
000AC9  1  E0 24                cpx #$24
000ACB  1  D0 FE                trap_ne
000ACD  1  C0 42                cpy #$42
000ACF  1  D0 FE                trap_ne
000AD1  1  A2 DB                ldx #$db
000AD3  1  A0 BD                ldy #$bd
000AD5  1  A9 FF 48 A9          set_a $e7,$ff
000AD9  1  E7 28        
000ADB  1  EA                   nop
000ADC  1  08 C9 E7 D0          tst_a $e7,$ff
000AE0  1  FE 68 48 C9  
000AE4  1  FF D0 FE 28  
000AE8  1  E0 DB                cpx #$db
000AEA  1  D0 FE                trap_ne
000AEC  1  C0 BD                cpy #$bd
000AEE  1  D0 FE                trap_ne
000AF0  1  AD 00 02 C9          next_test
000AF4  1  07 D0 FE A9  
000AF8  1  08 8D 00 02  
000AFC  1               
000AFC  1               ; jump absolute
000AFC  1  A9 00 48 28          set_stat $0
000B00  1  A9 46                lda #'F'
000B02  1  A2 41                ldx #'A'
000B04  1  A0 52                ldy #'R'        ;N=0, V=0, Z=0, C=0
000B06  1  4C D4 36             jmp test_far
000B09  1  EA                   nop
000B0A  1  EA                   nop
000B0B  1  D0 FE                trap_ne         ;runover protection
000B0D  1  E8                   inx
000B0E  1  E8                   inx
000B0F  1               far_ret:
000B0F  1  F0 FE                trap_eq         ;returned flags OK?
000B11  1  10 FE                trap_pl
000B13  1  90 FE                trap_cc
000B15  1  50 FE                trap_vc
000B17  1  C9 EC                cmp #('F'^$aa)  ;returned registers OK?
000B19  1  D0 FE                trap_ne
000B1B  1  E0 42                cpx #('A'+1)
000B1D  1  D0 FE                trap_ne
000B1F  1  C0 4F                cpy #('R'-3)
000B21  1  D0 FE                trap_ne
000B23  1  CA                   dex
000B24  1  C8                   iny
000B25  1  C8                   iny
000B26  1  C8                   iny
000B27  1  49 AA                eor #$aa        ;N=0, V=1, Z=0, C=1
000B29  1  4C 32 0B             jmp test_near
000B2C  1  EA                   nop
000B2D  1  EA                   nop
000B2E  1  D0 FE                trap_ne         ;runover protection
000B30  1  E8                   inx
000B31  1  E8                   inx
000B32  1               test_near:
000B32  1  F0 FE                trap_eq         ;passed flags OK?
000B34  1  30 FE                trap_mi
000B36  1  90 FE                trap_cc
000B38  1  50 FE                trap_vc
000B3A  1  C9 46                cmp #'F'        ;passed registers OK?
000B3C  1  D0 FE                trap_ne
000B3E  1  E0 41                cpx #'A'
000B40  1  D0 FE                trap_ne
000B42  1  C0 52                cpy #'R'
000B44  1  D0 FE                trap_ne
000B46  1  AD 00 02 C9          next_test
000B4A  1  08 D0 FE A9  
000B4E  1  09 8D 00 02  
000B52  1               
000B52  1               ; jump indirect
000B52  1  A9 00 48 28          set_stat 0
000B56  1  A9 49                lda #'I'
000B58  1  A2 4E                ldx #'N'
000B5A  1  A0 44                ldy #'D'        ;N=0, V=0, Z=0, C=0
000B5C  1  6C 02 37             jmp (ptr_tst_ind)
000B5F  1  EA                   nop
000B60  1  D0 FE                trap_ne         ;runover protection
000B62  1  88                   dey
000B63  1  88                   dey
000B64  1               ind_ret:
000B64  1  08                   php             ;either SP or Y count will fail, if we do not hit
000B65  1  88                   dey
000B66  1  88                   dey
000B67  1  88                   dey
000B68  1  28                   plp
000B69  1  F0 FE                trap_eq         ;returned flags OK?
000B6B  1  10 FE                trap_pl
000B6D  1  90 FE                trap_cc
000B6F  1  50 FE                trap_vc
000B71  1  C9 E3                cmp #('I'^$aa)  ;returned registers OK?
000B73  1  D0 FE                trap_ne
000B75  1  E0 4F                cpx #('N'+1)
000B77  1  D0 FE                trap_ne
000B79  1  C0 3E                cpy #('D'-6)
000B7B  1  D0 FE                trap_ne
000B7D  1  BA                   tsx             ;SP check
000B7E  1  E0 FF                cpx #$ff
000B80  1  D0 FE                trap_ne
000B82  1  AD 00 02 C9          next_test
000B86  1  09 D0 FE A9  
000B8A  1  0A 8D 00 02  
000B8E  1               
000B8E  1               ; jump subroutine & return from subroutine
000B8E  1  A9 00 48 28          set_stat 0
000B92  1  A9 4A                lda #'J'
000B94  1  A2 53                ldx #'S'
000B96  1  A0 52                ldy #'R'        ;N=0, V=0, Z=0, C=0
000B98  1  20 41 37             jsr test_jsr
000B9B  1               jsr_ret = *-1           ;last address of jsr = return address
000B9B  1  08                   php             ;either SP or Y count will fail, if we do not hit
000B9C  1  88                   dey
000B9D  1  88                   dey
000B9E  1  88                   dey
000B9F  1  28                   plp
000BA0  1  F0 FE                trap_eq         ;returned flags OK?
000BA2  1  10 FE                trap_pl
000BA4  1  90 FE                trap_cc
000BA6  1  50 FE                trap_vc
000BA8  1  C9 E0                cmp #('J'^$aa)  ;returned registers OK?
000BAA  1  D0 FE                trap_ne
000BAC  1  E0 54                cpx #('S'+1)
000BAE  1  D0 FE                trap_ne
000BB0  1  C0 4C                cpy #('R'-6)
000BB2  1  D0 FE                trap_ne
000BB4  1  BA                   tsx             ;sp?
000BB5  1  E0 FF                cpx #$ff
000BB7  1  D0 FE                trap_ne
000BB9  1  AD 00 02 C9          next_test
000BBD  1  0A D0 FE A9  
000BC1  1  0B 8D 00 02  
000BC5  1               
000BC5  1               ; break & return from interrupt
000BC5  1                   .if ROM_vectors = 1
000BC5  1                       load_flag 0     ;with interrupts enabled if allowed!
000BC5  1                       pha
000BC5  1                       lda #'B'
000BC5  1                       ldx #'R'
000BC5  1                       ldy #'K'
000BC5  1                       plp             ;N=0, V=0, Z=0, C=0
000BC5  1                       brk
000BC5  1                   .else
000BC5  1  A9 0B                lda #>brk_ret0 ;emulated break
000BC7  1  48                   pha
000BC8  1  A9 DC                lda #<brk_ret0
000BCA  1  48                   pha
000BCB  1  A9 30                load_flag fao    ;set break & unused on stack
000BCD  1  48                   pha
000BCE  1  A9 04                load_flag intdis ;during interrupt
000BD0  1  48                   pha
000BD1  1  A9 42                lda #'B'
000BD3  1  A2 52                ldx #'R'
000BD5  1  A0 4B                ldy #'K'
000BD7  1  28                   plp             ;N=0, V=0, Z=0, C=0
000BD8  1  4C 8F 37             jmp irq_trap
000BDB  1                   .endif
000BDB  1  88                   dey             ;should not be executed
000BDC  1               brk_ret0:               ;address of break return
000BDC  1  08                   php             ;either SP or Y count will fail, if we do not hit
000BDD  1  88                   dey
000BDE  1  88                   dey
000BDF  1  88                   dey
000BE0  1  C9 E8                cmp #'B'^$aa    ;returned registers OK?
000BE2  1                       ;the IRQ vector was never executed if A & X stay unmodified
000BE2  1  D0 FE                trap_ne
000BE4  1  E0 53                cpx #'R'+1
000BE6  1  D0 FE                trap_ne
000BE8  1  C0 45                cpy #'K'-6
000BEA  1  D0 FE                trap_ne
000BEC  1  68                   pla             ;returned flags OK (unchanged)?
000BED  1  C9 30                cmp_flag 0
000BEF  1  D0 FE                trap_ne
000BF1  1  BA                   tsx             ;sp?
000BF2  1  E0 FF                cpx #$ff
000BF4  1  D0 FE                trap_ne
000BF6  1                   .if ROM_vectors = 1
000BF6  1                       load_flag $ff   ;with interrupts disabled if allowed!
000BF6  1                       pha
000BF6  1                       lda #$ff-'B'
000BF6  1                       ldx #$ff-'R'
000BF6  1                       ldy #$ff-'K'
000BF6  1                       plp             ;N=1, V=1, Z=1, C=1
000BF6  1                       brk
000BF6  1                   .else
000BF6  1  A9 0C                lda #>brk_ret1 ;emulated break
000BF8  1  48                   pha
000BF9  1  A9 0B                lda #<brk_ret1
000BFB  1  48                   pha
000BFC  1  A9 FF                load_flag $ff
000BFE  1  48                   pha             ;set break & unused on stack
000BFF  1  48                   pha             ;actual flags
000C00  1  A9 BD                lda #$ff-'B'
000C02  1  A2 AD                ldx #$ff-'R'
000C04  1  A0 B4                ldy #$ff-'K'
000C06  1  28                   plp             ;N=1, V=1, Z=1, C=1
000C07  1  4C 8F 37             jmp irq_trap
000C0A  1                   .endif
000C0A  1  88                   dey             ;should not be executed
000C0B  1               brk_ret1:               ;address of break return
000C0B  1  08                   php             ;either SP or Y count will fail, if we do not hit
000C0C  1  88                   dey
000C0D  1  88                   dey
000C0E  1  88                   dey
000C0F  1  C9 17                cmp #($ff-'B')^$aa  ;returned registers OK?
000C11  1                       ;the IRQ vector was never executed if A & X stay unmodified
000C11  1  D0 FE                trap_ne
000C13  1  E0 AE                cpx #$ff-'R'+1
000C15  1  D0 FE                trap_ne
000C17  1  C0 AE                cpy #$ff-'K'-6
000C19  1  D0 FE                trap_ne
000C1B  1  68                   pla             ;returned flags OK (unchanged)?
000C1C  1  C9 FF                cmp_flag $ff
000C1E  1  D0 FE                trap_ne
000C20  1  BA                   tsx             ;sp?
000C21  1  E0 FF                cpx #$ff
000C23  1  D0 FE                trap_ne
000C25  1  AD 00 02 C9          next_test
000C29  1  0B D0 FE A9  
000C2D  1  0C 8D 00 02  
000C31  1               
000C31  1               ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
000C31  1  A9 FF 48 28          set_stat $ff
000C35  1  18                   clc
000C36  1  08 68 48 C9          tst_stat $ff-carry
000C3A  1  FE D0 FE 28  
000C3E  1  38                   sec
000C3F  1  08 68 48 C9          tst_stat $ff
000C43  1  FF D0 FE 28  
000C47  1                   .if I_flag = 3
000C47  1  58                   cli
000C48  1  08 68 48 C9          tst_stat $ff-intdis
000C4C  1  FB D0 FE 28  
000C50  1  78                   sei
000C51  1  08 68 48 C9          tst_stat $ff
000C55  1  FF D0 FE 28  
000C59  1                   .endif
000C59  1  D8                   cld
000C5A  1  08 68 48 C9          tst_stat $ff-decmode
000C5E  1  F7 D0 FE 28  
000C62  1  F8                   sed
000C63  1  08 68 48 C9          tst_stat $ff
000C67  1  FF D0 FE 28  
000C6B  1  B8                   clv
000C6C  1  08 68 48 C9          tst_stat $ff-overfl
000C70  1  BF D0 FE 28  
000C74  1  A9 00 48 28          set_stat 0
000C78  1  08 68 48 C9          tst_stat 0
000C7C  1  30 D0 FE 28  
000C80  1  38                   sec
000C81  1  08 68 48 C9          tst_stat carry
000C85  1  31 D0 FE 28  
000C89  1  18                   clc
000C8A  1  08 68 48 C9          tst_stat 0
000C8E  1  30 D0 FE 28  
000C92  1                   .if I_flag = 3
000C92  1  78                   sei
000C93  1  08 68 48 C9          tst_stat intdis
000C97  1  34 D0 FE 28  
000C9B  1  58                   cli
000C9C  1  08 68 48 C9          tst_stat 0
000CA0  1  30 D0 FE 28  
000CA4  1                   .endif
000CA4  1  F8                   sed
000CA5  1  08 68 48 C9          tst_stat decmode
000CA9  1  38 D0 FE 28  
000CAD  1  D8                   cld
000CAE  1  08 68 48 C9          tst_stat 0
000CB2  1  30 D0 FE 28  
000CB6  1  A9 40 48 28          set_stat overfl
000CBA  1  08 68 48 C9          tst_stat overfl
000CBE  1  70 D0 FE 28  
000CC2  1  B8                   clv
000CC3  1  08 68 48 C9          tst_stat 0
000CC7  1  30 D0 FE 28  
000CCB  1  AD 00 02 C9          next_test
000CCF  1  0C D0 FE A9  
000CD3  1  0D 8D 00 02  
000CD7  1               ; testing index register increment/decrement and transfer
000CD7  1               ; INX INY DEX DEY TAX TXA TAY TYA
000CD7  1  A2 FE                ldx #$fe
000CD9  1  A9 FF 48 28          set_stat $ff
000CDD  1  E8                   inx             ;ff
000CDE  1  08 E0 FF D0          tst_x $ff,$ff-zero
000CE2  1  FE 68 48 C9  
000CE6  1  FD D0 FE 28  
000CEA  1  E8                   inx             ;00
000CEB  1  08 E0 00 D0          tst_x 0,$ff-minus
000CEF  1  FE 68 48 C9  
000CF3  1  7F D0 FE 28  
000CF7  1  E8                   inx             ;01
000CF8  1  08 E0 01 D0          tst_x 1,$ff-minus-zero
000CFC  1  FE 68 48 C9  
000D00  1  7D D0 FE 28  
000D04  1  CA                   dex             ;00
000D05  1  08 E0 00 D0          tst_x 0,$ff-minus
000D09  1  FE 68 48 C9  
000D0D  1  7F D0 FE 28  
000D11  1  CA                   dex             ;ff
000D12  1  08 E0 FF D0          tst_x $ff,$ff-zero
000D16  1  FE 68 48 C9  
000D1A  1  FD D0 FE 28  
000D1E  1  CA                   dex             ;fe
000D1F  1  A9 00 48 28          set_stat 0
000D23  1  E8                   inx             ;ff
000D24  1  08 E0 FF D0          tst_x $ff,minus
000D28  1  FE 68 48 C9  
000D2C  1  B0 D0 FE 28  
000D30  1  E8                   inx             ;00
000D31  1  08 E0 00 D0          tst_x 0,zero
000D35  1  FE 68 48 C9  
000D39  1  32 D0 FE 28  
000D3D  1  E8                   inx             ;01
000D3E  1  08 E0 01 D0          tst_x 1,0
000D42  1  FE 68 48 C9  
000D46  1  30 D0 FE 28  
000D4A  1  CA                   dex             ;00
000D4B  1  08 E0 00 D0          tst_x 0,zero
000D4F  1  FE 68 48 C9  
000D53  1  32 D0 FE 28  
000D57  1  CA                   dex             ;ff
000D58  1  08 E0 FF D0          tst_x $ff,minus
000D5C  1  FE 68 48 C9  
000D60  1  B0 D0 FE 28  
000D64  1               
000D64  1  A0 FE                ldy #$fe
000D66  1  A9 FF 48 28          set_stat $ff
000D6A  1  C8                   iny             ;ff
000D6B  1  08 C0 FF D0          tst_y $ff,$ff-zero
000D6F  1  FE 68 48 C9  
000D73  1  FD D0 FE 28  
000D77  1  C8                   iny             ;00
000D78  1  08 C0 00 D0          tst_y 0,$ff-minus
000D7C  1  FE 68 48 C9  
000D80  1  7F D0 FE 28  
000D84  1  C8                   iny             ;01
000D85  1  08 C0 01 D0          tst_y 1,$ff-minus-zero
000D89  1  FE 68 48 C9  
000D8D  1  7D D0 FE 28  
000D91  1  88                   dey             ;00
000D92  1  08 C0 00 D0          tst_y 0,$ff-minus
000D96  1  FE 68 48 C9  
000D9A  1  7F D0 FE 28  
000D9E  1  88                   dey             ;ff
000D9F  1  08 C0 FF D0          tst_y $ff,$ff-zero
000DA3  1  FE 68 48 C9  
000DA7  1  FD D0 FE 28  
000DAB  1  88                   dey             ;fe
000DAC  1  A9 00 48 28          set_stat 0
000DB0  1  C8                   iny             ;ff
000DB1  1  08 C0 FF D0          tst_y $ff,0+minus
000DB5  1  FE 68 48 C9  
000DB9  1  B0 D0 FE 28  
000DBD  1  C8                   iny             ;00
000DBE  1  08 C0 00 D0          tst_y 0,zero
000DC2  1  FE 68 48 C9  
000DC6  1  32 D0 FE 28  
000DCA  1  C8                   iny             ;01
000DCB  1  08 C0 01 D0          tst_y 1,0
000DCF  1  FE 68 48 C9  
000DD3  1  30 D0 FE 28  
000DD7  1  88                   dey             ;00
000DD8  1  08 C0 00 D0          tst_y 0,zero
000DDC  1  FE 68 48 C9  
000DE0  1  32 D0 FE 28  
000DE4  1  88                   dey             ;ff
000DE5  1  08 C0 FF D0          tst_y $ff,minus
000DE9  1  FE 68 48 C9  
000DED  1  B0 D0 FE 28  
000DF1  1               
000DF1  1  A2 FF                ldx #$ff
000DF3  1  A9 FF 48 28          set_stat $ff
000DF7  1  8A                   txa
000DF8  1  08 C9 FF D0          tst_a $ff,$ff-zero
000DFC  1  FE 68 48 C9  
000E00  1  FD D0 FE 28  
000E04  1  08                   php
000E05  1  E8                   inx             ;00
000E06  1  28                   plp
000E07  1  8A                   txa
000E08  1  08 C9 00 D0          tst_a 0,$ff-minus
000E0C  1  FE 68 48 C9  
000E10  1  7F D0 FE 28  
000E14  1  08                   php
000E15  1  E8                   inx             ;01
000E16  1  28                   plp
000E17  1  8A                   txa
000E18  1  08 C9 01 D0          tst_a 1,$ff-minus-zero
000E1C  1  FE 68 48 C9  
000E20  1  7D D0 FE 28  
000E24  1  A9 00 48 28          set_stat 0
000E28  1  8A                   txa
000E29  1  08 C9 01 D0          tst_a 1,0
000E2D  1  FE 68 48 C9  
000E31  1  30 D0 FE 28  
000E35  1  08                   php
000E36  1  CA                   dex             ;00
000E37  1  28                   plp
000E38  1  8A                   txa
000E39  1  08 C9 00 D0          tst_a 0,zero
000E3D  1  FE 68 48 C9  
000E41  1  32 D0 FE 28  
000E45  1  08                   php
000E46  1  CA                   dex             ;ff
000E47  1  28                   plp
000E48  1  8A                   txa
000E49  1  08 C9 FF D0          tst_a $ff,minus
000E4D  1  FE 68 48 C9  
000E51  1  B0 D0 FE 28  
000E55  1               
000E55  1  A0 FF                ldy #$ff
000E57  1  A9 FF 48 28          set_stat $ff
000E5B  1  98                   tya
000E5C  1  08 C9 FF D0          tst_a $ff,$ff-zero
000E60  1  FE 68 48 C9  
000E64  1  FD D0 FE 28  
000E68  1  08                   php
000E69  1  C8                   iny             ;00
000E6A  1  28                   plp
000E6B  1  98                   tya
000E6C  1  08 C9 00 D0          tst_a 0,$ff-minus
000E70  1  FE 68 48 C9  
000E74  1  7F D0 FE 28  
000E78  1  08                   php
000E79  1  C8                   iny             ;01
000E7A  1  28                   plp
000E7B  1  98                   tya
000E7C  1  08 C9 01 D0          tst_a 1,$ff-minus-zero
000E80  1  FE 68 48 C9  
000E84  1  7D D0 FE 28  
000E88  1  A9 00 48 28          set_stat 0
000E8C  1  98                   tya
000E8D  1  08 C9 01 D0          tst_a 1,0
000E91  1  FE 68 48 C9  
000E95  1  30 D0 FE 28  
000E99  1  08                   php
000E9A  1  88                   dey             ;00
000E9B  1  28                   plp
000E9C  1  98                   tya
000E9D  1  08 C9 00 D0          tst_a 0,zero
000EA1  1  FE 68 48 C9  
000EA5  1  32 D0 FE 28  
000EA9  1  08                   php
000EAA  1  88                   dey             ;ff
000EAB  1  28                   plp
000EAC  1  98                   tya
000EAD  1  08 C9 FF D0          tst_a $ff,minus
000EB1  1  FE 68 48 C9  
000EB5  1  B0 D0 FE 28  
000EB9  1               
000EB9  1  A9 FF                load_flag $ff
000EBB  1  48                   pha
000EBC  1  A2 FF                ldx #$ff        ;ff
000EBE  1  8A                   txa
000EBF  1  28                   plp
000EC0  1  A8                   tay
000EC1  1  08 C0 FF D0          tst_y $ff,$ff-zero
000EC5  1  FE 68 48 C9  
000EC9  1  FD D0 FE 28  
000ECD  1  08                   php
000ECE  1  E8                   inx             ;00
000ECF  1  8A                   txa
000ED0  1  28                   plp
000ED1  1  A8                   tay
000ED2  1  08 C0 00 D0          tst_y 0,$ff-minus
000ED6  1  FE 68 48 C9  
000EDA  1  7F D0 FE 28  
000EDE  1  08                   php
000EDF  1  E8                   inx             ;01
000EE0  1  8A                   txa
000EE1  1  28                   plp
000EE2  1  A8                   tay
000EE3  1  08 C0 01 D0          tst_y 1,$ff-minus-zero
000EE7  1  FE 68 48 C9  
000EEB  1  7D D0 FE 28  
000EEF  1  A9 00                load_flag 0
000EF1  1  48                   pha
000EF2  1  A9 00                lda #0
000EF4  1  8A                   txa
000EF5  1  28                   plp
000EF6  1  A8                   tay
000EF7  1  08 C0 01 D0          tst_y 1,0
000EFB  1  FE 68 48 C9  
000EFF  1  30 D0 FE 28  
000F03  1  08                   php
000F04  1  CA                   dex             ;00
000F05  1  8A                   txa
000F06  1  28                   plp
000F07  1  A8                   tay
000F08  1  08 C0 00 D0          tst_y 0,zero
000F0C  1  FE 68 48 C9  
000F10  1  32 D0 FE 28  
000F14  1  08                   php
000F15  1  CA                   dex             ;ff
000F16  1  8A                   txa
000F17  1  28                   plp
000F18  1  A8                   tay
000F19  1  08 C0 FF D0          tst_y $ff,minus
000F1D  1  FE 68 48 C9  
000F21  1  B0 D0 FE 28  
000F25  1               
000F25  1               
000F25  1  A9 FF                load_flag $ff
000F27  1  48                   pha
000F28  1  A0 FF                ldy #$ff        ;ff
000F2A  1  98                   tya
000F2B  1  28                   plp
000F2C  1  AA                   tax
000F2D  1  08 E0 FF D0          tst_x $ff,$ff-zero
000F31  1  FE 68 48 C9  
000F35  1  FD D0 FE 28  
000F39  1  08                   php
000F3A  1  C8                   iny             ;00
000F3B  1  98                   tya
000F3C  1  28                   plp
000F3D  1  AA                   tax
000F3E  1  08 E0 00 D0          tst_x 0,$ff-minus
000F42  1  FE 68 48 C9  
000F46  1  7F D0 FE 28  
000F4A  1  08                   php
000F4B  1  C8                   iny             ;01
000F4C  1  98                   tya
000F4D  1  28                   plp
000F4E  1  AA                   tax
000F4F  1  08 E0 01 D0          tst_x 1,$ff-minus-zero
000F53  1  FE 68 48 C9  
000F57  1  7D D0 FE 28  
000F5B  1  A9 00                load_flag 0
000F5D  1  48                   pha
000F5E  1  A9 00                lda #0          ;preset status
000F60  1  98                   tya
000F61  1  28                   plp
000F62  1  AA                   tax
000F63  1  08 E0 01 D0          tst_x 1,0
000F67  1  FE 68 48 C9  
000F6B  1  30 D0 FE 28  
000F6F  1  08                   php
000F70  1  88                   dey             ;00
000F71  1  98                   tya
000F72  1  28                   plp
000F73  1  AA                   tax
000F74  1  08 E0 00 D0          tst_x 0,zero
000F78  1  FE 68 48 C9  
000F7C  1  32 D0 FE 28  
000F80  1  08                   php
000F81  1  88                   dey             ;ff
000F82  1  98                   tya
000F83  1  28                   plp
000F84  1  AA                   tax
000F85  1  08 E0 FF D0          tst_x $ff,minus
000F89  1  FE 68 48 C9  
000F8D  1  B0 D0 FE 28  
000F91  1  AD 00 02 C9          next_test
000F95  1  0D D0 FE A9  
000F99  1  0E 8D 00 02  
000F9D  1               
000F9D  1               ;TSX sets NZ - TXS does not
000F9D  1               ;  This section also tests for proper stack wrap around.
000F9D  1  A2 01                ldx #1          ;01
000F9F  1  A9 FF 48 28          set_stat $ff
000FA3  1  9A                   txs
000FA4  1  08                   php
000FA5  1  AD 01 01             lda $101
000FA8  1  C9 FF                cmp_flag $ff
000FAA  1  D0 FE                trap_ne
000FAC  1  A9 00 48 28          set_stat 0
000FB0  1  9A                   txs
000FB1  1  08                   php
000FB2  1  AD 01 01             lda $101
000FB5  1  C9 30                cmp_flag 0
000FB7  1  D0 FE                trap_ne
000FB9  1  CA                   dex             ;00
000FBA  1  A9 FF 48 28          set_stat $ff
000FBE  1  9A                   txs
000FBF  1  08                   php
000FC0  1  AD 00 01             lda $100
000FC3  1  C9 FF                cmp_flag $ff
000FC5  1  D0 FE                trap_ne
000FC7  1  A9 00 48 28          set_stat 0
000FCB  1  9A                   txs
000FCC  1  08                   php
000FCD  1  AD 00 01             lda $100
000FD0  1  C9 30                cmp_flag 0
000FD2  1  D0 FE                trap_ne
000FD4  1  CA                   dex             ;ff
000FD5  1  A9 FF 48 28          set_stat $ff
000FD9  1  9A                   txs
000FDA  1  08                   php
000FDB  1  AD FF 01             lda $1ff
000FDE  1  C9 FF                cmp_flag $ff
000FE0  1  D0 FE                trap_ne
000FE2  1  A9 00 48 28          set_stat 0
000FE6  1  9A                   txs
000FE7  1  08                   php
000FE8  1  AD FF 01             lda $1ff
000FEB  1  C9 30                cmp_flag 0
000FED  1               
000FED  1  A2 01                ldx #1
000FEF  1  9A                   txs             ;sp=01
000FF0  1  A9 FF 48 28          set_stat $ff
000FF4  1  BA                   tsx             ;clears Z, N
000FF5  1  08                   php             ;sp=00
000FF6  1  E0 01                cpx #1
000FF8  1  D0 FE                trap_ne
000FFA  1  AD 01 01             lda $101
000FFD  1  C9 7D                cmp_flag $ff-minus-zero
000FFF  1  D0 FE                trap_ne
001001  1  A9 FF 48 28          set_stat $ff
001005  1  BA                   tsx             ;clears N, sets Z
001006  1  08                   php             ;sp=ff
001007  1  E0 00                cpx #0
001009  1  D0 FE                trap_ne
00100B  1  AD 00 01             lda $100
00100E  1  C9 7F                cmp_flag $ff-minus
001010  1  D0 FE                trap_ne
001012  1  A9 FF 48 28          set_stat $ff
001016  1  BA                   tsx             ;clears N, sets Z
001017  1  08                   php             ;sp=fe
001018  1  E0 FF                cpx #$ff
00101A  1  D0 FE                trap_ne
00101C  1  AD FF 01             lda $1ff
00101F  1  C9 FD                cmp_flag $ff-zero
001021  1  D0 FE                trap_ne
001023  1               
001023  1  A2 01                ldx #1
001025  1  9A                   txs             ;sp=01
001026  1  A9 00 48 28          set_stat 0
00102A  1  BA                   tsx             ;clears Z, N
00102B  1  08                   php             ;sp=00
00102C  1  E0 01                cpx #1
00102E  1  D0 FE                trap_ne
001030  1  AD 01 01             lda $101
001033  1  C9 30                cmp_flag 0
001035  1  D0 FE                trap_ne
001037  1  A9 00 48 28          set_stat 0
00103B  1  BA                   tsx             ;clears N, sets Z
00103C  1  08                   php             ;sp=ff
00103D  1  E0 00                cpx #0
00103F  1  D0 FE                trap_ne
001041  1  AD 00 01             lda $100
001044  1  C9 32                cmp_flag zero
001046  1  D0 FE                trap_ne
001048  1  A9 00 48 28          set_stat 0
00104C  1  BA                   tsx             ;clears N, sets Z
00104D  1  08                   php             ;sp=fe
00104E  1  E0 FF                cpx #$ff
001050  1  D0 FE                trap_ne
001052  1  AD FF 01             lda $1ff
001055  1  C9 B0                cmp_flag minus
001057  1  D0 FE                trap_ne
001059  1  68                   pla             ;sp=ff
00105A  1  AD 00 02 C9          next_test
00105E  1  0E D0 FE A9  
001062  1  0F 8D 00 02  
001066  1               
001066  1               ; testing index register load & store LDY LDX STY STX all addressing modes
001066  1               ; LDX / STX - zp,y / abs,y
001066  1  A0 03                ldy #3
001068  1               tldx:
001068  1  A9 00 48 28          set_stat 0
00106C  1  B6 09                ldx zp1,y
00106E  1  08                   php         ;test stores do not alter flags
00106F  1  8A                   txa
001070  1  49 C3                eor #$c3
001072  1  28                   plp
001073  1  99 03 02             sta abst,y
001076  1  08                   php         ;flags after load/store sequence
001077  1  49 C3                eor #$c3
001079  1  D9 17 02             cmp abs1,y  ;test result
00107C  1  D0 FE                trap_ne
00107E  1  68                   pla         ;load status
00107F  1  49 30                eor_flag 0
001081  1  D9 1C 02             cmp fLDx,y  ;test flags
001084  1  D0 FE                trap_ne
001086  1  88                   dey
001087  1  10 DF                bpl tldx
001089  1               
001089  1  A0 03                ldy #3
00108B  1               tldx1:
00108B  1  A9 FF 48 28          set_stat $ff
00108F  1  B6 09                ldx zp1,y
001091  1  08                   php         ;test stores do not alter flags
001092  1  8A                   txa
001093  1  49 C3                eor #$c3
001095  1  28                   plp
001096  1  99 03 02             sta abst,y
001099  1  08                   php         ;flags after load/store sequence
00109A  1  49 C3                eor #$c3
00109C  1  D9 17 02             cmp abs1,y  ;test result
00109F  1  D0 FE                trap_ne
0010A1  1  68                   pla         ;load status
0010A2  1  49 7D                eor_flag <~fnz ;mask bits not altered
0010A4  1  D9 1C 02             cmp fLDx,y  ;test flags
0010A7  1  D0 FE                trap_ne
0010A9  1  88                   dey
0010AA  1  10 DF                bpl tldx1
0010AC  1               
0010AC  1  A0 03                ldy #3
0010AE  1               tldx2:
0010AE  1  A9 00 48 28          set_stat 0
0010B2  1  BE 17 02             ldx abs1,y
0010B5  1  08                   php         ;test stores do not alter flags
0010B6  1  8A                   txa
0010B7  1  49 C3                eor #$c3
0010B9  1  AA                   tax
0010BA  1  28                   plp
0010BB  1  96 02                stx zpt,y
0010BD  1  08                   php         ;flags after load/store sequence
0010BE  1  49 C3                eor #$c3
0010C0  1  D9 09 00             cmp zp1,y   ;test result
0010C3  1  D0 FE                trap_ne
0010C5  1  68                   pla         ;load status
0010C6  1  49 30                eor_flag 0
0010C8  1  D9 1C 02             cmp fLDx,y  ;test flags
0010CB  1  D0 FE                trap_ne
0010CD  1  88                   dey
0010CE  1  10 DE                bpl tldx2
0010D0  1               
0010D0  1  A0 03                ldy #3
0010D2  1               tldx3:
0010D2  1  A9 FF 48 28          set_stat $ff
0010D6  1  BE 17 02             ldx abs1,y
0010D9  1  08                   php         ;test stores do not alter flags
0010DA  1  8A                   txa
0010DB  1  49 C3                eor #$c3
0010DD  1  AA                   tax
0010DE  1  28                   plp
0010DF  1  96 02                stx zpt,y
0010E1  1  08                   php         ;flags after load/store sequence
0010E2  1  49 C3                eor #$c3
0010E4  1  D9 09 00             cmp zp1,y   ;test result
0010E7  1  D0 FE                trap_ne
0010E9  1  68                   pla         ;load status
0010EA  1  49 7D                eor_flag <~fnz ;mask bits not altered
0010EC  1  D9 1C 02             cmp fLDx,y  ;test flags
0010EF  1  D0 FE                trap_ne
0010F1  1  88                   dey
0010F2  1  10 DE                bpl tldx3
0010F4  1               
0010F4  1  A0 03                ldy #3      ;testing store result
0010F6  1  A2 00                ldx #0
0010F8  1  B9 02 00     tstx:   lda zpt,y
0010FB  1  49 C3                eor #$c3
0010FD  1  D9 09 00             cmp zp1,y
001100  1  D0 FE                trap_ne     ;store to zp data
001102  1  96 02                stx zpt,y   ;clear
001104  1  B9 03 02             lda abst,y
001107  1  49 C3                eor #$c3
001109  1  D9 17 02             cmp abs1,y
00110C  1  D0 FE                trap_ne     ;store to abs data
00110E  1  8A                   txa
00110F  1  99 03 02             sta abst,y  ;clear
001112  1  88                   dey
001113  1  10 E3                bpl tstx
001115  1  AD 00 02 C9          next_test
001119  1  0F D0 FE A9  
00111D  1  10 8D 00 02  
001121  1               
001121  1               ; indexed wraparound test (only zp should wrap)
001121  1  A0 FD                ldy #3+$fa
001123  1  B6 0F        tldx4:  ldx <(zp1-$fa),y   ;wrap on indexed zp
001125  1  8A                   txa
001126  1  99 09 01             sta abst-$fa,y      ;no STX abs,y!
001129  1  88                   dey
00112A  1  C0 FA                cpy #$fa
00112C  1  B0 F5                bcs tldx4
00112E  1  A0 FD                ldy #3+$fa
001130  1  BE 1D 01     tldx5:  ldx abs1-$fa,y      ;no wrap on indexed abs
001133  1  96 08                stx <(zpt-$fa),y
001135  1  88                   dey
001136  1  C0 FA                cpy #$fa
001138  1  B0 F6                bcs tldx5
00113A  1  A0 03                ldy #3      ;testing wraparound result
00113C  1  A2 00                ldx #0
00113E  1  B9 02 00     tstx1:  lda zpt,y
001141  1  D9 09 00             cmp zp1,y
001144  1  D0 FE                trap_ne     ;store to zp data
001146  1  96 02                stx zpt,y   ;clear
001148  1  B9 03 02             lda abst,y
00114B  1  D9 17 02             cmp abs1,y
00114E  1  D0 FE                trap_ne     ;store to abs data
001150  1  8A                   txa
001151  1  99 03 02             sta abst,y  ;clear
001154  1  88                   dey
001155  1  10 E7                bpl tstx1
001157  1  AD 00 02 C9          next_test
00115B  1  10 D0 FE A9  
00115F  1  11 8D 00 02  
001163  1               
001163  1               ; LDY / STY - zp,x / abs,x
001163  1  A2 03                ldx #3
001165  1               tldy:
001165  1  A9 00 48 28          set_stat 0
001169  1  B4 09                ldy zp1,x
00116B  1  08                   php         ;test stores do not alter flags
00116C  1  98                   tya
00116D  1  49 C3                eor #$c3
00116F  1  28                   plp
001170  1  9D 03 02             sta abst,x
001173  1  08                   php         ;flags after load/store sequence
001174  1  49 C3                eor #$c3
001176  1  DD 17 02             cmp abs1,x  ;test result
001179  1  D0 FE                trap_ne
00117B  1  68                   pla         ;load status
00117C  1  49 30                eor_flag 0
00117E  1  DD 1C 02             cmp fLDx,x  ;test flags
001181  1  D0 FE                trap_ne
001183  1  CA                   dex
001184  1  10 DF                bpl tldy
001186  1               
001186  1  A2 03                ldx #3
001188  1               tldy1:
001188  1  A9 FF 48 28          set_stat $ff
00118C  1  B4 09                ldy zp1,x
00118E  1  08                   php         ;test stores do not alter flags
00118F  1  98                   tya
001190  1  49 C3                eor #$c3
001192  1  28                   plp
001193  1  9D 03 02             sta abst,x
001196  1  08                   php         ;flags after load/store sequence
001197  1  49 C3                eor #$c3
001199  1  DD 17 02             cmp abs1,x  ;test result
00119C  1  D0 FE                trap_ne
00119E  1  68                   pla         ;load status
00119F  1  49 7D                eor_flag <~fnz ;mask bits not altered
0011A1  1  DD 1C 02             cmp fLDx,x  ;test flags
0011A4  1  D0 FE                trap_ne
0011A6  1  CA                   dex
0011A7  1  10 DF                bpl tldy1
0011A9  1               
0011A9  1  A2 03                ldx #3
0011AB  1               tldy2:
0011AB  1  A9 00 48 28          set_stat 0
0011AF  1  BC 17 02             ldy abs1,x
0011B2  1  08                   php         ;test stores do not alter flags
0011B3  1  98                   tya
0011B4  1  49 C3                eor #$c3
0011B6  1  A8                   tay
0011B7  1  28                   plp
0011B8  1  94 02                sty zpt,x
0011BA  1  08                   php         ;flags after load/store sequence
0011BB  1  49 C3                eor #$c3
0011BD  1  D5 09                cmp zp1,x   ;test result
0011BF  1  D0 FE                trap_ne
0011C1  1  68                   pla         ;load status
0011C2  1  49 30                eor_flag 0
0011C4  1  DD 1C 02             cmp fLDx,x  ;test flags
0011C7  1  D0 FE                trap_ne
0011C9  1  CA                   dex
0011CA  1  10 DF                bpl tldy2
0011CC  1               
0011CC  1  A2 03                ldx #3
0011CE  1               tldy3:
0011CE  1  A9 FF 48 28          set_stat $ff
0011D2  1  BC 17 02             ldy abs1,x
0011D5  1  08                   php         ;test stores do not alter flags
0011D6  1  98                   tya
0011D7  1  49 C3                eor #$c3
0011D9  1  A8                   tay
0011DA  1  28                   plp
0011DB  1  94 02                sty zpt,x
0011DD  1  08                   php         ;flags after load/store sequence
0011DE  1  49 C3                eor #$c3
0011E0  1  D5 09                cmp zp1,x   ;test result
0011E2  1  D0 FE                trap_ne
0011E4  1  68                   pla         ;load status
0011E5  1  49 7D                eor_flag <~fnz ;mask bits not altered
0011E7  1  DD 1C 02             cmp fLDx,x  ;test flags
0011EA  1  D0 FE                trap_ne
0011EC  1  CA                   dex
0011ED  1  10 DF                bpl tldy3
0011EF  1               
0011EF  1  A2 03                ldx #3      ;testing store result
0011F1  1  A0 00                ldy #0
0011F3  1  B5 02        tsty:   lda zpt,x
0011F5  1  49 C3                eor #$c3
0011F7  1  D5 09                cmp zp1,x
0011F9  1  D0 FE                trap_ne     ;store to zp,x data
0011FB  1  94 02                sty zpt,x   ;clear
0011FD  1  BD 03 02             lda abst,x
001200  1  49 C3                eor #$c3
001202  1  DD 17 02             cmp abs1,x
001205  1  D0 FE                trap_ne     ;store to abs,x data
001207  1  8A                   txa
001208  1  9D 03 02             sta abst,x  ;clear
00120B  1  CA                   dex
00120C  1  10 E5                bpl tsty
00120E  1  AD 00 02 C9          next_test
001212  1  11 D0 FE A9  
001216  1  12 8D 00 02  
00121A  1               
00121A  1               ; indexed wraparound test (only zp should wrap)
00121A  1  A2 FD                ldx #3+$fa
00121C  1  B4 0F        tldy4:  ldy <(zp1-$fa),x   ;wrap on indexed zp
00121E  1  98                   tya
00121F  1  9D 09 01             sta abst-$fa,x      ;no STX abs,x!
001222  1  CA                   dex
001223  1  E0 FA                cpx #$fa
001225  1  B0 F5                bcs tldy4
001227  1  A2 FD                ldx #3+$fa
001229  1  BC 1D 01     tldy5:  ldy abs1-$fa,x      ;no wrap on indexed abs
00122C  1  94 08                sty <(zpt-$fa),x
00122E  1  CA                   dex
00122F  1  E0 FA                cpx #$fa
001231  1  B0 F6                bcs tldy5
001233  1  A2 03                ldx #3      ;testing wraparound result
001235  1  A0 00                ldy #0
001237  1  B5 02        tsty1:  lda zpt,x
001239  1  D5 09                cmp zp1,x
00123B  1  D0 FE                trap_ne     ;store to zp,x data
00123D  1  94 02                sty zpt,x   ;clear
00123F  1  BD 03 02             lda abst,x
001242  1  DD 17 02             cmp abs1,x
001245  1  D0 FE                trap_ne     ;store to abs,x data
001247  1  8A                   txa
001248  1  9D 03 02             sta abst,x  ;clear
00124B  1  CA                   dex
00124C  1  10 E9                bpl tsty1
00124E  1  AD 00 02 C9          next_test
001252  1  12 D0 FE A9  
001256  1  13 8D 00 02  
00125A  1               
00125A  1               ; LDX / STX - zp / abs / #
00125A  1  A9 00 48 28          set_stat 0
00125E  1  A6 09                ldx zp1
001260  1  08                   php         ;test stores do not alter flags
001261  1  8A                   txa
001262  1  49 C3                eor #$c3
001264  1  AA                   tax
001265  1  28                   plp
001266  1  8E 03 02             stx abst
001269  1  08                   php         ;flags after load/store sequence
00126A  1  49 C3                eor #$c3
00126C  1  AA                   tax
00126D  1  E0 C3                cpx #$c3    ;test result
00126F  1  D0 FE                trap_ne
001271  1  68                   pla         ;load status
001272  1  49 30                eor_flag 0
001274  1  CD 1C 02             cmp fLDx    ;test flags
001277  1  D0 FE                trap_ne
001279  1  A9 00 48 28          set_stat 0
00127D  1  A6 0A                ldx zp1+1
00127F  1  08                   php         ;test stores do not alter flags
001280  1  8A                   txa
001281  1  49 C3                eor #$c3
001283  1  AA                   tax
001284  1  28                   plp
001285  1  8E 04 02             stx abst+1
001288  1  08                   php         ;flags after load/store sequence
001289  1  49 C3                eor #$c3
00128B  1  AA                   tax
00128C  1  E0 82                cpx #$82    ;test result
00128E  1  D0 FE                trap_ne
001290  1  68                   pla         ;load status
001291  1  49 30                eor_flag 0
001293  1  CD 1D 02             cmp fLDx+1  ;test flags
001296  1  D0 FE                trap_ne
001298  1  A9 00 48 28          set_stat 0
00129C  1  A6 0B                ldx zp1+2
00129E  1  08                   php         ;test stores do not alter flags
00129F  1  8A                   txa
0012A0  1  49 C3                eor #$c3
0012A2  1  AA                   tax
0012A3  1  28                   plp
0012A4  1  8E 05 02             stx abst+2
0012A7  1  08                   php         ;flags after load/store sequence
0012A8  1  49 C3                eor #$c3
0012AA  1  AA                   tax
0012AB  1  E0 41                cpx #$41    ;test result
0012AD  1  D0 FE                trap_ne
0012AF  1  68                   pla         ;load status
0012B0  1  49 30                eor_flag 0
0012B2  1  CD 1E 02             cmp fLDx+2  ;test flags
0012B5  1  D0 FE                trap_ne
0012B7  1  A9 00 48 28          set_stat 0
0012BB  1  A6 0C                ldx zp1+3
0012BD  1  08                   php         ;test stores do not alter flags
0012BE  1  8A                   txa
0012BF  1  49 C3                eor #$c3
0012C1  1  AA                   tax
0012C2  1  28                   plp
0012C3  1  8E 06 02             stx abst+3
0012C6  1  08                   php         ;flags after load/store sequence
0012C7  1  49 C3                eor #$c3
0012C9  1  AA                   tax
0012CA  1  E0 00                cpx #0      ;test result
0012CC  1  D0 FE                trap_ne
0012CE  1  68                   pla         ;load status
0012CF  1  49 30                eor_flag 0
0012D1  1  CD 1F 02             cmp fLDx+3  ;test flags
0012D4  1  D0 FE                trap_ne
0012D6  1               
0012D6  1  A9 FF 48 28          set_stat $ff
0012DA  1  A6 09                ldx zp1
0012DC  1  08                   php         ;test stores do not alter flags
0012DD  1  8A                   txa
0012DE  1  49 C3                eor #$c3
0012E0  1  AA                   tax
0012E1  1  28                   plp
0012E2  1  8E 03 02             stx abst
0012E5  1  08                   php         ;flags after load/store sequence
0012E6  1  49 C3                eor #$c3
0012E8  1  AA                   tax
0012E9  1  E0 C3                cpx #$c3    ;test result
0012EB  1  D0 FE                trap_ne     ;
0012ED  1  68                   pla         ;load status
0012EE  1  49 7D                eor_flag <~fnz ;mask bits not altered
0012F0  1  CD 1C 02             cmp fLDx    ;test flags
0012F3  1  D0 FE                trap_ne
0012F5  1  A9 FF 48 28          set_stat $ff
0012F9  1  A6 0A                ldx zp1+1
0012FB  1  08                   php         ;test stores do not alter flags
0012FC  1  8A                   txa
0012FD  1  49 C3                eor #$c3
0012FF  1  AA                   tax
001300  1  28                   plp
001301  1  8E 04 02             stx abst+1
001304  1  08                   php         ;flags after load/store sequence
001305  1  49 C3                eor #$c3
001307  1  AA                   tax
001308  1  E0 82                cpx #$82    ;test result
00130A  1  D0 FE                trap_ne
00130C  1  68                   pla         ;load status
00130D  1  49 7D                eor_flag <~fnz ;mask bits not altered
00130F  1  CD 1D 02             cmp fLDx+1  ;test flags
001312  1  D0 FE                trap_ne
001314  1  A9 FF 48 28          set_stat $ff
001318  1  A6 0B                ldx zp1+2
00131A  1  08                   php         ;test stores do not alter flags
00131B  1  8A                   txa
00131C  1  49 C3                eor #$c3
00131E  1  AA                   tax
00131F  1  28                   plp
001320  1  8E 05 02             stx abst+2
001323  1  08                   php         ;flags after load/store sequence
001324  1  49 C3                eor #$c3
001326  1  AA                   tax
001327  1  E0 41                cpx #$41    ;test result
001329  1  D0 FE                trap_ne     ;
00132B  1  68                   pla         ;load status
00132C  1  49 7D                eor_flag <~fnz ;mask bits not altered
00132E  1  CD 1E 02             cmp fLDx+2  ;test flags
001331  1  D0 FE                trap_ne
001333  1  A9 FF 48 28          set_stat $ff
001337  1  A6 0C                ldx zp1+3
001339  1  08                   php         ;test stores do not alter flags
00133A  1  8A                   txa
00133B  1  49 C3                eor #$c3
00133D  1  AA                   tax
00133E  1  28                   plp
00133F  1  8E 06 02             stx abst+3
001342  1  08                   php         ;flags after load/store sequence
001343  1  49 C3                eor #$c3
001345  1  AA                   tax
001346  1  E0 00                cpx #0      ;test result
001348  1  D0 FE                trap_ne
00134A  1  68                   pla         ;load status
00134B  1  49 7D                eor_flag <~fnz ;mask bits not altered
00134D  1  CD 1F 02             cmp fLDx+3  ;test flags
001350  1  D0 FE                trap_ne
001352  1               
001352  1  A9 00 48 28          set_stat 0
001356  1  AE 17 02             ldx abs1
001359  1  08                   php         ;test stores do not alter flags
00135A  1  8A                   txa
00135B  1  49 C3                eor #$c3
00135D  1  AA                   tax
00135E  1  28                   plp
00135F  1  86 02                stx zpt
001361  1  08                   php         ;flags after load/store sequence
001362  1  49 C3                eor #$c3
001364  1  C5 09                cmp zp1     ;test result
001366  1  D0 FE                trap_ne
001368  1  68                   pla         ;load status
001369  1  49 30                eor_flag 0
00136B  1  CD 1C 02             cmp fLDx    ;test flags
00136E  1  D0 FE                trap_ne
001370  1  A9 00 48 28          set_stat 0
001374  1  AE 18 02             ldx abs1+1
001377  1  08                   php         ;test stores do not alter flags
001378  1  8A                   txa
001379  1  49 C3                eor #$c3
00137B  1  AA                   tax
00137C  1  28                   plp
00137D  1  86 03                stx zpt+1
00137F  1  08                   php         ;flags after load/store sequence
001380  1  49 C3                eor #$c3
001382  1  C5 0A                cmp zp1+1   ;test result
001384  1  D0 FE                trap_ne
001386  1  68                   pla         ;load status
001387  1  49 30                eor_flag 0
001389  1  CD 1D 02             cmp fLDx+1  ;test flags
00138C  1  D0 FE                trap_ne
00138E  1  A9 00 48 28          set_stat 0
001392  1  AE 19 02             ldx abs1+2
001395  1  08                   php         ;test stores do not alter flags
001396  1  8A                   txa
001397  1  49 C3                eor #$c3
001399  1  AA                   tax
00139A  1  28                   plp
00139B  1  86 04                stx zpt+2
00139D  1  08                   php         ;flags after load/store sequence
00139E  1  49 C3                eor #$c3
0013A0  1  C5 0B                cmp zp1+2   ;test result
0013A2  1  D0 FE                trap_ne
0013A4  1  68                   pla         ;load status
0013A5  1  49 30                eor_flag 0
0013A7  1  CD 1E 02             cmp fLDx+2  ;test flags
0013AA  1  D0 FE                trap_ne
0013AC  1  A9 00 48 28          set_stat 0
0013B0  1  AE 1A 02             ldx abs1+3
0013B3  1  08                   php         ;test stores do not alter flags
0013B4  1  8A                   txa
0013B5  1  49 C3                eor #$c3
0013B7  1  AA                   tax
0013B8  1  28                   plp
0013B9  1  86 05                stx zpt+3
0013BB  1  08                   php         ;flags after load/store sequence
0013BC  1  49 C3                eor #$c3
0013BE  1  C5 0C                cmp zp1+3   ;test result
0013C0  1  D0 FE                trap_ne
0013C2  1  68                   pla         ;load status
0013C3  1  49 30                eor_flag 0
0013C5  1  CD 1F 02             cmp fLDx+3  ;test flags
0013C8  1  D0 FE                trap_ne
0013CA  1               
0013CA  1  A9 FF 48 28          set_stat $ff
0013CE  1  AE 17 02             ldx abs1
0013D1  1  08                   php         ;test stores do not alter flags
0013D2  1  8A                   txa
0013D3  1  49 C3                eor #$c3
0013D5  1  AA                   tax
0013D6  1  28                   plp
0013D7  1  86 02                stx zpt
0013D9  1  08                   php         ;flags after load/store sequence
0013DA  1  49 C3                eor #$c3
0013DC  1  AA                   tax
0013DD  1  E4 09                cpx zp1     ;test result
0013DF  1  D0 FE                trap_ne
0013E1  1  68                   pla         ;load status
0013E2  1  49 7D                eor_flag <~fnz ;mask bits not altered
0013E4  1  CD 1C 02             cmp fLDx    ;test flags
0013E7  1  D0 FE                trap_ne
0013E9  1  A9 FF 48 28          set_stat $ff
0013ED  1  AE 18 02             ldx abs1+1
0013F0  1  08                   php         ;test stores do not alter flags
0013F1  1  8A                   txa
0013F2  1  49 C3                eor #$c3
0013F4  1  AA                   tax
0013F5  1  28                   plp
0013F6  1  86 03                stx zpt+1
0013F8  1  08                   php         ;flags after load/store sequence
0013F9  1  49 C3                eor #$c3
0013FB  1  AA                   tax
0013FC  1  E4 0A                cpx zp1+1   ;test result
0013FE  1  D0 FE                trap_ne
001400  1  68                   pla         ;load status
001401  1  49 7D                eor_flag <~fnz ;mask bits not altered
001403  1  CD 1D 02             cmp fLDx+1  ;test flags
001406  1  D0 FE                trap_ne
001408  1  A9 FF 48 28          set_stat $ff
00140C  1  AE 19 02             ldx abs1+2
00140F  1  08                   php         ;test stores do not alter flags
001410  1  8A                   txa
001411  1  49 C3                eor #$c3
001413  1  AA                   tax
001414  1  28                   plp
001415  1  86 04                stx zpt+2
001417  1  08                   php         ;flags after load/store sequence
001418  1  49 C3                eor #$c3
00141A  1  AA                   tax
00141B  1  E4 0B                cpx zp1+2   ;test result
00141D  1  D0 FE                trap_ne
00141F  1  68                   pla         ;load status
001420  1  49 7D                eor_flag <~fnz ;mask bits not altered
001422  1  CD 1E 02             cmp fLDx+2  ;test flags
001425  1  D0 FE                trap_ne
001427  1  A9 FF 48 28          set_stat $ff
00142B  1  AE 1A 02             ldx abs1+3
00142E  1  08                   php         ;test stores do not alter flags
00142F  1  8A                   txa
001430  1  49 C3                eor #$c3
001432  1  AA                   tax
001433  1  28                   plp
001434  1  86 05                stx zpt+3
001436  1  08                   php         ;flags after load/store sequence
001437  1  49 C3                eor #$c3
001439  1  AA                   tax
00143A  1  E4 0C                cpx zp1+3   ;test result
00143C  1  D0 FE                trap_ne
00143E  1  68                   pla         ;load status
00143F  1  49 7D                eor_flag <~fnz ;mask bits not altered
001441  1  CD 1F 02             cmp fLDx+3  ;test flags
001444  1  D0 FE                trap_ne
001446  1               
001446  1  A9 00 48 28          set_stat 0
00144A  1  A2 C3                ldx #$c3
00144C  1  08                   php
00144D  1  EC 17 02             cpx abs1    ;test result
001450  1  D0 FE                trap_ne
001452  1  68                   pla         ;load status
001453  1  49 30                eor_flag 0
001455  1  CD 1C 02             cmp fLDx    ;test flags
001458  1  D0 FE                trap_ne
00145A  1  A9 00 48 28          set_stat 0
00145E  1  A2 82                ldx #$82
001460  1  08                   php
001461  1  EC 18 02             cpx abs1+1  ;test result
001464  1  D0 FE                trap_ne
001466  1  68                   pla         ;load status
001467  1  49 30                eor_flag 0
001469  1  CD 1D 02             cmp fLDx+1  ;test flags
00146C  1  D0 FE                trap_ne
00146E  1  A9 00 48 28          set_stat 0
001472  1  A2 41                ldx #$41
001474  1  08                   php
001475  1  EC 19 02             cpx abs1+2  ;test result
001478  1  D0 FE                trap_ne
00147A  1  68                   pla         ;load status
00147B  1  49 30                eor_flag 0
00147D  1  CD 1E 02             cmp fLDx+2  ;test flags
001480  1  D0 FE                trap_ne
001482  1  A9 00 48 28          set_stat 0
001486  1  A2 00                ldx #0
001488  1  08                   php
001489  1  EC 1A 02             cpx abs1+3  ;test result
00148C  1  D0 FE                trap_ne
00148E  1  68                   pla         ;load status
00148F  1  49 30                eor_flag 0
001491  1  CD 1F 02             cmp fLDx+3  ;test flags
001494  1  D0 FE                trap_ne
001496  1               
001496  1  A9 FF 48 28          set_stat $ff
00149A  1  A2 C3                ldx #$c3
00149C  1  08                   php
00149D  1  EC 17 02             cpx abs1    ;test result
0014A0  1  D0 FE                trap_ne
0014A2  1  68                   pla         ;load status
0014A3  1  49 7D                eor_flag <~fnz ;mask bits not altered
0014A5  1  CD 1C 02             cmp fLDx    ;test flags
0014A8  1  D0 FE                trap_ne
0014AA  1  A9 FF 48 28          set_stat $ff
0014AE  1  A2 82                ldx #$82
0014B0  1  08                   php
0014B1  1  EC 18 02             cpx abs1+1  ;test result
0014B4  1  D0 FE                trap_ne
0014B6  1  68                   pla         ;load status
0014B7  1  49 7D                eor_flag <~fnz ;mask bits not altered
0014B9  1  CD 1D 02             cmp fLDx+1  ;test flags
0014BC  1  D0 FE                trap_ne
0014BE  1  A9 FF 48 28          set_stat $ff
0014C2  1  A2 41                ldx #$41
0014C4  1  08                   php
0014C5  1  EC 19 02             cpx abs1+2  ;test result
0014C8  1  D0 FE                trap_ne
0014CA  1  68                   pla         ;load status
0014CB  1  49 7D                eor_flag <~fnz ;mask bits not altered
0014CD  1  CD 1E 02             cmp fLDx+2  ;test flags
0014D0  1  D0 FE                trap_ne
0014D2  1  A9 FF 48 28          set_stat $ff
0014D6  1  A2 00                ldx #0
0014D8  1  08                   php
0014D9  1  EC 1A 02             cpx abs1+3  ;test result
0014DC  1  D0 FE                trap_ne
0014DE  1  68                   pla         ;load status
0014DF  1  49 7D                eor_flag <~fnz ;mask bits not altered
0014E1  1  CD 1F 02             cmp fLDx+3  ;test flags
0014E4  1  D0 FE                trap_ne
0014E6  1               
0014E6  1  A2 00                ldx #0
0014E8  1  A5 02                lda zpt
0014EA  1  49 C3                eor #$c3
0014EC  1  C5 09                cmp zp1
0014EE  1  D0 FE                trap_ne     ;store to zp data
0014F0  1  86 02                stx zpt     ;clear
0014F2  1  AD 03 02             lda abst
0014F5  1  49 C3                eor #$c3
0014F7  1  CD 17 02             cmp abs1
0014FA  1  D0 FE                trap_ne     ;store to abs data
0014FC  1  8E 03 02             stx abst    ;clear
0014FF  1  A5 03                lda zpt+1
001501  1  49 C3                eor #$c3
001503  1  C5 0A                cmp zp1+1
001505  1  D0 FE                trap_ne     ;store to zp data
001507  1  86 03                stx zpt+1   ;clear
001509  1  AD 04 02             lda abst+1
00150C  1  49 C3                eor #$c3
00150E  1  CD 18 02             cmp abs1+1
001511  1  D0 FE                trap_ne     ;store to abs data
001513  1  8E 04 02             stx abst+1  ;clear
001516  1  A5 04                lda zpt+2
001518  1  49 C3                eor #$c3
00151A  1  C5 0B                cmp zp1+2
00151C  1  D0 FE                trap_ne     ;store to zp data
00151E  1  86 04                stx zpt+2   ;clear
001520  1  AD 05 02             lda abst+2
001523  1  49 C3                eor #$c3
001525  1  CD 19 02             cmp abs1+2
001528  1  D0 FE                trap_ne     ;store to abs data
00152A  1  8E 05 02             stx abst+2  ;clear
00152D  1  A5 05                lda zpt+3
00152F  1  49 C3                eor #$c3
001531  1  C5 0C                cmp zp1+3
001533  1  D0 FE                trap_ne     ;store to zp data
001535  1  86 05                stx zpt+3   ;clear
001537  1  AD 06 02             lda abst+3
00153A  1  49 C3                eor #$c3
00153C  1  CD 1A 02             cmp abs1+3
00153F  1  D0 FE                trap_ne     ;store to abs data
001541  1  8E 06 02             stx abst+3  ;clear
001544  1  AD 00 02 C9          next_test
001548  1  13 D0 FE A9  
00154C  1  14 8D 00 02  
001550  1               
001550  1               ; LDY / STY - zp / abs / #
001550  1  A9 00 48 28          set_stat 0
001554  1  A4 09                ldy zp1
001556  1  08                   php         ;test stores do not alter flags
001557  1  98                   tya
001558  1  49 C3                eor #$c3
00155A  1  A8                   tay
00155B  1  28                   plp
00155C  1  8C 03 02             sty abst
00155F  1  08                   php         ;flags after load/store sequence
001560  1  49 C3                eor #$c3
001562  1  A8                   tay
001563  1  C0 C3                cpy #$c3    ;test result
001565  1  D0 FE                trap_ne
001567  1  68                   pla         ;load status
001568  1  49 30                eor_flag 0
00156A  1  CD 1C 02             cmp fLDx    ;test flags
00156D  1  D0 FE                trap_ne
00156F  1  A9 00 48 28          set_stat 0
001573  1  A4 0A                ldy zp1+1
001575  1  08                   php         ;test stores do not alter flags
001576  1  98                   tya
001577  1  49 C3                eor #$c3
001579  1  A8                   tay
00157A  1  28                   plp
00157B  1  8C 04 02             sty abst+1
00157E  1  08                   php         ;flags after load/store sequence
00157F  1  49 C3                eor #$c3
001581  1  A8                   tay
001582  1  C0 82                cpy #$82    ;test result
001584  1  D0 FE                trap_ne
001586  1  68                   pla         ;load status
001587  1  49 30                eor_flag 0
001589  1  CD 1D 02             cmp fLDx+1  ;test flags
00158C  1  D0 FE                trap_ne
00158E  1  A9 00 48 28          set_stat 0
001592  1  A4 0B                ldy zp1+2
001594  1  08                   php         ;test stores do not alter flags
001595  1  98                   tya
001596  1  49 C3                eor #$c3
001598  1  A8                   tay
001599  1  28                   plp
00159A  1  8C 05 02             sty abst+2
00159D  1  08                   php         ;flags after load/store sequence
00159E  1  49 C3                eor #$c3
0015A0  1  A8                   tay
0015A1  1  C0 41                cpy #$41    ;test result
0015A3  1  D0 FE                trap_ne
0015A5  1  68                   pla         ;load status
0015A6  1  49 30                eor_flag 0
0015A8  1  CD 1E 02             cmp fLDx+2  ;test flags
0015AB  1  D0 FE                trap_ne
0015AD  1  A9 00 48 28          set_stat 0
0015B1  1  A4 0C                ldy zp1+3
0015B3  1  08                   php         ;test stores do not alter flags
0015B4  1  98                   tya
0015B5  1  49 C3                eor #$c3
0015B7  1  A8                   tay
0015B8  1  28                   plp
0015B9  1  8C 06 02             sty abst+3
0015BC  1  08                   php         ;flags after load/store sequence
0015BD  1  49 C3                eor #$c3
0015BF  1  A8                   tay
0015C0  1  C0 00                cpy #0      ;test result
0015C2  1  D0 FE                trap_ne
0015C4  1  68                   pla         ;load status
0015C5  1  49 30                eor_flag 0
0015C7  1  CD 1F 02             cmp fLDx+3  ;test flags
0015CA  1  D0 FE                trap_ne
0015CC  1               
0015CC  1  A9 FF 48 28          set_stat $ff
0015D0  1  A4 09                ldy zp1
0015D2  1  08                   php         ;test stores do not alter flags
0015D3  1  98                   tya
0015D4  1  49 C3                eor #$c3
0015D6  1  A8                   tay
0015D7  1  28                   plp
0015D8  1  8C 03 02             sty abst
0015DB  1  08                   php         ;flags after load/store sequence
0015DC  1  49 C3                eor #$c3
0015DE  1  A8                   tay
0015DF  1  C0 C3                cpy #$c3    ;test result
0015E1  1  D0 FE                trap_ne
0015E3  1  68                   pla         ;load status
0015E4  1  49 7D                eor_flag <~fnz ;mask bits not altered
0015E6  1  CD 1C 02             cmp fLDx    ;test flags
0015E9  1  D0 FE                trap_ne
0015EB  1  A9 FF 48 28          set_stat $ff
0015EF  1  A4 0A                ldy zp1+1
0015F1  1  08                   php         ;test stores do not alter flags
0015F2  1  98                   tya
0015F3  1  49 C3                eor #$c3
0015F5  1  A8                   tay
0015F6  1  28                   plp
0015F7  1  8C 04 02             sty abst+1
0015FA  1  08                   php         ;flags after load/store sequence
0015FB  1  49 C3                eor #$c3
0015FD  1  A8                   tay
0015FE  1  C0 82                cpy #$82   ;test result
001600  1  D0 FE                trap_ne
001602  1  68                   pla         ;load status
001603  1  49 7D                eor_flag <~fnz ;mask bits not altered
001605  1  CD 1D 02             cmp fLDx+1  ;test flags
001608  1  D0 FE                trap_ne
00160A  1  A9 FF 48 28          set_stat $ff
00160E  1  A4 0B                ldy zp1+2
001610  1  08                   php         ;test stores do not alter flags
001611  1  98                   tya
001612  1  49 C3                eor #$c3
001614  1  A8                   tay
001615  1  28                   plp
001616  1  8C 05 02             sty abst+2
001619  1  08                   php         ;flags after load/store sequence
00161A  1  49 C3                eor #$c3
00161C  1  A8                   tay
00161D  1  C0 41                cpy #$41    ;test result
00161F  1  D0 FE                trap_ne
001621  1  68                   pla         ;load status
001622  1  49 7D                eor_flag <~fnz ;mask bits not altered
001624  1  CD 1E 02             cmp fLDx+2  ;test flags
001627  1  D0 FE                trap_ne
001629  1  A9 FF 48 28          set_stat $ff
00162D  1  A4 0C                ldy zp1+3
00162F  1  08                   php         ;test stores do not alter flags
001630  1  98                   tya
001631  1  49 C3                eor #$c3
001633  1  A8                   tay
001634  1  28                   plp
001635  1  8C 06 02             sty abst+3
001638  1  08                   php         ;flags after load/store sequence
001639  1  49 C3                eor #$c3
00163B  1  A8                   tay
00163C  1  C0 00                cpy #0      ;test result
00163E  1  D0 FE                trap_ne
001640  1  68                   pla         ;load status
001641  1  49 7D                eor_flag <~fnz ;mask bits not altered
001643  1  CD 1F 02             cmp fLDx+3  ;test flags
001646  1  D0 FE                trap_ne
001648  1               
001648  1  A9 00 48 28          set_stat 0
00164C  1  AC 17 02             ldy abs1
00164F  1  08                   php         ;test stores do not alter flags
001650  1  98                   tya
001651  1  49 C3                eor #$c3
001653  1  A8                   tay
001654  1  28                   plp
001655  1  84 02                sty zpt
001657  1  08                   php         ;flags after load/store sequence
001658  1  49 C3                eor #$c3
00165A  1  A8                   tay
00165B  1  C4 09                cpy zp1     ;test result
00165D  1  D0 FE                trap_ne
00165F  1  68                   pla         ;load status
001660  1  49 30                eor_flag 0
001662  1  CD 1C 02             cmp fLDx    ;test flags
001665  1  D0 FE                trap_ne
001667  1  A9 00 48 28          set_stat 0
00166B  1  AC 18 02             ldy abs1+1
00166E  1  08                   php         ;test stores do not alter flags
00166F  1  98                   tya
001670  1  49 C3                eor #$c3
001672  1  A8                   tay
001673  1  28                   plp
001674  1  84 03                sty zpt+1
001676  1  08                   php         ;flags after load/store sequence
001677  1  49 C3                eor #$c3
001679  1  A8                   tay
00167A  1  C4 0A                cpy zp1+1   ;test result
00167C  1  D0 FE                trap_ne
00167E  1  68                   pla         ;load status
00167F  1  49 30                eor_flag 0
001681  1  CD 1D 02             cmp fLDx+1  ;test flags
001684  1  D0 FE                trap_ne
001686  1  A9 00 48 28          set_stat 0
00168A  1  AC 19 02             ldy abs1+2
00168D  1  08                   php         ;test stores do not alter flags
00168E  1  98                   tya
00168F  1  49 C3                eor #$c3
001691  1  A8                   tay
001692  1  28                   plp
001693  1  84 04                sty zpt+2
001695  1  08                   php         ;flags after load/store sequence
001696  1  49 C3                eor #$c3
001698  1  A8                   tay
001699  1  C4 0B                cpy zp1+2   ;test result
00169B  1  D0 FE                trap_ne
00169D  1  68                   pla         ;load status
00169E  1  49 30                eor_flag 0
0016A0  1  CD 1E 02             cmp fLDx+2  ;test flags
0016A3  1  D0 FE                trap_ne
0016A5  1  A9 00 48 28          set_stat 0
0016A9  1  AC 1A 02             ldy abs1+3
0016AC  1  08                   php         ;test stores do not alter flags
0016AD  1  98                   tya
0016AE  1  49 C3                eor #$c3
0016B0  1  A8                   tay
0016B1  1  28                   plp
0016B2  1  84 05                sty zpt+3
0016B4  1  08                   php         ;flags after load/store sequence
0016B5  1  49 C3                eor #$c3
0016B7  1  A8                   tay
0016B8  1  C4 0C                cpy zp1+3   ;test result
0016BA  1  D0 FE                trap_ne
0016BC  1  68                   pla         ;load status
0016BD  1  49 30                eor_flag 0
0016BF  1  CD 1F 02             cmp fLDx+3  ;test flags
0016C2  1  D0 FE                trap_ne
0016C4  1               
0016C4  1  A9 FF 48 28          set_stat $ff
0016C8  1  AC 17 02             ldy abs1
0016CB  1  08                   php         ;test stores do not alter flags
0016CC  1  98                   tya
0016CD  1  49 C3                eor #$c3
0016CF  1  A8                   tay
0016D0  1  28                   plp
0016D1  1  84 02                sty zpt
0016D3  1  08                   php         ;flags after load/store sequence
0016D4  1  49 C3                eor #$c3
0016D6  1  A8                   tay
0016D7  1  C5 09                cmp zp1     ;test result
0016D9  1  D0 FE                trap_ne
0016DB  1  68                   pla         ;load status
0016DC  1  49 7D                eor_flag <~fnz ;mask bits not altered
0016DE  1  CD 1C 02             cmp fLDx    ;test flags
0016E1  1  D0 FE                trap_ne
0016E3  1  A9 FF 48 28          set_stat $ff
0016E7  1  AC 18 02             ldy abs1+1
0016EA  1  08                   php         ;test stores do not alter flags
0016EB  1  98                   tya
0016EC  1  49 C3                eor #$c3
0016EE  1  A8                   tay
0016EF  1  28                   plp
0016F0  1  84 03                sty zpt+1
0016F2  1  08                   php         ;flags after load/store sequence
0016F3  1  49 C3                eor #$c3
0016F5  1  A8                   tay
0016F6  1  C5 0A                cmp zp1+1   ;test result
0016F8  1  D0 FE                trap_ne
0016FA  1  68                   pla         ;load status
0016FB  1  49 7D                eor_flag <~fnz ;mask bits not altered
0016FD  1  CD 1D 02             cmp fLDx+1  ;test flags
001700  1  D0 FE                trap_ne
001702  1  A9 FF 48 28          set_stat $ff
001706  1  AC 19 02             ldy abs1+2
001709  1  08                   php         ;test stores do not alter flags
00170A  1  98                   tya
00170B  1  49 C3                eor #$c3
00170D  1  A8                   tay
00170E  1  28                   plp
00170F  1  84 04                sty zpt+2
001711  1  08                   php         ;flags after load/store sequence
001712  1  49 C3                eor #$c3
001714  1  A8                   tay
001715  1  C5 0B                cmp zp1+2   ;test result
001717  1  D0 FE                trap_ne
001719  1  68                   pla         ;load status
00171A  1  49 7D                eor_flag <~fnz ;mask bits not altered
00171C  1  CD 1E 02             cmp fLDx+2  ;test flags
00171F  1  D0 FE                trap_ne
001721  1  A9 FF 48 28          set_stat $ff
001725  1  AC 1A 02             ldy abs1+3
001728  1  08                   php         ;test stores do not alter flags
001729  1  98                   tya
00172A  1  49 C3                eor #$c3
00172C  1  A8                   tay
00172D  1  28                   plp
00172E  1  84 05                sty zpt+3
001730  1  08                   php         ;flags after load/store sequence
001731  1  49 C3                eor #$c3
001733  1  A8                   tay
001734  1  C5 0C                cmp zp1+3   ;test result
001736  1  D0 FE                trap_ne
001738  1  68                   pla         ;load status
001739  1  49 7D                eor_flag <~fnz ;mask bits not altered
00173B  1  CD 1F 02             cmp fLDx+3  ;test flags
00173E  1  D0 FE                trap_ne
001740  1               
001740  1               
001740  1  A9 00 48 28          set_stat 0
001744  1  A0 C3                ldy #$c3
001746  1  08                   php
001747  1  CC 17 02             cpy abs1    ;test result
00174A  1  D0 FE                trap_ne
00174C  1  68                   pla         ;load status
00174D  1  49 30                eor_flag 0
00174F  1  CD 1C 02             cmp fLDx    ;test flags
001752  1  D0 FE                trap_ne
001754  1  A9 00 48 28          set_stat 0
001758  1  A0 82                ldy #$82
00175A  1  08                   php
00175B  1  CC 18 02             cpy abs1+1  ;test result
00175E  1  D0 FE                trap_ne
001760  1  68                   pla         ;load status
001761  1  49 30                eor_flag 0
001763  1  CD 1D 02             cmp fLDx+1  ;test flags
001766  1  D0 FE                trap_ne
001768  1  A9 00 48 28          set_stat 0
00176C  1  A0 41                ldy #$41
00176E  1  08                   php
00176F  1  CC 19 02             cpy abs1+2  ;test result
001772  1  D0 FE                trap_ne
001774  1  68                   pla         ;load status
001775  1  49 30                eor_flag 0
001777  1  CD 1E 02             cmp fLDx+2  ;test flags
00177A  1  D0 FE                trap_ne
00177C  1  A9 00 48 28          set_stat 0
001780  1  A0 00                ldy #0
001782  1  08                   php
001783  1  CC 1A 02             cpy abs1+3  ;test result
001786  1  D0 FE                trap_ne
001788  1  68                   pla         ;load status
001789  1  49 30                eor_flag 0
00178B  1  CD 1F 02             cmp fLDx+3  ;test flags
00178E  1  D0 FE                trap_ne
001790  1               
001790  1  A9 FF 48 28          set_stat $ff
001794  1  A0 C3                ldy #$c3
001796  1  08                   php
001797  1  CC 17 02             cpy abs1    ;test result
00179A  1  D0 FE                trap_ne
00179C  1  68                   pla         ;load status
00179D  1  49 7D                eor_flag <~fnz ;mask bits not altered
00179F  1  CD 1C 02             cmp fLDx    ;test flags
0017A2  1  D0 FE                trap_ne
0017A4  1  A9 FF 48 28          set_stat $ff
0017A8  1  A0 82                ldy #$82
0017AA  1  08                   php
0017AB  1  CC 18 02             cpy abs1+1  ;test result
0017AE  1  D0 FE                trap_ne
0017B0  1  68                   pla         ;load status
0017B1  1  49 7D                eor_flag <~fnz ;mask bits not altered
0017B3  1  CD 1D 02             cmp fLDx+1  ;test flags
0017B6  1  D0 FE                trap_ne
0017B8  1  A9 FF 48 28          set_stat $ff
0017BC  1  A0 41                ldy #$41
0017BE  1  08                   php
0017BF  1  CC 19 02             cpy abs1+2   ;test result
0017C2  1  D0 FE                trap_ne
0017C4  1  68                   pla         ;load status
0017C5  1  49 7D                eor_flag <~fnz ;mask bits not altered
0017C7  1  CD 1E 02             cmp fLDx+2  ;test flags
0017CA  1  D0 FE                trap_ne
0017CC  1  A9 FF 48 28          set_stat $ff
0017D0  1  A0 00                ldy #0
0017D2  1  08                   php
0017D3  1  CC 1A 02             cpy abs1+3  ;test result
0017D6  1  D0 FE                trap_ne
0017D8  1  68                   pla         ;load status
0017D9  1  49 7D                eor_flag <~fnz ;mask bits not altered
0017DB  1  CD 1F 02             cmp fLDx+3  ;test flags
0017DE  1  D0 FE                trap_ne
0017E0  1               
0017E0  1  A0 00                ldy #0
0017E2  1  A5 02                lda zpt
0017E4  1  49 C3                eor #$c3
0017E6  1  C5 09                cmp zp1
0017E8  1  D0 FE                trap_ne     ;store to zp   data
0017EA  1  84 02                sty zpt     ;clear
0017EC  1  AD 03 02             lda abst
0017EF  1  49 C3                eor #$c3
0017F1  1  CD 17 02             cmp abs1
0017F4  1  D0 FE                trap_ne     ;store to abs   data
0017F6  1  8C 03 02             sty abst    ;clear
0017F9  1  A5 03                lda zpt+1
0017FB  1  49 C3                eor #$c3
0017FD  1  C5 0A                cmp zp1+1
0017FF  1  D0 FE                trap_ne     ;store to zp+1 data
001801  1  84 03                sty zpt+1   ;clear
001803  1  AD 04 02             lda abst+1
001806  1  49 C3                eor #$c3
001808  1  CD 18 02             cmp abs1+1
00180B  1  D0 FE                trap_ne     ;store to abs+1 data
00180D  1  8C 04 02             sty abst+1  ;clear
001810  1  A5 04                lda zpt+2
001812  1  49 C3                eor #$c3
001814  1  C5 0B                cmp zp1+2
001816  1  D0 FE                trap_ne     ;store to zp+2 data
001818  1  84 04                sty zpt+2   ;clear
00181A  1  AD 05 02             lda abst+2
00181D  1  49 C3                eor #$c3
00181F  1  CD 19 02             cmp abs1+2
001822  1  D0 FE                trap_ne     ;store to abs+2 data
001824  1  8C 05 02             sty abst+2  ;clear
001827  1  A5 05                lda zpt+3
001829  1  49 C3                eor #$c3
00182B  1  C5 0C                cmp zp1+3
00182D  1  D0 FE                trap_ne     ;store to zp+3 data
00182F  1  84 05                sty zpt+3   ;clear
001831  1  AD 06 02             lda abst+3
001834  1  49 C3                eor #$c3
001836  1  CD 1A 02             cmp abs1+3
001839  1  D0 FE                trap_ne     ;store to abs+3 data
00183B  1  8C 06 02             sty abst+3  ;clear
00183E  1  AD 00 02 C9          next_test
001842  1  14 D0 FE A9  
001846  1  15 8D 00 02  
00184A  1               
00184A  1               ; testing load / store accumulator LDA / STA all addressing modes
00184A  1               ; LDA / STA - zp,x / abs,x
00184A  1  A2 03                ldx #3
00184C  1               tldax:
00184C  1  A9 00 48 28          set_stat 0
001850  1  B5 09                lda zp1,x
001852  1  08                   php         ;test stores do not alter flags
001853  1  49 C3                eor #$c3
001855  1  28                   plp
001856  1  9D 03 02             sta abst,x
001859  1  08                   php         ;flags after load/store sequence
00185A  1  49 C3                eor #$c3
00185C  1  DD 17 02             cmp abs1,x  ;test result
00185F  1  D0 FE                trap_ne
001861  1  68                   pla         ;load status
001862  1  49 30                eor_flag 0
001864  1  DD 1C 02             cmp fLDx,x  ;test flags
001867  1  D0 FE                trap_ne
001869  1  CA                   dex
00186A  1  10 E0                bpl tldax
00186C  1               
00186C  1  A2 03                ldx #3
00186E  1               tldax1:
00186E  1  A9 FF 48 28          set_stat $ff
001872  1  B5 09                lda zp1,x
001874  1  08                   php         ;test stores do not alter flags
001875  1  49 C3                eor #$c3
001877  1  28                   plp
001878  1  9D 03 02             sta abst,x
00187B  1  08                   php         ;flags after load/store sequence
00187C  1  49 C3                eor #$c3
00187E  1  DD 17 02             cmp abs1,x   ;test result
001881  1  D0 FE                trap_ne
001883  1  68                   pla         ;load status
001884  1  49 7D                eor_flag <~fnz ;mask bits not altered
001886  1  DD 1C 02             cmp fLDx,x  ;test flags
001889  1  D0 FE                trap_ne
00188B  1  CA                   dex
00188C  1  10 E0                bpl tldax1
00188E  1               
00188E  1  A2 03                ldx #3
001890  1               tldax2:
001890  1  A9 00 48 28          set_stat 0
001894  1  BD 17 02             lda abs1,x
001897  1  08                   php         ;test stores do not alter flags
001898  1  49 C3                eor #$c3
00189A  1  28                   plp
00189B  1  95 02                sta zpt,x
00189D  1  08                   php         ;flags after load/store sequence
00189E  1  49 C3                eor #$c3
0018A0  1  D5 09                cmp zp1,x   ;test result
0018A2  1  D0 FE                trap_ne
0018A4  1  68                   pla         ;load status
0018A5  1  49 30                eor_flag 0
0018A7  1  DD 1C 02             cmp fLDx,x  ;test flags
0018AA  1  D0 FE                trap_ne
0018AC  1  CA                   dex
0018AD  1  10 E1                bpl tldax2
0018AF  1               
0018AF  1  A2 03                ldx #3
0018B1  1               tldax3:
0018B1  1  A9 FF 48 28          set_stat $ff
0018B5  1  BD 17 02             lda abs1,x
0018B8  1  08                   php         ;test stores do not alter flags
0018B9  1  49 C3                eor #$c3
0018BB  1  28                   plp
0018BC  1  95 02                sta zpt,x
0018BE  1  08                   php         ;flags after load/store sequence
0018BF  1  49 C3                eor #$c3
0018C1  1  D5 09                cmp zp1,x   ;test result
0018C3  1  D0 FE                trap_ne
0018C5  1  68                   pla         ;load status
0018C6  1  49 7D                eor_flag <~fnz ;mask bits not altered
0018C8  1  DD 1C 02             cmp fLDx,x  ;test flags
0018CB  1  D0 FE                trap_ne
0018CD  1  CA                   dex
0018CE  1  10 E1                bpl tldax3
0018D0  1               
0018D0  1  A2 03                ldx #3      ;testing store result
0018D2  1  A0 00                ldy #0
0018D4  1  B5 02        tstax:  lda zpt,x
0018D6  1  49 C3                eor #$c3
0018D8  1  D5 09                cmp zp1,x
0018DA  1  D0 FE                trap_ne     ;store to zp,x data
0018DC  1  94 02                sty zpt,x   ;clear
0018DE  1  BD 03 02             lda abst,x
0018E1  1  49 C3                eor #$c3
0018E3  1  DD 17 02             cmp abs1,x
0018E6  1  D0 FE                trap_ne     ;store to abs,x data
0018E8  1  8A                   txa
0018E9  1  9D 03 02             sta abst,x  ;clear
0018EC  1  CA                   dex
0018ED  1  10 E5                bpl tstax
0018EF  1  AD 00 02 C9          next_test
0018F3  1  15 D0 FE A9  
0018F7  1  16 8D 00 02  
0018FB  1               
0018FB  1               ; LDA / STA - (zp),y / abs,y / (zp,x)
0018FB  1  A0 03                ldy #3
0018FD  1               tlday:
0018FD  1  A9 00 48 28          set_stat 0
001901  1  B1 1A                lda (ind1),y
001903  1  08                   php         ;test stores do not alter flags
001904  1  49 C3                eor #$c3
001906  1  28                   plp
001907  1  99 03 02             sta abst,y
00190A  1  08                   php         ;flags after load/store sequence
00190B  1  49 C3                eor #$c3
00190D  1  D9 17 02             cmp abs1,y  ;test result
001910  1  D0 FE                trap_ne
001912  1  68                   pla         ;load status
001913  1  49 30                eor_flag 0
001915  1  D9 1C 02             cmp fLDx,y  ;test flags
001918  1  D0 FE                trap_ne
00191A  1  88                   dey
00191B  1  10 E0                bpl tlday
00191D  1               
00191D  1  A0 03                ldy #3
00191F  1               tlday1:
00191F  1  A9 FF 48 28          set_stat $ff
001923  1  B1 1A                lda (ind1),y
001925  1  08                   php         ;test stores do not alter flags
001926  1  49 C3                eor #$c3
001928  1  28                   plp
001929  1  99 03 02             sta abst,y
00192C  1  08                   php         ;flags after load/store sequence
00192D  1  49 C3                eor #$c3
00192F  1  D9 17 02             cmp abs1,y  ;test result
001932  1  D0 FE                trap_ne
001934  1  68                   pla         ;load status
001935  1  49 7D                eor_flag <~fnz ;mask bits not altered
001937  1  D9 1C 02             cmp fLDx,y  ;test flags
00193A  1  D0 FE                trap_ne
00193C  1  88                   dey
00193D  1  10 E0                bpl tlday1
00193F  1               
00193F  1  A0 03                ldy #3      ;testing store result
001941  1  A2 00                ldx #0
001943  1  B9 03 02     tstay:  lda abst,y
001946  1  49 C3                eor #$c3
001948  1  D9 17 02             cmp abs1,y
00194B  1  D0 FE                trap_ne     ;store to abs data
00194D  1  8A                   txa
00194E  1  99 03 02             sta abst,y  ;clear
001951  1  88                   dey
001952  1  10 EF                bpl tstay
001954  1               
001954  1  A0 03                ldy #3
001956  1               tlday2:
001956  1  A9 00 48 28          set_stat 0
00195A  1  B9 17 02             lda abs1,y
00195D  1  08                   php         ;test stores do not alter flags
00195E  1  49 C3                eor #$c3
001960  1  28                   plp
001961  1  91 26                sta (indt),y
001963  1  08                   php         ;flags after load/store sequence
001964  1  49 C3                eor #$c3
001966  1  D1 1A                cmp (ind1),y    ;test result
001968  1  D0 FE                trap_ne
00196A  1  68                   pla         ;load status
00196B  1  49 30                eor_flag 0
00196D  1  D9 1C 02             cmp fLDx,y  ;test flags
001970  1  D0 FE                trap_ne
001972  1  88                   dey
001973  1  10 E1                bpl tlday2
001975  1               
001975  1  A0 03                ldy #3
001977  1               tlday3:
001977  1  A9 FF 48 28          set_stat $ff
00197B  1  B9 17 02             lda abs1,y
00197E  1  08                   php         ;test stores do not alter flags
00197F  1  49 C3                eor #$c3
001981  1  28                   plp
001982  1  91 26                sta (indt),y
001984  1  08                   php         ;flags after load/store sequence
001985  1  49 C3                eor #$c3
001987  1  D1 1A                cmp (ind1),y   ;test result
001989  1  D0 FE                trap_ne
00198B  1  68                   pla         ;load status
00198C  1  49 7D                eor_flag <~fnz ;mask bits not altered
00198E  1  D9 1C 02             cmp fLDx,y  ;test flags
001991  1  D0 FE                trap_ne
001993  1  88                   dey
001994  1  10 E1                bpl tlday3
001996  1               
001996  1  A0 03                ldy #3      ;testing store result
001998  1  A2 00                ldx #0
00199A  1  B9 03 02     tstay1: lda abst,y
00199D  1  49 C3                eor #$c3
00199F  1  D9 17 02             cmp abs1,y
0019A2  1  D0 FE                trap_ne     ;store to abs data
0019A4  1  8A                   txa
0019A5  1  99 03 02             sta abst,y  ;clear
0019A8  1  88                   dey
0019A9  1  10 EF                bpl tstay1
0019AB  1               
0019AB  1  A2 06                ldx #6
0019AD  1  A0 03                ldy #3
0019AF  1               tldax4:
0019AF  1  A9 00 48 28          set_stat 0
0019B3  1  A1 1A                lda (ind1,x)
0019B5  1  08                   php         ;test stores do not alter flags
0019B6  1  49 C3                eor #$c3
0019B8  1  28                   plp
0019B9  1  81 26                sta (indt,x)
0019BB  1  08                   php         ;flags after load/store sequence
0019BC  1  49 C3                eor #$c3
0019BE  1  D9 17 02             cmp abs1,y  ;test result
0019C1  1  D0 FE                trap_ne
0019C3  1  68                   pla         ;load status
0019C4  1  49 30                eor_flag 0
0019C6  1  D9 1C 02             cmp fLDx,y  ;test flags
0019C9  1  D0 FE                trap_ne
0019CB  1  CA                   dex
0019CC  1  CA                   dex
0019CD  1  88                   dey
0019CE  1  10 DF                bpl tldax4
0019D0  1               
0019D0  1  A2 06                ldx #6
0019D2  1  A0 03                ldy #3
0019D4  1               tldax5:
0019D4  1  A9 FF 48 28          set_stat $ff
0019D8  1  A1 1A                lda (ind1,x)
0019DA  1  08                   php         ;test stores do not alter flags
0019DB  1  49 C3                eor #$c3
0019DD  1  28                   plp
0019DE  1  81 26                sta (indt,x)
0019E0  1  08                   php         ;flags after load/store sequence
0019E1  1  49 C3                eor #$c3
0019E3  1  D9 17 02             cmp abs1,y  ;test result
0019E6  1  D0 FE                trap_ne
0019E8  1  68                   pla         ;load status
0019E9  1  49 7D                eor_flag <~fnz ;mask bits not altered
0019EB  1  D9 1C 02             cmp fLDx,y  ;test flags
0019EE  1  D0 FE                trap_ne
0019F0  1  CA                   dex
0019F1  1  CA                   dex
0019F2  1  88                   dey
0019F3  1  10 DF                bpl tldax5
0019F5  1               
0019F5  1  A0 03                ldy #3      ;testing store result
0019F7  1  A2 00                ldx #0
0019F9  1  B9 03 02     tstay2: lda abst,y
0019FC  1  49 C3                eor #$c3
0019FE  1  D9 17 02             cmp abs1,y
001A01  1  D0 FE                trap_ne     ;store to abs data
001A03  1  8A                   txa
001A04  1  99 03 02             sta abst,y  ;clear
001A07  1  88                   dey
001A08  1  10 EF                bpl tstay2
001A0A  1  AD 00 02 C9          next_test
001A0E  1  16 D0 FE A9  
001A12  1  17 8D 00 02  
001A16  1               
001A16  1               ; indexed wraparound test (only zp should wrap)
001A16  1  A2 FD                ldx #3+$fa
001A18  1  B5 0F        tldax6: lda <(zp1-$fa),x   ;wrap on indexed zp
001A1A  1  9D 09 01             sta abst-$fa,x      ;no STX abs,x!
001A1D  1  CA                   dex
001A1E  1  E0 FA                cpx #$fa
001A20  1  B0 F6                bcs tldax6
001A22  1  A2 FD                ldx #3+$fa
001A24  1  BD 1D 01     tldax7: lda abs1-$fa,x      ;no wrap on indexed abs
001A27  1  95 08                sta <(zpt-$fa),x
001A29  1  CA                   dex
001A2A  1  E0 FA                cpx #$fa
001A2C  1  B0 F6                bcs tldax7
001A2E  1               
001A2E  1  A2 03                ldx #3      ;testing wraparound result
001A30  1  A0 00                ldy #0
001A32  1  B5 02        tstax1: lda zpt,x
001A34  1  D5 09                cmp zp1,x
001A36  1  D0 FE                trap_ne     ;store to zp,x data
001A38  1  94 02                sty zpt,x   ;clear
001A3A  1  BD 03 02             lda abst,x
001A3D  1  DD 17 02             cmp abs1,x
001A40  1  D0 FE                trap_ne     ;store to abs,x data
001A42  1  8A                   txa
001A43  1  9D 03 02             sta abst,x  ;clear
001A46  1  CA                   dex
001A47  1  10 E9                bpl tstax1
001A49  1               
001A49  1  A0 FB                ldy #3+$f8
001A4B  1  A2 FE                ldx #6+$f8
001A4D  1  A1 22        tlday4: lda (<(ind1-$f8),x) ;wrap on indexed zp indirect
001A4F  1  99 0B 01             sta abst-$f8,y
001A52  1  CA                   dex
001A53  1  CA                   dex
001A54  1  88                   dey
001A55  1  C0 F8                cpy #$f8
001A57  1  B0 F4                bcs tlday4
001A59  1  A0 03                ldy #3      ;testing wraparound result
001A5B  1  A2 00                ldx #0
001A5D  1  B9 03 02     tstay4: lda abst,y
001A60  1  D9 17 02             cmp abs1,y
001A63  1  D0 FE                trap_ne     ;store to abs data
001A65  1  8A                   txa
001A66  1  99 03 02             sta abst,y  ;clear
001A69  1  88                   dey
001A6A  1  10 F1                bpl tstay4
001A6C  1               
001A6C  1  A0 FB                ldy #3+$f8
001A6E  1  B9 1F 01     tlday5: lda abs1-$f8,y  ;no wrap on indexed abs
001A71  1  91 2E                sta (inwt),y
001A73  1  88                   dey
001A74  1  C0 F8                cpy #$f8
001A76  1  B0 F6                bcs tlday5
001A78  1  A0 03                ldy #3      ;testing wraparound result
001A7A  1  A2 00                ldx #0
001A7C  1  B9 03 02     tstay5: lda abst,y
001A7F  1  D9 17 02             cmp abs1,y
001A82  1  D0 FE                trap_ne     ;store to abs data
001A84  1  8A                   txa
001A85  1  99 03 02             sta abst,y  ;clear
001A88  1  88                   dey
001A89  1  10 F1                bpl tstay5
001A8B  1               
001A8B  1  A0 FB                ldy #3+$f8
001A8D  1  A2 FE                ldx #6+$f8
001A8F  1  B1 24        tlday6: lda (inw1),y    ;no wrap on zp indirect indexed
001A91  1  81 2E                sta (<(indt-$f8),x)
001A93  1  CA                   dex
001A94  1  CA                   dex
001A95  1  88                   dey
001A96  1  C0 F8                cpy #$f8
001A98  1  B0 F5                bcs tlday6
001A9A  1  A0 03                ldy #3      ;testing wraparound result
001A9C  1  A2 00                ldx #0
001A9E  1  B9 03 02     tstay6: lda abst,y
001AA1  1  D9 17 02             cmp abs1,y
001AA4  1  D0 FE                trap_ne     ;store to abs data
001AA6  1  8A                   txa
001AA7  1  99 03 02             sta abst,y  ;clear
001AAA  1  88                   dey
001AAB  1  10 F1                bpl tstay6
001AAD  1  AD 00 02 C9          next_test
001AB1  1  17 D0 FE A9  
001AB5  1  18 8D 00 02  
001AB9  1               
001AB9  1               ; LDA / STA - zp / abs / #
001AB9  1  A9 00 48 28          set_stat 0
001ABD  1  A5 09                lda zp1
001ABF  1  08                   php         ;test stores do not alter flags
001AC0  1  49 C3                eor #$c3
001AC2  1  28                   plp
001AC3  1  8D 03 02             sta abst
001AC6  1  08                   php         ;flags after load/store sequence
001AC7  1  49 C3                eor #$c3
001AC9  1  C9 C3                cmp #$c3    ;test result
001ACB  1  D0 FE                trap_ne
001ACD  1  68                   pla         ;load status
001ACE  1  49 30                eor_flag 0
001AD0  1  CD 1C 02             cmp fLDx    ;test flags
001AD3  1  D0 FE                trap_ne
001AD5  1  A9 00 48 28          set_stat 0
001AD9  1  A5 0A                lda zp1+1
001ADB  1  08                   php         ;test stores do not alter flags
001ADC  1  49 C3                eor #$c3
001ADE  1  28                   plp
001ADF  1  8D 04 02             sta abst+1
001AE2  1  08                   php         ;flags after load/store sequence
001AE3  1  49 C3                eor #$c3
001AE5  1  C9 82                cmp #$82    ;test result
001AE7  1  D0 FE                trap_ne
001AE9  1  68                   pla         ;load status
001AEA  1  49 30                eor_flag 0
001AEC  1  CD 1D 02             cmp fLDx+1  ;test flags
001AEF  1  D0 FE                trap_ne
001AF1  1  A9 00 48 28          set_stat 0
001AF5  1  A5 0B                lda zp1+2
001AF7  1  08                   php         ;test stores do not alter flags
001AF8  1  49 C3                eor #$c3
001AFA  1  28                   plp
001AFB  1  8D 05 02             sta abst+2
001AFE  1  08                   php         ;flags after load/store sequence
001AFF  1  49 C3                eor #$c3
001B01  1  C9 41                cmp #$41    ;test result
001B03  1  D0 FE                trap_ne
001B05  1  68                   pla         ;load status
001B06  1  49 30                eor_flag 0
001B08  1  CD 1E 02             cmp fLDx+2  ;test flags
001B0B  1  D0 FE                trap_ne
001B0D  1  A9 00 48 28          set_stat 0
001B11  1  A5 0C                lda zp1+3
001B13  1  08                   php         ;test stores do not alter flags
001B14  1  49 C3                eor #$c3
001B16  1  28                   plp
001B17  1  8D 06 02             sta abst+3
001B1A  1  08                   php         ;flags after load/store sequence
001B1B  1  49 C3                eor #$c3
001B1D  1  C9 00                cmp #0      ;test result
001B1F  1  D0 FE                trap_ne
001B21  1  68                   pla         ;load status
001B22  1  49 30                eor_flag 0
001B24  1  CD 1F 02             cmp fLDx+3  ;test flags
001B27  1  D0 FE                trap_ne
001B29  1  A9 FF 48 28          set_stat $ff
001B2D  1  A5 09                lda zp1
001B2F  1  08                   php         ;test stores do not alter flags
001B30  1  49 C3                eor #$c3
001B32  1  28                   plp
001B33  1  8D 03 02             sta abst
001B36  1  08                   php         ;flags after load/store sequence
001B37  1  49 C3                eor #$c3
001B39  1  C9 C3                cmp #$c3    ;test result
001B3B  1  D0 FE                trap_ne
001B3D  1  68                   pla         ;load status
001B3E  1  49 7D                eor_flag <~fnz ;mask bits not altered
001B40  1  CD 1C 02             cmp fLDx    ;test flags
001B43  1  D0 FE                trap_ne
001B45  1  A9 FF 48 28          set_stat $ff
001B49  1  A5 0A                lda zp1+1
001B4B  1  08                   php         ;test stores do not alter flags
001B4C  1  49 C3                eor #$c3
001B4E  1  28                   plp
001B4F  1  8D 04 02             sta abst+1
001B52  1  08                   php         ;flags after load/store sequence
001B53  1  49 C3                eor #$c3
001B55  1  C9 82                cmp #$82    ;test result
001B57  1  D0 FE                trap_ne
001B59  1  68                   pla         ;load status
001B5A  1  49 7D                eor_flag <~fnz ;mask bits not altered
001B5C  1  CD 1D 02             cmp fLDx+1  ;test flags
001B5F  1  D0 FE                trap_ne
001B61  1  A9 FF 48 28          set_stat $ff
001B65  1  A5 0B                lda zp1+2
001B67  1  08                   php         ;test stores do not alter flags
001B68  1  49 C3                eor #$c3
001B6A  1  28                   plp
001B6B  1  8D 05 02             sta abst+2
001B6E  1  08                   php         ;flags after load/store sequence
001B6F  1  49 C3                eor #$c3
001B71  1  C9 41                cmp #$41    ;test result
001B73  1  D0 FE                trap_ne
001B75  1  68                   pla         ;load status
001B76  1  49 7D                eor_flag <~fnz ;mask bits not altered
001B78  1  CD 1E 02             cmp fLDx+2  ;test flags
001B7B  1  D0 FE                trap_ne
001B7D  1  A9 FF 48 28          set_stat $ff
001B81  1  A5 0C                lda zp1+3
001B83  1  08                   php         ;test stores do not alter flags
001B84  1  49 C3                eor #$c3
001B86  1  28                   plp
001B87  1  8D 06 02             sta abst+3
001B8A  1  08                   php         ;flags after load/store sequence
001B8B  1  49 C3                eor #$c3
001B8D  1  C9 00                cmp #0      ;test result
001B8F  1  D0 FE                trap_ne
001B91  1  68                   pla         ;load status
001B92  1  49 7D                eor_flag <~fnz ;mask bits not altered
001B94  1  CD 1F 02             cmp fLDx+3  ;test flags
001B97  1  D0 FE                trap_ne
001B99  1  A9 00 48 28          set_stat 0
001B9D  1  AD 17 02             lda abs1
001BA0  1  08                   php         ;test stores do not alter flags
001BA1  1  49 C3                eor #$c3
001BA3  1  28                   plp
001BA4  1  85 02                sta zpt
001BA6  1  08                   php         ;flags after load/store sequence
001BA7  1  49 C3                eor #$c3
001BA9  1  C5 09                cmp zp1     ;test result
001BAB  1  D0 FE                trap_ne
001BAD  1  68                   pla         ;load status
001BAE  1  49 30                eor_flag 0
001BB0  1  CD 1C 02             cmp fLDx    ;test flags
001BB3  1  D0 FE                trap_ne
001BB5  1  A9 00 48 28          set_stat 0
001BB9  1  AD 18 02             lda abs1+1
001BBC  1  08                   php         ;test stores do not alter flags
001BBD  1  49 C3                eor #$c3
001BBF  1  28                   plp
001BC0  1  85 03                sta zpt+1
001BC2  1  08                   php         ;flags after load/store sequence
001BC3  1  49 C3                eor #$c3
001BC5  1  C5 0A                cmp zp1+1   ;test result
001BC7  1  D0 FE                trap_ne
001BC9  1  68                   pla         ;load status
001BCA  1  49 30                eor_flag 0
001BCC  1  CD 1D 02             cmp fLDx+1  ;test flags
001BCF  1  D0 FE                trap_ne
001BD1  1  A9 00 48 28          set_stat 0
001BD5  1  AD 19 02             lda abs1+2
001BD8  1  08                   php         ;test stores do not alter flags
001BD9  1  49 C3                eor #$c3
001BDB  1  28                   plp
001BDC  1  85 04                sta zpt+2
001BDE  1  08                   php         ;flags after load/store sequence
001BDF  1  49 C3                eor #$c3
001BE1  1  C5 0B                cmp zp1+2   ;test result
001BE3  1  D0 FE                trap_ne
001BE5  1  68                   pla         ;load status
001BE6  1  49 30                eor_flag 0
001BE8  1  CD 1E 02             cmp fLDx+2  ;test flags
001BEB  1  D0 FE                trap_ne
001BED  1  A9 00 48 28          set_stat 0
001BF1  1  AD 1A 02             lda abs1+3
001BF4  1  08                   php         ;test stores do not alter flags
001BF5  1  49 C3                eor #$c3
001BF7  1  28                   plp
001BF8  1  85 05                sta zpt+3
001BFA  1  08                   php         ;flags after load/store sequence
001BFB  1  49 C3                eor #$c3
001BFD  1  C5 0C                cmp zp1+3   ;test result
001BFF  1  D0 FE                trap_ne
001C01  1  68                   pla         ;load status
001C02  1  49 30                eor_flag 0
001C04  1  CD 1F 02             cmp fLDx+3  ;test flags
001C07  1  D0 FE                trap_ne
001C09  1  A9 FF 48 28          set_stat $ff
001C0D  1  AD 17 02             lda abs1
001C10  1  08                   php         ;test stores do not alter flags
001C11  1  49 C3                eor #$c3
001C13  1  28                   plp
001C14  1  85 02                sta zpt
001C16  1  08                   php         ;flags after load/store sequence
001C17  1  49 C3                eor #$c3
001C19  1  C5 09                cmp zp1     ;test result
001C1B  1  D0 FE                trap_ne
001C1D  1  68                   pla         ;load status
001C1E  1  49 7D                eor_flag <~fnz ;mask bits not altered
001C20  1  CD 1C 02             cmp fLDx    ;test flags
001C23  1  D0 FE                trap_ne
001C25  1  A9 FF 48 28          set_stat $ff
001C29  1  AD 18 02             lda abs1+1
001C2C  1  08                   php         ;test stores do not alter flags
001C2D  1  49 C3                eor #$c3
001C2F  1  28                   plp
001C30  1  85 03                sta zpt+1
001C32  1  08                   php         ;flags after load/store sequence
001C33  1  49 C3                eor #$c3
001C35  1  C5 0A                cmp zp1+1   ;test result
001C37  1  D0 FE                trap_ne
001C39  1  68                   pla         ;load status
001C3A  1  49 7D                eor_flag <~fnz ;mask bits not altered
001C3C  1  CD 1D 02             cmp fLDx+1  ;test flags
001C3F  1  D0 FE                trap_ne
001C41  1  A9 FF 48 28          set_stat $ff
001C45  1  AD 19 02             lda abs1+2
001C48  1  08                   php         ;test stores do not alter flags
001C49  1  49 C3                eor #$c3
001C4B  1  28                   plp
001C4C  1  85 04                sta zpt+2
001C4E  1  08                   php         ;flags after load/store sequence
001C4F  1  49 C3                eor #$c3
001C51  1  C5 0B                cmp zp1+2   ;test result
001C53  1  D0 FE                trap_ne
001C55  1  68                   pla         ;load status
001C56  1  49 7D                eor_flag <~fnz ;mask bits not altered
001C58  1  CD 1E 02             cmp fLDx+2  ;test flags
001C5B  1  D0 FE                trap_ne
001C5D  1  A9 FF 48 28          set_stat $ff
001C61  1  AD 1A 02             lda abs1+3
001C64  1  08                   php         ;test stores do not alter flags
001C65  1  49 C3                eor #$c3
001C67  1  28                   plp
001C68  1  85 05                sta zpt+3
001C6A  1  08                   php         ;flags after load/store sequence
001C6B  1  49 C3                eor #$c3
001C6D  1  C5 0C                cmp zp1+3   ;test result
001C6F  1  D0 FE                trap_ne
001C71  1  68                   pla         ;load status
001C72  1  49 7D                eor_flag <~fnz ;mask bits not altered
001C74  1  CD 1F 02             cmp fLDx+3  ;test flags
001C77  1  D0 FE                trap_ne
001C79  1  A9 00 48 28          set_stat 0
001C7D  1  A9 C3                lda #$c3
001C7F  1  08                   php
001C80  1  CD 17 02             cmp abs1    ;test result
001C83  1  D0 FE                trap_ne
001C85  1  68                   pla         ;load status
001C86  1  49 30                eor_flag 0
001C88  1  CD 1C 02             cmp fLDx    ;test flags
001C8B  1  D0 FE                trap_ne
001C8D  1  A9 00 48 28          set_stat 0
001C91  1  A9 82                lda #$82
001C93  1  08                   php
001C94  1  CD 18 02             cmp abs1+1  ;test result
001C97  1  D0 FE                trap_ne
001C99  1  68                   pla         ;load status
001C9A  1  49 30                eor_flag 0
001C9C  1  CD 1D 02             cmp fLDx+1  ;test flags
001C9F  1  D0 FE                trap_ne
001CA1  1  A9 00 48 28          set_stat 0
001CA5  1  A9 41                lda #$41
001CA7  1  08                   php
001CA8  1  CD 19 02             cmp abs1+2  ;test result
001CAB  1  D0 FE                trap_ne
001CAD  1  68                   pla         ;load status
001CAE  1  49 30                eor_flag 0
001CB0  1  CD 1E 02             cmp fLDx+2  ;test flags
001CB3  1  D0 FE                trap_ne
001CB5  1  A9 00 48 28          set_stat 0
001CB9  1  A9 00                lda #0
001CBB  1  08                   php
001CBC  1  CD 1A 02             cmp abs1+3  ;test result
001CBF  1  D0 FE                trap_ne
001CC1  1  68                   pla         ;load status
001CC2  1  49 30                eor_flag 0
001CC4  1  CD 1F 02             cmp fLDx+3  ;test flags
001CC7  1  D0 FE                trap_ne
001CC9  1               
001CC9  1  A9 FF 48 28          set_stat $ff
001CCD  1  A9 C3                lda #$c3
001CCF  1  08                   php
001CD0  1  CD 17 02             cmp abs1    ;test result
001CD3  1  D0 FE                trap_ne
001CD5  1  68                   pla         ;load status
001CD6  1  49 7D                eor_flag <~fnz ;mask bits not altered
001CD8  1  CD 1C 02             cmp fLDx    ;test flags
001CDB  1  D0 FE                trap_ne
001CDD  1  A9 FF 48 28          set_stat $ff
001CE1  1  A9 82                lda #$82
001CE3  1  08                   php
001CE4  1  CD 18 02             cmp abs1+1  ;test result
001CE7  1  D0 FE                trap_ne
001CE9  1  68                   pla         ;load status
001CEA  1  49 7D                eor_flag <~fnz ;mask bits not altered
001CEC  1  CD 1D 02             cmp fLDx+1  ;test flags
001CEF  1  D0 FE                trap_ne
001CF1  1  A9 FF 48 28          set_stat $ff
001CF5  1  A9 41                lda #$41
001CF7  1  08                   php
001CF8  1  CD 19 02             cmp abs1+2  ;test result
001CFB  1  D0 FE                trap_ne
001CFD  1  68                   pla         ;load status
001CFE  1  49 7D                eor_flag <~fnz ;mask bits not altered
001D00  1  CD 1E 02             cmp fLDx+2  ;test flags
001D03  1  D0 FE                trap_ne
001D05  1  A9 FF 48 28          set_stat $ff
001D09  1  A9 00                lda #0
001D0B  1  08                   php
001D0C  1  CD 1A 02             cmp abs1+3  ;test result
001D0F  1  D0 FE                trap_ne
001D11  1  68                   pla         ;load status
001D12  1  49 7D                eor_flag <~fnz ;mask bits not altered
001D14  1  CD 1F 02             cmp fLDx+3  ;test flags
001D17  1  D0 FE                trap_ne
001D19  1               
001D19  1  A2 00                ldx #0
001D1B  1  A5 02                lda zpt
001D1D  1  49 C3                eor #$c3
001D1F  1  C5 09                cmp zp1
001D21  1  D0 FE                trap_ne     ;store to zp data
001D23  1  86 02                stx zpt     ;clear
001D25  1  AD 03 02             lda abst
001D28  1  49 C3                eor #$c3
001D2A  1  CD 17 02             cmp abs1
001D2D  1  D0 FE                trap_ne     ;store to abs data
001D2F  1  8E 03 02             stx abst    ;clear
001D32  1  A5 03                lda zpt+1
001D34  1  49 C3                eor #$c3
001D36  1  C5 0A                cmp zp1+1
001D38  1  D0 FE                trap_ne     ;store to zp data
001D3A  1  86 03                stx zpt+1   ;clear
001D3C  1  AD 04 02             lda abst+1
001D3F  1  49 C3                eor #$c3
001D41  1  CD 18 02             cmp abs1+1
001D44  1  D0 FE                trap_ne     ;store to abs data
001D46  1  8E 04 02             stx abst+1  ;clear
001D49  1  A5 04                lda zpt+2
001D4B  1  49 C3                eor #$c3
001D4D  1  C5 0B                cmp zp1+2
001D4F  1  D0 FE                trap_ne     ;store to zp data
001D51  1  86 04                stx zpt+2   ;clear
001D53  1  AD 05 02             lda abst+2
001D56  1  49 C3                eor #$c3
001D58  1  CD 19 02             cmp abs1+2
001D5B  1  D0 FE                trap_ne     ;store to abs data
001D5D  1  8E 05 02             stx abst+2  ;clear
001D60  1  A5 05                lda zpt+3
001D62  1  49 C3                eor #$c3
001D64  1  C5 0C                cmp zp1+3
001D66  1  D0 FE                trap_ne     ;store to zp data
001D68  1  86 05                stx zpt+3   ;clear
001D6A  1  AD 06 02             lda abst+3
001D6D  1  49 C3                eor #$c3
001D6F  1  CD 1A 02             cmp abs1+3
001D72  1  D0 FE                trap_ne     ;store to abs data
001D74  1  8E 06 02             stx abst+3  ;clear
001D77  1  AD 00 02 C9          next_test
001D7B  1  18 D0 FE A9  
001D7F  1  19 8D 00 02  
001D83  1               
001D83  1               ; testing bit test & compares BIT CPX CPY CMP all addressing modes
001D83  1               ; BIT - zp / abs
001D83  1  A9 00 48 A9          set_a $ff,0
001D87  1  FF 28        
001D89  1  24 0C                bit zp1+3   ;00 - should set Z / clear  NV
001D8B  1  08 C9 FF D0          tst_a $ff,fz
001D8F  1  FE 68 48 C9  
001D93  1  32 D0 FE 28  
001D97  1  A9 00 48 A9          set_a 1,0
001D9B  1  01 28        
001D9D  1  24 0B                bit zp1+2   ;41 - should set V (M6) / clear NZ
001D9F  1  08 C9 01 D0          tst_a 1,fv
001DA3  1  FE 68 48 C9  
001DA7  1  70 D0 FE 28  
001DAB  1  A9 00 48 A9          set_a 1,0
001DAF  1  01 28        
001DB1  1  24 0A                bit zp1+1   ;82 - should set N (M7) & Z / clear V
001DB3  1  08 C9 01 D0          tst_a 1,fnz
001DB7  1  FE 68 48 C9  
001DBB  1  B2 D0 FE 28  
001DBF  1  A9 00 48 A9          set_a 1,0
001DC3  1  01 28        
001DC5  1  24 09                bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
001DC7  1  08 C9 01 D0          tst_a 1,fnv
001DCB  1  FE 68 48 C9  
001DCF  1  F0 D0 FE 28  
001DD3  1               
001DD3  1  A9 FF 48 A9          set_a $ff,$ff
001DD7  1  FF 28        
001DD9  1  24 0C                bit zp1+3   ;00 - should set Z / clear  NV
001DDB  1  08 C9 FF D0          tst_a $ff,~fnv
001DDF  1  FE 68 48 C9  
001DE3  1  3F D0 FE 28  
001DE7  1  A9 FF 48 A9          set_a 1,$ff
001DEB  1  01 28        
001DED  1  24 0B                bit zp1+2   ;41 - should set V (M6) / clear NZ
001DEF  1  08 C9 01 D0          tst_a 1,~fnz
001DF3  1  FE 68 48 C9  
001DF7  1  7D D0 FE 28  
001DFB  1  A9 FF 48 A9          set_a 1,$ff
001DFF  1  01 28        
001E01  1  24 0A                bit zp1+1   ;82 - should set N (M7) & Z / clear V
001E03  1  08 C9 01 D0          tst_a 1,~fv
001E07  1  FE 68 48 C9  
001E0B  1  BF D0 FE 28  
001E0F  1  A9 FF 48 A9          set_a 1,$ff
001E13  1  01 28        
001E15  1  24 09                bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
001E17  1  08 C9 01 D0          tst_a 1,~fz
001E1B  1  FE 68 48 C9  
001E1F  1  FD D0 FE 28  
001E23  1               
001E23  1  A9 00 48 A9          set_a $ff,0
001E27  1  FF 28        
001E29  1  2C 1A 02             bit abs1+3  ;00 - should set Z / clear  NV
001E2C  1  08 C9 FF D0          tst_a $ff,fz
001E30  1  FE 68 48 C9  
001E34  1  32 D0 FE 28  
001E38  1  A9 00 48 A9          set_a 1,0
001E3C  1  01 28        
001E3E  1  2C 19 02             bit abs1+2  ;41 - should set V (M6) / clear NZ
001E41  1  08 C9 01 D0          tst_a 1,fv
001E45  1  FE 68 48 C9  
001E49  1  70 D0 FE 28  
001E4D  1  A9 00 48 A9          set_a 1,0
001E51  1  01 28        
001E53  1  2C 18 02             bit abs1+1  ;82 - should set N (M7) & Z / clear V
001E56  1  08 C9 01 D0          tst_a 1,fnz
001E5A  1  FE 68 48 C9  
001E5E  1  B2 D0 FE 28  
001E62  1  A9 00 48 A9          set_a 1,0
001E66  1  01 28        
001E68  1  2C 17 02             bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
001E6B  1  08 C9 01 D0          tst_a 1,fnv
001E6F  1  FE 68 48 C9  
001E73  1  F0 D0 FE 28  
001E77  1               
001E77  1  A9 FF 48 A9          set_a $ff,$ff
001E7B  1  FF 28        
001E7D  1  2C 1A 02             bit abs1+3  ;00 - should set Z / clear  NV
001E80  1  08 C9 FF D0          tst_a $ff,~fnv
001E84  1  FE 68 48 C9  
001E88  1  3F D0 FE 28  
001E8C  1  A9 FF 48 A9          set_a 1,$ff
001E90  1  01 28        
001E92  1  2C 19 02             bit abs1+2  ;41 - should set V (M6) / clear NZ
001E95  1  08 C9 01 D0          tst_a 1,~fnz
001E99  1  FE 68 48 C9  
001E9D  1  7D D0 FE 28  
001EA1  1  A9 FF 48 A9          set_a 1,$ff
001EA5  1  01 28        
001EA7  1  2C 18 02             bit abs1+1  ;82 - should set N (M7) & Z / clear V
001EAA  1  08 C9 01 D0          tst_a 1,~fv
001EAE  1  FE 68 48 C9  
001EB2  1  BF D0 FE 28  
001EB6  1  A9 FF 48 A9          set_a 1,$ff
001EBA  1  01 28        
001EBC  1  2C 17 02             bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
001EBF  1  08 C9 01 D0          tst_a 1,~fz
001EC3  1  FE 68 48 C9  
001EC7  1  FD D0 FE 28  
001ECB  1  AD 00 02 C9          next_test
001ECF  1  19 D0 FE A9  
001ED3  1  1A 8D 00 02  
001ED7  1               
001ED7  1               ; CPX - zp / abs / #
001ED7  1  A9 00 48 A2          set_x $80,0
001EDB  1  80 28        
001EDD  1  E4 0D                cpx zp7f
001EDF  1  08 68 48 C9          tst_stat fc
001EE3  1  31 D0 FE 28  
001EE7  1  CA                   dex
001EE8  1  E4 0D                cpx zp7f
001EEA  1  08 68 48 C9          tst_stat fzc
001EEE  1  33 D0 FE 28  
001EF2  1  CA                   dex
001EF3  1  E4 0D                cpx zp7f
001EF5  1  08 E0 7E D0          tst_x $7e,fn
001EF9  1  FE 68 48 C9  
001EFD  1  B0 D0 FE 28  
001F01  1  A9 FF 48 A2          set_x $80,$ff
001F05  1  80 28        
001F07  1  E4 0D                cpx zp7f
001F09  1  08 68 48 C9          tst_stat ~fnz
001F0D  1  7D D0 FE 28  
001F11  1  CA                   dex
001F12  1  E4 0D                cpx zp7f
001F14  1  08 68 48 C9          tst_stat ~fn
001F18  1  7F D0 FE 28  
001F1C  1  CA                   dex
001F1D  1  E4 0D                cpx zp7f
001F1F  1  08 E0 7E D0          tst_x $7e,~fzc
001F23  1  FE 68 48 C9  
001F27  1  FC D0 FE 28  
001F2B  1               
001F2B  1  A9 00 48 A2          set_x $80,0
001F2F  1  80 28        
001F31  1  EC 1B 02             cpx abs7f
001F34  1  08 68 48 C9          tst_stat fc
001F38  1  31 D0 FE 28  
001F3C  1  CA                   dex
001F3D  1  EC 1B 02             cpx abs7f
001F40  1  08 68 48 C9          tst_stat fzc
001F44  1  33 D0 FE 28  
001F48  1  CA                   dex
001F49  1  EC 1B 02             cpx abs7f
001F4C  1  08 E0 7E D0          tst_x $7e,fn
001F50  1  FE 68 48 C9  
001F54  1  B0 D0 FE 28  
001F58  1  A9 FF 48 A2          set_x $80,$ff
001F5C  1  80 28        
001F5E  1  EC 1B 02             cpx abs7f
001F61  1  08 68 48 C9          tst_stat ~fnz
001F65  1  7D D0 FE 28  
001F69  1  CA                   dex
001F6A  1  EC 1B 02             cpx abs7f
001F6D  1  08 68 48 C9          tst_stat ~fn
001F71  1  7F D0 FE 28  
001F75  1  CA                   dex
001F76  1  EC 1B 02             cpx abs7f
001F79  1  08 E0 7E D0          tst_x $7e,~fzc
001F7D  1  FE 68 48 C9  
001F81  1  FC D0 FE 28  
001F85  1               
001F85  1  A9 00 48 A2          set_x $80,0
001F89  1  80 28        
001F8B  1  E0 7F                cpx #$7f
001F8D  1  08 68 48 C9          tst_stat fc
001F91  1  31 D0 FE 28  
001F95  1  CA                   dex
001F96  1  E0 7F                cpx #$7f
001F98  1  08 68 48 C9          tst_stat fzc
001F9C  1  33 D0 FE 28  
001FA0  1  CA                   dex
001FA1  1  E0 7F                cpx #$7f
001FA3  1  08 E0 7E D0          tst_x $7e,fn
001FA7  1  FE 68 48 C9  
001FAB  1  B0 D0 FE 28  
001FAF  1  A9 FF 48 A2          set_x $80,$ff
001FB3  1  80 28        
001FB5  1  E0 7F                cpx #$7f
001FB7  1  08 68 48 C9          tst_stat ~fnz
001FBB  1  7D D0 FE 28  
001FBF  1  CA                   dex
001FC0  1  E0 7F                cpx #$7f
001FC2  1  08 68 48 C9          tst_stat ~fn
001FC6  1  7F D0 FE 28  
001FCA  1  CA                   dex
001FCB  1  E0 7F                cpx #$7f
001FCD  1  08 E0 7E D0          tst_x $7e,~fzc
001FD1  1  FE 68 48 C9  
001FD5  1  FC D0 FE 28  
001FD9  1  AD 00 02 C9          next_test
001FDD  1  1A D0 FE A9  
001FE1  1  1B 8D 00 02  
001FE5  1               
001FE5  1               ; CPY - zp / abs / #
001FE5  1  A9 00 48 A0          set_y $80,0
001FE9  1  80 28        
001FEB  1  C4 0D                cpy zp7f
001FED  1  08 68 48 C9          tst_stat fc
001FF1  1  31 D0 FE 28  
001FF5  1  88                   dey
001FF6  1  C4 0D                cpy zp7f
001FF8  1  08 68 48 C9          tst_stat fzc
001FFC  1  33 D0 FE 28  
002000  1  88                   dey
002001  1  C4 0D                cpy zp7f
002003  1  08 C0 7E D0          tst_y $7e,fn
002007  1  FE 68 48 C9  
00200B  1  B0 D0 FE 28  
00200F  1  A9 FF 48 A0          set_y $80,$ff
002013  1  80 28        
002015  1  C4 0D                cpy zp7f
002017  1  08 68 48 C9          tst_stat ~fnz
00201B  1  7D D0 FE 28  
00201F  1  88                   dey
002020  1  C4 0D                cpy zp7f
002022  1  08 68 48 C9          tst_stat ~fn
002026  1  7F D0 FE 28  
00202A  1  88                   dey
00202B  1  C4 0D                cpy zp7f
00202D  1  08 C0 7E D0          tst_y $7e,~fzc
002031  1  FE 68 48 C9  
002035  1  FC D0 FE 28  
002039  1               
002039  1  A9 00 48 A0          set_y $80,0
00203D  1  80 28        
00203F  1  CC 1B 02             cpy abs7f
002042  1  08 68 48 C9          tst_stat fc
002046  1  31 D0 FE 28  
00204A  1  88                   dey
00204B  1  CC 1B 02             cpy abs7f
00204E  1  08 68 48 C9          tst_stat fzc
002052  1  33 D0 FE 28  
002056  1  88                   dey
002057  1  CC 1B 02             cpy abs7f
00205A  1  08 C0 7E D0          tst_y $7e,fn
00205E  1  FE 68 48 C9  
002062  1  B0 D0 FE 28  
002066  1  A9 FF 48 A0          set_y $80,$ff
00206A  1  80 28        
00206C  1  CC 1B 02             cpy abs7f
00206F  1  08 68 48 C9          tst_stat ~fnz
002073  1  7D D0 FE 28  
002077  1  88                   dey
002078  1  CC 1B 02             cpy abs7f
00207B  1  08 68 48 C9          tst_stat ~fn
00207F  1  7F D0 FE 28  
002083  1  88                   dey
002084  1  CC 1B 02             cpy abs7f
002087  1  08 C0 7E D0          tst_y $7e,~fzc
00208B  1  FE 68 48 C9  
00208F  1  FC D0 FE 28  
002093  1               
002093  1  A9 00 48 A0          set_y $80,0
002097  1  80 28        
002099  1  C0 7F                cpy #$7f
00209B  1  08 68 48 C9          tst_stat fc
00209F  1  31 D0 FE 28  
0020A3  1  88                   dey
0020A4  1  C0 7F                cpy #$7f
0020A6  1  08 68 48 C9          tst_stat fzc
0020AA  1  33 D0 FE 28  
0020AE  1  88                   dey
0020AF  1  C0 7F                cpy #$7f
0020B1  1  08 C0 7E D0          tst_y $7e,fn
0020B5  1  FE 68 48 C9  
0020B9  1  B0 D0 FE 28  
0020BD  1  A9 FF 48 A0          set_y $80,$ff
0020C1  1  80 28        
0020C3  1  C0 7F                cpy #$7f
0020C5  1  08 68 48 C9          tst_stat ~fnz
0020C9  1  7D D0 FE 28  
0020CD  1  88                   dey
0020CE  1  C0 7F                cpy #$7f
0020D0  1  08 68 48 C9          tst_stat ~fn
0020D4  1  7F D0 FE 28  
0020D8  1  88                   dey
0020D9  1  C0 7F                cpy #$7f
0020DB  1  08 C0 7E D0          tst_y $7e,~fzc
0020DF  1  FE 68 48 C9  
0020E3  1  FC D0 FE 28  
0020E7  1  AD 00 02 C9          next_test
0020EB  1  1B D0 FE A9  
0020EF  1  1C 8D 00 02  
0020F3  1               
0020F3  1               ; CMP - zp / abs / #
0020F3  1  A9 00 48 A9          set_a $80,0
0020F7  1  80 28        
0020F9  1  C5 0D                cmp zp7f
0020FB  1  08 C9 80 D0          tst_a $80,fc
0020FF  1  FE 68 48 C9  
002103  1  31 D0 FE 28  
002107  1  A9 00 48 A9          set_a $7f,0
00210B  1  7F 28        
00210D  1  C5 0D                cmp zp7f
00210F  1  08 C9 7F D0          tst_a $7f,fzc
002113  1  FE 68 48 C9  
002117  1  33 D0 FE 28  
00211B  1  A9 00 48 A9          set_a $7e,0
00211F  1  7E 28        
002121  1  C5 0D                cmp zp7f
002123  1  08 C9 7E D0          tst_a $7e,fn
002127  1  FE 68 48 C9  
00212B  1  B0 D0 FE 28  
00212F  1  A9 FF 48 A9          set_a $80,$ff
002133  1  80 28        
002135  1  C5 0D                cmp zp7f
002137  1  08 C9 80 D0          tst_a $80,~fnz
00213B  1  FE 68 48 C9  
00213F  1  7D D0 FE 28  
002143  1  A9 FF 48 A9          set_a $7f,$ff
002147  1  7F 28        
002149  1  C5 0D                cmp zp7f
00214B  1  08 C9 7F D0          tst_a $7f,~fn
00214F  1  FE 68 48 C9  
002153  1  7F D0 FE 28  
002157  1  A9 FF 48 A9          set_a $7e,$ff
00215B  1  7E 28        
00215D  1  C5 0D                cmp zp7f
00215F  1  08 C9 7E D0          tst_a $7e,~fzc
002163  1  FE 68 48 C9  
002167  1  FC D0 FE 28  
00216B  1               
00216B  1  A9 00 48 A9          set_a $80,0
00216F  1  80 28        
002171  1  CD 1B 02             cmp abs7f
002174  1  08 C9 80 D0          tst_a $80,fc
002178  1  FE 68 48 C9  
00217C  1  31 D0 FE 28  
002180  1  A9 00 48 A9          set_a $7f,0
002184  1  7F 28        
002186  1  CD 1B 02             cmp abs7f
002189  1  08 C9 7F D0          tst_a $7f,fzc
00218D  1  FE 68 48 C9  
002191  1  33 D0 FE 28  
002195  1  A9 00 48 A9          set_a $7e,0
002199  1  7E 28        
00219B  1  CD 1B 02             cmp abs7f
00219E  1  08 C9 7E D0          tst_a $7e,fn
0021A2  1  FE 68 48 C9  
0021A6  1  B0 D0 FE 28  
0021AA  1  A9 FF 48 A9          set_a $80,$ff
0021AE  1  80 28        
0021B0  1  CD 1B 02             cmp abs7f
0021B3  1  08 C9 80 D0          tst_a $80,~fnz
0021B7  1  FE 68 48 C9  
0021BB  1  7D D0 FE 28  
0021BF  1  A9 FF 48 A9          set_a $7f,$ff
0021C3  1  7F 28        
0021C5  1  CD 1B 02             cmp abs7f
0021C8  1  08 C9 7F D0          tst_a $7f,~fn
0021CC  1  FE 68 48 C9  
0021D0  1  7F D0 FE 28  
0021D4  1  A9 FF 48 A9          set_a $7e,$ff
0021D8  1  7E 28        
0021DA  1  CD 1B 02             cmp abs7f
0021DD  1  08 C9 7E D0          tst_a $7e,~fzc
0021E1  1  FE 68 48 C9  
0021E5  1  FC D0 FE 28  
0021E9  1               
0021E9  1  A9 00 48 A9          set_a $80,0
0021ED  1  80 28        
0021EF  1  C9 7F                cmp #$7f
0021F1  1  08 C9 80 D0          tst_a $80,fc
0021F5  1  FE 68 48 C9  
0021F9  1  31 D0 FE 28  
0021FD  1  A9 00 48 A9          set_a $7f,0
002201  1  7F 28        
002203  1  C9 7F                cmp #$7f
002205  1  08 C9 7F D0          tst_a $7f,fzc
002209  1  FE 68 48 C9  
00220D  1  33 D0 FE 28  
002211  1  A9 00 48 A9          set_a $7e,0
002215  1  7E 28        
002217  1  C9 7F                cmp #$7f
002219  1  08 C9 7E D0          tst_a $7e,fn
00221D  1  FE 68 48 C9  
002221  1  B0 D0 FE 28  
002225  1  A9 FF 48 A9          set_a $80,$ff
002229  1  80 28        
00222B  1  C9 7F                cmp #$7f
00222D  1  08 C9 80 D0          tst_a $80,~fnz
002231  1  FE 68 48 C9  
002235  1  7D D0 FE 28  
002239  1  A9 FF 48 A9          set_a $7f,$ff
00223D  1  7F 28        
00223F  1  C9 7F                cmp #$7f
002241  1  08 C9 7F D0          tst_a $7f,~fn
002245  1  FE 68 48 C9  
002249  1  7F D0 FE 28  
00224D  1  A9 FF 48 A9          set_a $7e,$ff
002251  1  7E 28        
002253  1  C9 7F                cmp #$7f
002255  1  08 C9 7E D0          tst_a $7e,~fzc
002259  1  FE 68 48 C9  
00225D  1  FC D0 FE 28  
002261  1               
002261  1  A2 04                ldx #4          ;with indexing by X
002263  1  A9 00 48 A9          set_a $80,0
002267  1  80 28        
002269  1  D5 09                cmp zp1,x
00226B  1  08 C9 80 D0          tst_a $80,fc
00226F  1  FE 68 48 C9  
002273  1  31 D0 FE 28  
002277  1  A9 00 48 A9          set_a $7f,0
00227B  1  7F 28        
00227D  1  D5 09                cmp zp1,x
00227F  1  08 C9 7F D0          tst_a $7f,fzc
002283  1  FE 68 48 C9  
002287  1  33 D0 FE 28  
00228B  1  A9 00 48 A9          set_a $7e,0
00228F  1  7E 28        
002291  1  D5 09                cmp zp1,x
002293  1  08 C9 7E D0          tst_a $7e,fn
002297  1  FE 68 48 C9  
00229B  1  B0 D0 FE 28  
00229F  1  A9 FF 48 A9          set_a $80,$ff
0022A3  1  80 28        
0022A5  1  D5 09                cmp zp1,x
0022A7  1  08 C9 80 D0          tst_a $80,~fnz
0022AB  1  FE 68 48 C9  
0022AF  1  7D D0 FE 28  
0022B3  1  A9 FF 48 A9          set_a $7f,$ff
0022B7  1  7F 28        
0022B9  1  D5 09                cmp zp1,x
0022BB  1  08 C9 7F D0          tst_a $7f,~fn
0022BF  1  FE 68 48 C9  
0022C3  1  7F D0 FE 28  
0022C7  1  A9 FF 48 A9          set_a $7e,$ff
0022CB  1  7E 28        
0022CD  1  D5 09                cmp zp1,x
0022CF  1  08 C9 7E D0          tst_a $7e,~fzc
0022D3  1  FE 68 48 C9  
0022D7  1  FC D0 FE 28  
0022DB  1               
0022DB  1  A9 00 48 A9          set_a $80,0
0022DF  1  80 28        
0022E1  1  DD 17 02             cmp abs1,x
0022E4  1  08 C9 80 D0          tst_a $80,fc
0022E8  1  FE 68 48 C9  
0022EC  1  31 D0 FE 28  
0022F0  1  A9 00 48 A9          set_a $7f,0
0022F4  1  7F 28        
0022F6  1  DD 17 02             cmp abs1,x
0022F9  1  08 C9 7F D0          tst_a $7f,fzc
0022FD  1  FE 68 48 C9  
002301  1  33 D0 FE 28  
002305  1  A9 00 48 A9          set_a $7e,0
002309  1  7E 28        
00230B  1  DD 17 02             cmp abs1,x
00230E  1  08 C9 7E D0          tst_a $7e,fn
002312  1  FE 68 48 C9  
002316  1  B0 D0 FE 28  
00231A  1  A9 FF 48 A9          set_a $80,$ff
00231E  1  80 28        
002320  1  DD 17 02             cmp abs1,x
002323  1  08 C9 80 D0          tst_a $80,~fnz
002327  1  FE 68 48 C9  
00232B  1  7D D0 FE 28  
00232F  1  A9 FF 48 A9          set_a $7f,$ff
002333  1  7F 28        
002335  1  DD 17 02             cmp abs1,x
002338  1  08 C9 7F D0          tst_a $7f,~fn
00233C  1  FE 68 48 C9  
002340  1  7F D0 FE 28  
002344  1  A9 FF 48 A9          set_a $7e,$ff
002348  1  7E 28        
00234A  1  DD 17 02             cmp abs1,x
00234D  1  08 C9 7E D0          tst_a $7e,~fzc
002351  1  FE 68 48 C9  
002355  1  FC D0 FE 28  
002359  1               
002359  1  A0 04                ldy #4          ;with indexing by Y
00235B  1  A2 08                ldx #8          ;with indexed indirect
00235D  1  A9 00 48 A9          set_a $80,0
002361  1  80 28        
002363  1  D9 17 02             cmp abs1,y
002366  1  08 C9 80 D0          tst_a $80,fc
00236A  1  FE 68 48 C9  
00236E  1  31 D0 FE 28  
002372  1  A9 00 48 A9          set_a $7f,0
002376  1  7F 28        
002378  1  D9 17 02             cmp abs1,y
00237B  1  08 C9 7F D0          tst_a $7f,fzc
00237F  1  FE 68 48 C9  
002383  1  33 D0 FE 28  
002387  1  A9 00 48 A9          set_a $7e,0
00238B  1  7E 28        
00238D  1  D9 17 02             cmp abs1,y
002390  1  08 C9 7E D0          tst_a $7e,fn
002394  1  FE 68 48 C9  
002398  1  B0 D0 FE 28  
00239C  1  A9 FF 48 A9          set_a $80,$ff
0023A0  1  80 28        
0023A2  1  D9 17 02             cmp abs1,y
0023A5  1  08 C9 80 D0          tst_a $80,~fnz
0023A9  1  FE 68 48 C9  
0023AD  1  7D D0 FE 28  
0023B1  1  A9 FF 48 A9          set_a $7f,$ff
0023B5  1  7F 28        
0023B7  1  D9 17 02             cmp abs1,y
0023BA  1  08 C9 7F D0          tst_a $7f,~fn
0023BE  1  FE 68 48 C9  
0023C2  1  7F D0 FE 28  
0023C6  1  A9 FF 48 A9          set_a $7e,$ff
0023CA  1  7E 28        
0023CC  1  D9 17 02             cmp abs1,y
0023CF  1  08 C9 7E D0          tst_a $7e,~fzc
0023D3  1  FE 68 48 C9  
0023D7  1  FC D0 FE 28  
0023DB  1               
0023DB  1  A9 00 48 A9          set_a $80,0
0023DF  1  80 28        
0023E1  1  C1 1A                cmp (ind1,x)
0023E3  1  08 C9 80 D0          tst_a $80,fc
0023E7  1  FE 68 48 C9  
0023EB  1  31 D0 FE 28  
0023EF  1  A9 00 48 A9          set_a $7f,0
0023F3  1  7F 28        
0023F5  1  C1 1A                cmp (ind1,x)
0023F7  1  08 C9 7F D0          tst_a $7f,fzc
0023FB  1  FE 68 48 C9  
0023FF  1  33 D0 FE 28  
002403  1  A9 00 48 A9          set_a $7e,0
002407  1  7E 28        
002409  1  C1 1A                cmp (ind1,x)
00240B  1  08 C9 7E D0          tst_a $7e,fn
00240F  1  FE 68 48 C9  
002413  1  B0 D0 FE 28  
002417  1  A9 FF 48 A9          set_a $80,$ff
00241B  1  80 28        
00241D  1  C1 1A                cmp (ind1,x)
00241F  1  08 C9 80 D0          tst_a $80,~fnz
002423  1  FE 68 48 C9  
002427  1  7D D0 FE 28  
00242B  1  A9 FF 48 A9          set_a $7f,$ff
00242F  1  7F 28        
002431  1  C1 1A                cmp (ind1,x)
002433  1  08 C9 7F D0          tst_a $7f,~fn
002437  1  FE 68 48 C9  
00243B  1  7F D0 FE 28  
00243F  1  A9 FF 48 A9          set_a $7e,$ff
002443  1  7E 28        
002445  1  C1 1A                cmp (ind1,x)
002447  1  08 C9 7E D0          tst_a $7e,~fzc
00244B  1  FE 68 48 C9  
00244F  1  FC D0 FE 28  
002453  1               
002453  1  A9 00 48 A9          set_a $80,0
002457  1  80 28        
002459  1  D1 1A                cmp (ind1),y
00245B  1  08 C9 80 D0          tst_a $80,fc
00245F  1  FE 68 48 C9  
002463  1  31 D0 FE 28  
002467  1  A9 00 48 A9          set_a $7f,0
00246B  1  7F 28        
00246D  1  D1 1A                cmp (ind1),y
00246F  1  08 C9 7F D0          tst_a $7f,fzc
002473  1  FE 68 48 C9  
002477  1  33 D0 FE 28  
00247B  1  A9 00 48 A9          set_a $7e,0
00247F  1  7E 28        
002481  1  D1 1A                cmp (ind1),y
002483  1  08 C9 7E D0          tst_a $7e,fn
002487  1  FE 68 48 C9  
00248B  1  B0 D0 FE 28  
00248F  1  A9 FF 48 A9          set_a $80,$ff
002493  1  80 28        
002495  1  D1 1A                cmp (ind1),y
002497  1  08 C9 80 D0          tst_a $80,~fnz
00249B  1  FE 68 48 C9  
00249F  1  7D D0 FE 28  
0024A3  1  A9 FF 48 A9          set_a $7f,$ff
0024A7  1  7F 28        
0024A9  1  D1 1A                cmp (ind1),y
0024AB  1  08 C9 7F D0          tst_a $7f,~fn
0024AF  1  FE 68 48 C9  
0024B3  1  7F D0 FE 28  
0024B7  1  A9 FF 48 A9          set_a $7e,$ff
0024BB  1  7E 28        
0024BD  1  D1 1A                cmp (ind1),y
0024BF  1  08 C9 7E D0          tst_a $7e,~fzc
0024C3  1  FE 68 48 C9  
0024C7  1  FC D0 FE 28  
0024CB  1  AD 00 02 C9          next_test
0024CF  1  1C D0 FE A9  
0024D3  1  1D 8D 00 02  
0024D7  1               
0024D7  1               ; testing shifts - ASL LSR ROL ROR all addressing modes
0024D7  1               ; shifts - accumulator
0024D7  1  A2 03                ldx #3
0024D9  1               tasl:
0024D9  1  A9 00 48 B5          set_ax zp1,0
0024DD  1  09 28        
0024DF  1  0A                   asl a
0024E0  1  08 DD 20 02          tst_ax rASL,fASL,0
0024E4  1  D0 FE 68 49  
0024E8  1  30 DD 30 02  
0024EE  1  CA                   dex
0024EF  1  10 E8                bpl tasl
0024F1  1  A2 03                ldx #3
0024F3  1               tasl1:
0024F3  1  A9 FF 48 B5          set_ax zp1,$ff
0024F7  1  09 28        
0024F9  1  0A                   asl a
0024FA  1  08 DD 20 02          tst_ax rASL,fASL,$ff-fnzc
0024FE  1  D0 FE 68 49  
002502  1  7C DD 30 02  
002508  1  CA                   dex
002509  1  10 E8                bpl tasl1
00250B  1               
00250B  1  A2 03                ldx #3
00250D  1               tlsr:
00250D  1  A9 00 48 B5          set_ax zp1,0
002511  1  09 28        
002513  1  4A                   lsr a
002514  1  08 DD 28 02          tst_ax rLSR,fLSR,0
002518  1  D0 FE 68 49  
00251C  1  30 DD 38 02  
002522  1  CA                   dex
002523  1  10 E8                bpl tlsr
002525  1  A2 03                ldx #3
002527  1               tlsr1:
002527  1  A9 FF 48 B5          set_ax zp1,$ff
00252B  1  09 28        
00252D  1  4A                   lsr a
00252E  1  08 DD 28 02          tst_ax rLSR,fLSR,$ff-fnzc
002532  1  D0 FE 68 49  
002536  1  7C DD 38 02  
00253C  1  CA                   dex
00253D  1  10 E8                bpl tlsr1
00253F  1               
00253F  1  A2 03                ldx #3
002541  1               trol:
002541  1  A9 00 48 B5          set_ax zp1,0
002545  1  09 28        
002547  1  2A                   rol a
002548  1  08 DD 20 02          tst_ax rROL,fROL,0
00254C  1  D0 FE 68 49  
002550  1  30 DD 30 02  
002556  1  CA                   dex
002557  1  10 E8                bpl trol
002559  1  A2 03                ldx #3
00255B  1               trol1:
00255B  1  A9 FE 48 B5          set_ax zp1,$ff-fc
00255F  1  09 28        
002561  1  2A                   rol a
002562  1  08 DD 20 02          tst_ax rROL,fROL,$ff-fnzc
002566  1  D0 FE 68 49  
00256A  1  7C DD 30 02  
002570  1  CA                   dex
002571  1  10 E8                bpl trol1
002573  1               
002573  1  A2 03                ldx #3
002575  1               trolc:
002575  1  A9 01 48 B5          set_ax zp1,fc
002579  1  09 28        
00257B  1  2A                   rol a
00257C  1  08 DD 24 02          tst_ax rROLc,fROLc,0
002580  1  D0 FE 68 49  
002584  1  30 DD 34 02  
00258A  1  CA                   dex
00258B  1  10 E8                bpl trolc
00258D  1  A2 03                ldx #3
00258F  1               trolc1:
00258F  1  A9 FF 48 B5          set_ax zp1,$ff
002593  1  09 28        
002595  1  2A                   rol a
002596  1  08 DD 24 02          tst_ax rROLc,fROLc,$ff-fnzc
00259A  1  D0 FE 68 49  
00259E  1  7C DD 34 02  
0025A4  1  CA                   dex
0025A5  1  10 E8                bpl trolc1
0025A7  1               
0025A7  1  A2 03                ldx #3
0025A9  1               tror:
0025A9  1  A9 00 48 B5          set_ax zp1,0
0025AD  1  09 28        
0025AF  1  6A                   ror a
0025B0  1  08 DD 28 02          tst_ax rROR,fROR,0
0025B4  1  D0 FE 68 49  
0025B8  1  30 DD 38 02  
0025BE  1  CA                   dex
0025BF  1  10 E8                bpl tror
0025C1  1  A2 03                ldx #3
0025C3  1               tror1:
0025C3  1  A9 FE 48 B5          set_ax zp1,$ff-fc
0025C7  1  09 28        
0025C9  1  6A                   ror a
0025CA  1  08 DD 28 02          tst_ax rROR,fROR,$ff-fnzc
0025CE  1  D0 FE 68 49  
0025D2  1  7C DD 38 02  
0025D8  1  CA                   dex
0025D9  1  10 E8                bpl tror1
0025DB  1               
0025DB  1  A2 03                ldx #3
0025DD  1               trorc:
0025DD  1  A9 01 48 B5          set_ax zp1,fc
0025E1  1  09 28        
0025E3  1  6A                   ror a
0025E4  1  08 DD 2C 02          tst_ax rRORc,fRORc,0
0025E8  1  D0 FE 68 49  
0025EC  1  30 DD 3C 02  
0025F2  1  CA                   dex
0025F3  1  10 E8                bpl trorc
0025F5  1  A2 03                ldx #3
0025F7  1               trorc1:
0025F7  1  A9 FF 48 B5          set_ax zp1,$ff
0025FB  1  09 28        
0025FD  1  6A                   ror a
0025FE  1  08 DD 2C 02          tst_ax rRORc,fRORc,$ff-fnzc
002602  1  D0 FE 68 49  
002606  1  7C DD 3C 02  
00260C  1  CA                   dex
00260D  1  10 E8                bpl trorc1
00260F  1  AD 00 02 C9          next_test
002613  1  1D D0 FE A9  
002617  1  1E 8D 00 02  
00261B  1               
00261B  1               ; shifts - zeropage
00261B  1  A2 03                ldx #3
00261D  1               tasl2:
00261D  1  A9 00 48 B5          set_z zp1,0
002621  1  09 85 02 28  
002625  1  06 02                asl zpt
002627  1  08 A5 02 DD          tst_z rASL,fASL,0
00262B  1  20 02 D0 FE  
00262F  1  68 49 30 DD  
002637  1  CA                   dex
002638  1  10 E3                bpl tasl2
00263A  1  A2 03                ldx #3
00263C  1               tasl3:
00263C  1  A9 FF 48 B5          set_z zp1,$ff
002640  1  09 85 02 28  
002644  1  06 02                asl zpt
002646  1  08 A5 02 DD          tst_z rASL,fASL,$ff-fnzc
00264A  1  20 02 D0 FE  
00264E  1  68 49 7C DD  
002656  1  CA                   dex
002657  1  10 E3                bpl tasl3
002659  1               
002659  1  A2 03                ldx #3
00265B  1               tlsr2:
00265B  1  A9 00 48 B5          set_z zp1,0
00265F  1  09 85 02 28  
002663  1  46 02                lsr zpt
002665  1  08 A5 02 DD          tst_z rLSR,fLSR,0
002669  1  28 02 D0 FE  
00266D  1  68 49 30 DD  
002675  1  CA                   dex
002676  1  10 E3                bpl tlsr2
002678  1  A2 03                ldx #3
00267A  1               tlsr3:
00267A  1  A9 FF 48 B5          set_z zp1,$ff
00267E  1  09 85 02 28  
002682  1  46 02                lsr zpt
002684  1  08 A5 02 DD          tst_z rLSR,fLSR,$ff-fnzc
002688  1  28 02 D0 FE  
00268C  1  68 49 7C DD  
002694  1  CA                   dex
002695  1  10 E3                bpl tlsr3
002697  1               
002697  1  A2 03                ldx #3
002699  1               trol2:
002699  1  A9 00 48 B5          set_z zp1,0
00269D  1  09 85 02 28  
0026A1  1  26 02                rol zpt
0026A3  1  08 A5 02 DD          tst_z rROL,fROL,0
0026A7  1  20 02 D0 FE  
0026AB  1  68 49 30 DD  
0026B3  1  CA                   dex
0026B4  1  10 E3                bpl trol2
0026B6  1  A2 03                ldx #3
0026B8  1               trol3:
0026B8  1  A9 FE 48 B5          set_z zp1,$ff-fc
0026BC  1  09 85 02 28  
0026C0  1  26 02                rol zpt
0026C2  1  08 A5 02 DD          tst_z rROL,fROL,$ff-fnzc
0026C6  1  20 02 D0 FE  
0026CA  1  68 49 7C DD  
0026D2  1  CA                   dex
0026D3  1  10 E3                bpl trol3
0026D5  1               
0026D5  1  A2 03                ldx #3
0026D7  1               trolc2:
0026D7  1  A9 01 48 B5          set_z zp1,fc
0026DB  1  09 85 02 28  
0026DF  1  26 02                rol zpt
0026E1  1  08 A5 02 DD          tst_z rROLc,fROLc,0
0026E5  1  24 02 D0 FE  
0026E9  1  68 49 30 DD  
0026F1  1  CA                   dex
0026F2  1  10 E3                bpl trolc2
0026F4  1  A2 03                ldx #3
0026F6  1               trolc3:
0026F6  1  A9 FF 48 B5          set_z zp1,$ff
0026FA  1  09 85 02 28  
0026FE  1  26 02                rol zpt
002700  1  08 A5 02 DD          tst_z rROLc,fROLc,$ff-fnzc
002704  1  24 02 D0 FE  
002708  1  68 49 7C DD  
002710  1  CA                   dex
002711  1  10 E3                bpl trolc3
002713  1               
002713  1  A2 03                ldx #3
002715  1               tror2:
002715  1  A9 00 48 B5          set_z zp1,0
002719  1  09 85 02 28  
00271D  1  66 02                ror zpt
00271F  1  08 A5 02 DD          tst_z rROR,fROR,0
002723  1  28 02 D0 FE  
002727  1  68 49 30 DD  
00272F  1  CA                   dex
002730  1  10 E3                bpl tror2
002732  1  A2 03                ldx #3
002734  1               tror3:
002734  1  A9 FE 48 B5          set_z zp1,$ff-fc
002738  1  09 85 02 28  
00273C  1  66 02                ror zpt
00273E  1  08 A5 02 DD          tst_z rROR,fROR,$ff-fnzc
002742  1  28 02 D0 FE  
002746  1  68 49 7C DD  
00274E  1  CA                   dex
00274F  1  10 E3                bpl tror3
002751  1               
002751  1  A2 03                ldx #3
002753  1               trorc2:
002753  1  A9 01 48 B5          set_z zp1,fc
002757  1  09 85 02 28  
00275B  1  66 02                ror zpt
00275D  1  08 A5 02 DD          tst_z rRORc,fRORc,0
002761  1  2C 02 D0 FE  
002765  1  68 49 30 DD  
00276D  1  CA                   dex
00276E  1  10 E3                bpl trorc2
002770  1  A2 03                ldx #3
002772  1               trorc3:
002772  1  A9 FF 48 B5          set_z zp1,$ff
002776  1  09 85 02 28  
00277A  1  66 02                ror zpt
00277C  1  08 A5 02 DD          tst_z rRORc,fRORc,$ff-fnzc
002780  1  2C 02 D0 FE  
002784  1  68 49 7C DD  
00278C  1  CA                   dex
00278D  1  10 E3                bpl trorc3
00278F  1  AD 00 02 C9          next_test
002793  1  1E D0 FE A9  
002797  1  1F 8D 00 02  
00279B  1               
00279B  1               ; shifts - absolute
00279B  1  A2 03                ldx #3
00279D  1               tasl4:
00279D  1  A9 00 48 B5          set_abs zp1,0
0027A1  1  09 8D 03 02  
0027A5  1  28           
0027A6  1  0E 03 02             asl abst
0027A9  1  08 AD 03 02          tst_abs rASL,fASL,0
0027AD  1  DD 20 02 D0  
0027B1  1  FE 68 49 30  
0027BA  1  CA                   dex
0027BB  1  10 E0                bpl tasl4
0027BD  1  A2 03                ldx #3
0027BF  1               tasl5:
0027BF  1  A9 FF 48 B5          set_abs zp1,$ff
0027C3  1  09 8D 03 02  
0027C7  1  28           
0027C8  1  0E 03 02             asl abst
0027CB  1  08 AD 03 02          tst_abs rASL,fASL,$ff-fnzc
0027CF  1  DD 20 02 D0  
0027D3  1  FE 68 49 7C  
0027DC  1  CA                   dex
0027DD  1  10 E0                bpl tasl5
0027DF  1               
0027DF  1  A2 03                ldx #3
0027E1  1               tlsr4:
0027E1  1  A9 00 48 B5          set_abs zp1,0
0027E5  1  09 8D 03 02  
0027E9  1  28           
0027EA  1  4E 03 02             lsr abst
0027ED  1  08 AD 03 02          tst_abs rLSR,fLSR,0
0027F1  1  DD 28 02 D0  
0027F5  1  FE 68 49 30  
0027FE  1  CA                   dex
0027FF  1  10 E0                bpl tlsr4
002801  1  A2 03                ldx #3
002803  1               tlsr5:
002803  1  A9 FF 48 B5          set_abs zp1,$ff
002807  1  09 8D 03 02  
00280B  1  28           
00280C  1  4E 03 02             lsr abst
00280F  1  08 AD 03 02          tst_abs rLSR,fLSR,$ff-fnzc
002813  1  DD 28 02 D0  
002817  1  FE 68 49 7C  
002820  1  CA                   dex
002821  1  10 E0                bpl tlsr5
002823  1               
002823  1  A2 03                ldx #3
002825  1               trol4:
002825  1  A9 00 48 B5          set_abs zp1,0
002829  1  09 8D 03 02  
00282D  1  28           
00282E  1  2E 03 02             rol abst
002831  1  08 AD 03 02          tst_abs rROL,fROL,0
002835  1  DD 20 02 D0  
002839  1  FE 68 49 30  
002842  1  CA                   dex
002843  1  10 E0                bpl trol4
002845  1  A2 03                ldx #3
002847  1               trol5:
002847  1  A9 FE 48 B5          set_abs zp1,$ff-fc
00284B  1  09 8D 03 02  
00284F  1  28           
002850  1  2E 03 02             rol abst
002853  1  08 AD 03 02          tst_abs rROL,fROL,$ff-fnzc
002857  1  DD 20 02 D0  
00285B  1  FE 68 49 7C  
002864  1  CA                   dex
002865  1  10 E0                bpl trol5
002867  1               
002867  1  A2 03                ldx #3
002869  1               trolc4:
002869  1  A9 01 48 B5          set_abs zp1,fc
00286D  1  09 8D 03 02  
002871  1  28           
002872  1  2E 03 02             rol abst
002875  1  08 AD 03 02          tst_abs rROLc,fROLc,0
002879  1  DD 24 02 D0  
00287D  1  FE 68 49 30  
002886  1  CA                   dex
002887  1  10 E0                bpl trolc4
002889  1  A2 03                ldx #3
00288B  1               trolc5:
00288B  1  A9 FF 48 B5          set_abs zp1,$ff
00288F  1  09 8D 03 02  
002893  1  28           
002894  1  2E 03 02             rol abst
002897  1  08 AD 03 02          tst_abs rROLc,fROLc,$ff-fnzc
00289B  1  DD 24 02 D0  
00289F  1  FE 68 49 7C  
0028A8  1  CA                   dex
0028A9  1  10 E0                bpl trolc5
0028AB  1               
0028AB  1  A2 03                ldx #3
0028AD  1               tror4:
0028AD  1  A9 00 48 B5          set_abs zp1,0
0028B1  1  09 8D 03 02  
0028B5  1  28           
0028B6  1  6E 03 02             ror abst
0028B9  1  08 AD 03 02          tst_abs rROR,fROR,0
0028BD  1  DD 28 02 D0  
0028C1  1  FE 68 49 30  
0028CA  1  CA                   dex
0028CB  1  10 E0                bpl tror4
0028CD  1  A2 03                ldx #3
0028CF  1               tror5:
0028CF  1  A9 FE 48 B5          set_abs zp1,$ff-fc
0028D3  1  09 8D 03 02  
0028D7  1  28           
0028D8  1  6E 03 02             ror abst
0028DB  1  08 AD 03 02          tst_abs rROR,fROR,$ff-fnzc
0028DF  1  DD 28 02 D0  
0028E3  1  FE 68 49 7C  
0028EC  1  CA                   dex
0028ED  1  10 E0                bpl tror5
0028EF  1               
0028EF  1  A2 03                ldx #3
0028F1  1               trorc4:
0028F1  1  A9 01 48 B5          set_abs zp1,fc
0028F5  1  09 8D 03 02  
0028F9  1  28           
0028FA  1  6E 03 02             ror abst
0028FD  1  08 AD 03 02          tst_abs rRORc,fRORc,0
002901  1  DD 2C 02 D0  
002905  1  FE 68 49 30  
00290E  1  CA                   dex
00290F  1  10 E0                bpl trorc4
002911  1  A2 03                ldx #3
002913  1               trorc5:
002913  1  A9 FF 48 B5          set_abs zp1,$ff
002917  1  09 8D 03 02  
00291B  1  28           
00291C  1  6E 03 02             ror abst
00291F  1  08 AD 03 02          tst_abs rRORc,fRORc,$ff-fnzc
002923  1  DD 2C 02 D0  
002927  1  FE 68 49 7C  
002930  1  CA                   dex
002931  1  10 E0                bpl trorc5
002933  1  AD 00 02 C9          next_test
002937  1  1F D0 FE A9  
00293B  1  20 8D 00 02  
00293F  1               
00293F  1               ; shifts - zp indexed
00293F  1  A2 03                ldx #3
002941  1               tasl6:
002941  1  A9 00 48 B5          set_zx zp1,0
002945  1  09 95 02 28  
002949  1  16 02                asl zpt,x
00294B  1  08 B5 02 DD          tst_zx rASL,fASL,0
00294F  1  20 02 D0 FE  
002953  1  68 49 30 DD  
00295B  1  CA                   dex
00295C  1  10 E3                bpl tasl6
00295E  1  A2 03                ldx #3
002960  1               tasl7:
002960  1  A9 FF 48 B5          set_zx zp1,$ff
002964  1  09 95 02 28  
002968  1  16 02                asl zpt,x
00296A  1  08 B5 02 DD          tst_zx rASL,fASL,$ff-fnzc
00296E  1  20 02 D0 FE  
002972  1  68 49 7C DD  
00297A  1  CA                   dex
00297B  1  10 E3                bpl tasl7
00297D  1               
00297D  1  A2 03                ldx #3
00297F  1               tlsr6:
00297F  1  A9 00 48 B5          set_zx zp1,0
002983  1  09 95 02 28  
002987  1  56 02                lsr zpt,x
002989  1  08 B5 02 DD          tst_zx rLSR,fLSR,0
00298D  1  28 02 D0 FE  
002991  1  68 49 30 DD  
002999  1  CA                   dex
00299A  1  10 E3                bpl tlsr6
00299C  1  A2 03                ldx #3
00299E  1               tlsr7:
00299E  1  A9 FF 48 B5          set_zx zp1,$ff
0029A2  1  09 95 02 28  
0029A6  1  56 02                lsr zpt,x
0029A8  1  08 B5 02 DD          tst_zx rLSR,fLSR,$ff-fnzc
0029AC  1  28 02 D0 FE  
0029B0  1  68 49 7C DD  
0029B8  1  CA                   dex
0029B9  1  10 E3                bpl tlsr7
0029BB  1               
0029BB  1  A2 03                ldx #3
0029BD  1               trol6:
0029BD  1  A9 00 48 B5          set_zx zp1,0
0029C1  1  09 95 02 28  
0029C5  1  36 02                rol zpt,x
0029C7  1  08 B5 02 DD          tst_zx rROL,fROL,0
0029CB  1  20 02 D0 FE  
0029CF  1  68 49 30 DD  
0029D7  1  CA                   dex
0029D8  1  10 E3                bpl trol6
0029DA  1  A2 03                ldx #3
0029DC  1               trol7:
0029DC  1  A9 FE 48 B5          set_zx zp1,$ff-fc
0029E0  1  09 95 02 28  
0029E4  1  36 02                rol zpt,x
0029E6  1  08 B5 02 DD          tst_zx rROL,fROL,$ff-fnzc
0029EA  1  20 02 D0 FE  
0029EE  1  68 49 7C DD  
0029F6  1  CA                   dex
0029F7  1  10 E3                bpl trol7
0029F9  1               
0029F9  1  A2 03                ldx #3
0029FB  1               trolc6:
0029FB  1  A9 01 48 B5          set_zx zp1,fc
0029FF  1  09 95 02 28  
002A03  1  36 02                rol zpt,x
002A05  1  08 B5 02 DD          tst_zx rROLc,fROLc,0
002A09  1  24 02 D0 FE  
002A0D  1  68 49 30 DD  
002A15  1  CA                   dex
002A16  1  10 E3                bpl trolc6
002A18  1  A2 03                ldx #3
002A1A  1               trolc7:
002A1A  1  A9 FF 48 B5          set_zx zp1,$ff
002A1E  1  09 95 02 28  
002A22  1  36 02                rol zpt,x
002A24  1  08 B5 02 DD          tst_zx rROLc,fROLc,$ff-fnzc
002A28  1  24 02 D0 FE  
002A2C  1  68 49 7C DD  
002A34  1  CA                   dex
002A35  1  10 E3                bpl trolc7
002A37  1               
002A37  1  A2 03                ldx #3
002A39  1               tror6:
002A39  1  A9 00 48 B5          set_zx zp1,0
002A3D  1  09 95 02 28  
002A41  1  76 02                ror zpt,x
002A43  1  08 B5 02 DD          tst_zx rROR,fROR,0
002A47  1  28 02 D0 FE  
002A4B  1  68 49 30 DD  
002A53  1  CA                   dex
002A54  1  10 E3                bpl tror6
002A56  1  A2 03                ldx #3
002A58  1               tror7:
002A58  1  A9 FE 48 B5          set_zx zp1,$ff-fc
002A5C  1  09 95 02 28  
002A60  1  76 02                ror zpt,x
002A62  1  08 B5 02 DD          tst_zx rROR,fROR,$ff-fnzc
002A66  1  28 02 D0 FE  
002A6A  1  68 49 7C DD  
002A72  1  CA                   dex
002A73  1  10 E3                bpl tror7
002A75  1               
002A75  1  A2 03                ldx #3
002A77  1               trorc6:
002A77  1  A9 01 48 B5          set_zx zp1,fc
002A7B  1  09 95 02 28  
002A7F  1  76 02                ror zpt,x
002A81  1  08 B5 02 DD          tst_zx rRORc,fRORc,0
002A85  1  2C 02 D0 FE  
002A89  1  68 49 30 DD  
002A91  1  CA                   dex
002A92  1  10 E3                bpl trorc6
002A94  1  A2 03                ldx #3
002A96  1               trorc7:
002A96  1  A9 FF 48 B5          set_zx zp1,$ff
002A9A  1  09 95 02 28  
002A9E  1  76 02                ror zpt,x
002AA0  1  08 B5 02 DD          tst_zx rRORc,fRORc,$ff-fnzc
002AA4  1  2C 02 D0 FE  
002AA8  1  68 49 7C DD  
002AB0  1  CA                   dex
002AB1  1  10 E3                bpl trorc7
002AB3  1  AD 00 02 C9          next_test
002AB7  1  20 D0 FE A9  
002ABB  1  21 8D 00 02  
002ABF  1               
002ABF  1               ; shifts - abs indexed
002ABF  1  A2 03                ldx #3
002AC1  1               tasl8:
002AC1  1  A9 00 48 B5          set_absx zp1,0
002AC5  1  09 9D 03 02  
002AC9  1  28           
002ACA  1  1E 03 02             asl abst,x
002ACD  1  08 BD 03 02          tst_absx rASL,fASL,0
002AD1  1  DD 20 02 D0  
002AD5  1  FE 68 49 30  
002ADE  1  CA                   dex
002ADF  1  10 E0                bpl tasl8
002AE1  1  A2 03                ldx #3
002AE3  1               tasl9:
002AE3  1  A9 FF 48 B5          set_absx zp1,$ff
002AE7  1  09 9D 03 02  
002AEB  1  28           
002AEC  1  1E 03 02             asl abst,x
002AEF  1  08 BD 03 02          tst_absx rASL,fASL,$ff-fnzc
002AF3  1  DD 20 02 D0  
002AF7  1  FE 68 49 7C  
002B00  1  CA                   dex
002B01  1  10 E0                bpl tasl9
002B03  1               
002B03  1  A2 03                ldx #3
002B05  1               tlsr8:
002B05  1  A9 00 48 B5          set_absx zp1,0
002B09  1  09 9D 03 02  
002B0D  1  28           
002B0E  1  5E 03 02             lsr abst,x
002B11  1  08 BD 03 02          tst_absx rLSR,fLSR,0
002B15  1  DD 28 02 D0  
002B19  1  FE 68 49 30  
002B22  1  CA                   dex
002B23  1  10 E0                bpl tlsr8
002B25  1  A2 03                ldx #3
002B27  1               tlsr9:
002B27  1  A9 FF 48 B5          set_absx zp1,$ff
002B2B  1  09 9D 03 02  
002B2F  1  28           
002B30  1  5E 03 02             lsr abst,x
002B33  1  08 BD 03 02          tst_absx rLSR,fLSR,$ff-fnzc
002B37  1  DD 28 02 D0  
002B3B  1  FE 68 49 7C  
002B44  1  CA                   dex
002B45  1  10 E0                bpl tlsr9
002B47  1               
002B47  1  A2 03                ldx #3
002B49  1               trol8:
002B49  1  A9 00 48 B5          set_absx zp1,0
002B4D  1  09 9D 03 02  
002B51  1  28           
002B52  1  3E 03 02             rol abst,x
002B55  1  08 BD 03 02          tst_absx rROL,fROL,0
002B59  1  DD 20 02 D0  
002B5D  1  FE 68 49 30  
002B66  1  CA                   dex
002B67  1  10 E0                bpl trol8
002B69  1  A2 03                ldx #3
002B6B  1               trol9:
002B6B  1  A9 FE 48 B5          set_absx zp1,$ff-fc
002B6F  1  09 9D 03 02  
002B73  1  28           
002B74  1  3E 03 02             rol abst,x
002B77  1  08 BD 03 02          tst_absx rROL,fROL,$ff-fnzc
002B7B  1  DD 20 02 D0  
002B7F  1  FE 68 49 7C  
002B88  1  CA                   dex
002B89  1  10 E0                bpl trol9
002B8B  1               
002B8B  1  A2 03                ldx #3
002B8D  1               trolc8:
002B8D  1  A9 01 48 B5          set_absx zp1,fc
002B91  1  09 9D 03 02  
002B95  1  28           
002B96  1  3E 03 02             rol abst,x
002B99  1  08 BD 03 02          tst_absx rROLc,fROLc,0
002B9D  1  DD 24 02 D0  
002BA1  1  FE 68 49 30  
002BAA  1  CA                   dex
002BAB  1  10 E0                bpl trolc8
002BAD  1  A2 03                ldx #3
002BAF  1               trolc9:
002BAF  1  A9 FF 48 B5          set_absx zp1,$ff
002BB3  1  09 9D 03 02  
002BB7  1  28           
002BB8  1  3E 03 02             rol abst,x
002BBB  1  08 BD 03 02          tst_absx rROLc,fROLc,$ff-fnzc
002BBF  1  DD 24 02 D0  
002BC3  1  FE 68 49 7C  
002BCC  1  CA                   dex
002BCD  1  10 E0                bpl trolc9
002BCF  1               
002BCF  1  A2 03                ldx #3
002BD1  1               tror8:
002BD1  1  A9 00 48 B5          set_absx zp1,0
002BD5  1  09 9D 03 02  
002BD9  1  28           
002BDA  1  7E 03 02             ror abst,x
002BDD  1  08 BD 03 02          tst_absx rROR,fROR,0
002BE1  1  DD 28 02 D0  
002BE5  1  FE 68 49 30  
002BEE  1  CA                   dex
002BEF  1  10 E0                bpl tror8
002BF1  1  A2 03                ldx #3
002BF3  1               tror9:
002BF3  1  A9 FE 48 B5          set_absx zp1,$ff-fc
002BF7  1  09 9D 03 02  
002BFB  1  28           
002BFC  1  7E 03 02             ror abst,x
002BFF  1  08 BD 03 02          tst_absx rROR,fROR,$ff-fnzc
002C03  1  DD 28 02 D0  
002C07  1  FE 68 49 7C  
002C10  1  CA                   dex
002C11  1  10 E0                bpl tror9
002C13  1               
002C13  1  A2 03                ldx #3
002C15  1               trorc8:
002C15  1  A9 01 48 B5          set_absx zp1,fc
002C19  1  09 9D 03 02  
002C1D  1  28           
002C1E  1  7E 03 02             ror abst,x
002C21  1  08 BD 03 02          tst_absx rRORc,fRORc,0
002C25  1  DD 2C 02 D0  
002C29  1  FE 68 49 30  
002C32  1  CA                   dex
002C33  1  10 E0                bpl trorc8
002C35  1  A2 03                ldx #3
002C37  1               trorc9:
002C37  1  A9 FF 48 B5          set_absx zp1,$ff
002C3B  1  09 9D 03 02  
002C3F  1  28           
002C40  1  7E 03 02             ror abst,x
002C43  1  08 BD 03 02          tst_absx rRORc,fRORc,$ff-fnzc
002C47  1  DD 2C 02 D0  
002C4B  1  FE 68 49 7C  
002C54  1  CA                   dex
002C55  1  10 E0                bpl trorc9
002C57  1  AD 00 02 C9          next_test
002C5B  1  21 D0 FE A9  
002C5F  1  22 8D 00 02  
002C63  1               
002C63  1               ; testing memory increment/decrement - INC DEC all addressing modes
002C63  1               ; zeropage
002C63  1  A2 00                ldx #0
002C65  1  A9 7E                lda #$7e
002C67  1  85 02                sta zpt
002C69  1               tinc:
002C69  1  A9 00 48 28          set_stat 0
002C6D  1  E6 02                inc zpt
002C6F  1  08 A5 02 DD          tst_z rINC,fINC,0
002C73  1  40 02 D0 FE  
002C77  1  68 49 30 DD  
002C7F  1  E8                   inx
002C80  1  E0 02                cpx #2
002C82  1  D0 04                bne tinc1
002C84  1  A9 FE                lda #$fe
002C86  1  85 02                sta zpt
002C88  1  E0 05        tinc1:  cpx #5
002C8A  1  D0 DD                bne tinc
002C8C  1  CA                   dex
002C8D  1  E6 02                inc zpt
002C8F  1               tdec:
002C8F  1  A9 00 48 28          set_stat 0
002C93  1  C6 02                dec zpt
002C95  1  08 A5 02 DD          tst_z rINC,fINC,0
002C99  1  40 02 D0 FE  
002C9D  1  68 49 30 DD  
002CA5  1  CA                   dex
002CA6  1  30 0A                bmi tdec1
002CA8  1  E0 01                cpx #1
002CAA  1  D0 E3                bne tdec
002CAC  1  A9 81                lda #$81
002CAE  1  85 02                sta zpt
002CB0  1  D0 DD                bne tdec
002CB2  1               tdec1:
002CB2  1  A2 00                ldx #0
002CB4  1  A9 7E                lda #$7e
002CB6  1  85 02                sta zpt
002CB8  1               tinc10:
002CB8  1  A9 FF 48 28          set_stat $ff
002CBC  1  E6 02                inc zpt
002CBE  1  08 A5 02 DD          tst_z rINC,fINC,$ff-fnz
002CC2  1  40 02 D0 FE  
002CC6  1  68 49 7D DD  
002CCE  1  E8                   inx
002CCF  1  E0 02                cpx #2
002CD1  1  D0 04                bne tinc11
002CD3  1  A9 FE                lda #$fe
002CD5  1  85 02                sta zpt
002CD7  1  E0 05        tinc11: cpx #5
002CD9  1  D0 DD                bne tinc10
002CDB  1  CA                   dex
002CDC  1  E6 02                inc zpt
002CDE  1               tdec10:
002CDE  1  A9 FF 48 28          set_stat $ff
002CE2  1  C6 02                dec zpt
002CE4  1  08 A5 02 DD          tst_z rINC,fINC,$ff-fnz
002CE8  1  40 02 D0 FE  
002CEC  1  68 49 7D DD  
002CF4  1  CA                   dex
002CF5  1  30 0A                bmi tdec11
002CF7  1  E0 01                cpx #1
002CF9  1  D0 E3                bne tdec10
002CFB  1  A9 81                lda #$81
002CFD  1  85 02                sta zpt
002CFF  1  D0 DD                bne tdec10
002D01  1               tdec11:
002D01  1  AD 00 02 C9          next_test
002D05  1  22 D0 FE A9  
002D09  1  23 8D 00 02  
002D0D  1               
002D0D  1               ; absolute memory
002D0D  1  A2 00                ldx #0
002D0F  1  A9 7E                lda #$7e
002D11  1  8D 03 02             sta abst
002D14  1               tinc2:
002D14  1  A9 00 48 28          set_stat 0
002D18  1  EE 03 02             inc abst
002D1B  1  08 AD 03 02          tst_abs rINC,fINC,0
002D1F  1  DD 40 02 D0  
002D23  1  FE 68 49 30  
002D2C  1  E8                   inx
002D2D  1  E0 02                cpx #2
002D2F  1  D0 05                bne tinc3
002D31  1  A9 FE                lda #$fe
002D33  1  8D 03 02             sta abst
002D36  1  E0 05        tinc3:  cpx #5
002D38  1  D0 DA                bne tinc2
002D3A  1  CA                   dex
002D3B  1  EE 03 02             inc abst
002D3E  1               tdec2:
002D3E  1  A9 00 48 28          set_stat 0
002D42  1  CE 03 02             dec abst
002D45  1  08 AD 03 02          tst_abs rINC,fINC,0
002D49  1  DD 40 02 D0  
002D4D  1  FE 68 49 30  
002D56  1  CA                   dex
002D57  1  30 0B                bmi tdec3
002D59  1  E0 01                cpx #1
002D5B  1  D0 E1                bne tdec2
002D5D  1  A9 81                lda #$81
002D5F  1  8D 03 02             sta abst
002D62  1  D0 DA                bne tdec2
002D64  1               tdec3:
002D64  1  A2 00                ldx #0
002D66  1  A9 7E                lda #$7e
002D68  1  8D 03 02             sta abst
002D6B  1               tinc12:
002D6B  1  A9 FF 48 28          set_stat $ff
002D6F  1  EE 03 02             inc abst
002D72  1  08 AD 03 02          tst_abs rINC,fINC,$ff-fnz
002D76  1  DD 40 02 D0  
002D7A  1  FE 68 49 7D  
002D83  1  E8                   inx
002D84  1  E0 02                cpx #2
002D86  1  D0 05                bne tinc13
002D88  1  A9 FE                lda #$fe
002D8A  1  8D 03 02             sta abst
002D8D  1  E0 05        tinc13:  cpx #5
002D8F  1  D0 DA                bne tinc12
002D91  1  CA                   dex
002D92  1  EE 03 02             inc abst
002D95  1               tdec12:
002D95  1  A9 FF 48 28          set_stat $ff
002D99  1  CE 03 02             dec abst
002D9C  1  08 AD 03 02          tst_abs rINC,fINC,$ff-fnz
002DA0  1  DD 40 02 D0  
002DA4  1  FE 68 49 7D  
002DAD  1  CA                   dex
002DAE  1  30 0B                bmi tdec13
002DB0  1  E0 01                cpx #1
002DB2  1  D0 E1                bne tdec12
002DB4  1  A9 81                lda #$81
002DB6  1  8D 03 02             sta abst
002DB9  1  D0 DA                bne tdec12
002DBB  1               tdec13:
002DBB  1  AD 00 02 C9          next_test
002DBF  1  23 D0 FE A9  
002DC3  1  24 8D 00 02  
002DC7  1               
002DC7  1               ; zeropage indexed
002DC7  1  A2 00                ldx #0
002DC9  1  A9 7E                lda #$7e
002DCB  1  95 02        tinc4:  sta zpt,x
002DCD  1  A9 00 48 28          set_stat 0
002DD1  1  F6 02                inc zpt,x
002DD3  1  08 B5 02 DD          tst_zx rINC,fINC,0
002DD7  1  40 02 D0 FE  
002DDB  1  68 49 30 DD  
002DE3  1  B5 02                lda zpt,x
002DE5  1  E8                   inx
002DE6  1  E0 02                cpx #2
002DE8  1  D0 02                bne tinc5
002DEA  1  A9 FE                lda #$fe
002DEC  1  E0 05        tinc5:  cpx #5
002DEE  1  D0 DB                bne tinc4
002DF0  1  CA                   dex
002DF1  1  A9 02                lda #2
002DF3  1  95 02        tdec4:  sta zpt,x
002DF5  1  A9 00 48 28          set_stat 0
002DF9  1  D6 02                dec zpt,x
002DFB  1  08 B5 02 DD          tst_zx rINC,fINC,0
002DFF  1  40 02 D0 FE  
002E03  1  68 49 30 DD  
002E0B  1  B5 02                lda zpt,x
002E0D  1  CA                   dex
002E0E  1  30 08                bmi tdec5
002E10  1  E0 01                cpx #1
002E12  1  D0 DF                bne tdec4
002E14  1  A9 81                lda #$81
002E16  1  D0 DB                bne tdec4
002E18  1               tdec5:
002E18  1  A2 00                ldx #0
002E1A  1  A9 7E                lda #$7e
002E1C  1  95 02        tinc14: sta zpt,x
002E1E  1  A9 FF 48 28          set_stat $ff
002E22  1  F6 02                inc zpt,x
002E24  1  08 B5 02 DD          tst_zx rINC,fINC,$ff-fnz
002E28  1  40 02 D0 FE  
002E2C  1  68 49 7D DD  
002E34  1  B5 02                lda zpt,x
002E36  1  E8                   inx
002E37  1  E0 02                cpx #2
002E39  1  D0 02                bne tinc15
002E3B  1  A9 FE                lda #$fe
002E3D  1  E0 05        tinc15: cpx #5
002E3F  1  D0 DB                bne tinc14
002E41  1  CA                   dex
002E42  1  A9 02                lda #2
002E44  1  95 02        tdec14: sta zpt,x
002E46  1  A9 FF 48 28          set_stat $ff
002E4A  1  D6 02                dec zpt,x
002E4C  1  08 B5 02 DD          tst_zx rINC,fINC,$ff-fnz
002E50  1  40 02 D0 FE  
002E54  1  68 49 7D DD  
002E5C  1  B5 02                lda zpt,x
002E5E  1  CA                   dex
002E5F  1  30 08                bmi tdec15
002E61  1  E0 01                cpx #1
002E63  1  D0 DF                bne tdec14
002E65  1  A9 81                lda #$81
002E67  1  D0 DB                bne tdec14
002E69  1               tdec15:
002E69  1  AD 00 02 C9          next_test
002E6D  1  24 D0 FE A9  
002E71  1  25 8D 00 02  
002E75  1               
002E75  1               ; memory indexed
002E75  1  A2 00                ldx #0
002E77  1  A9 7E                lda #$7e
002E79  1  9D 03 02     tinc6:  sta abst,x
002E7C  1  A9 00 48 28          set_stat 0
002E80  1  FE 03 02             inc abst,x
002E83  1  08 BD 03 02          tst_absx rINC,fINC,0
002E87  1  DD 40 02 D0  
002E8B  1  FE 68 49 30  
002E94  1  BD 03 02             lda abst,x
002E97  1  E8                   inx
002E98  1  E0 02                cpx #2
002E9A  1  D0 02                bne tinc7
002E9C  1  A9 FE                lda #$fe
002E9E  1  E0 05        tinc7:  cpx #5
002EA0  1  D0 D7                bne tinc6
002EA2  1  CA                   dex
002EA3  1  A9 02                lda #2
002EA5  1  9D 03 02     tdec6:  sta abst,x
002EA8  1  A9 00 48 28          set_stat 0
002EAC  1  DE 03 02             dec abst,x
002EAF  1  08 BD 03 02          tst_absx rINC,fINC,0
002EB3  1  DD 40 02 D0  
002EB7  1  FE 68 49 30  
002EC0  1  BD 03 02             lda abst,x
002EC3  1  CA                   dex
002EC4  1  30 08                bmi tdec7
002EC6  1  E0 01                cpx #1
002EC8  1  D0 DB                bne tdec6
002ECA  1  A9 81                lda #$81
002ECC  1  D0 D7                bne tdec6
002ECE  1               tdec7:
002ECE  1  A2 00                ldx #0
002ED0  1  A9 7E                lda #$7e
002ED2  1  9D 03 02     tinc16: sta abst,x
002ED5  1  A9 FF 48 28          set_stat $ff
002ED9  1  FE 03 02             inc abst,x
002EDC  1  08 BD 03 02          tst_absx rINC,fINC,$ff-fnz
002EE0  1  DD 40 02 D0  
002EE4  1  FE 68 49 7D  
002EED  1  BD 03 02             lda abst,x
002EF0  1  E8                   inx
002EF1  1  E0 02                cpx #2
002EF3  1  D0 02                bne tinc17
002EF5  1  A9 FE                lda #$fe
002EF7  1  E0 05        tinc17: cpx #5
002EF9  1  D0 D7                bne tinc16
002EFB  1  CA                   dex
002EFC  1  A9 02                lda #2
002EFE  1  9D 03 02     tdec16: sta abst,x
002F01  1  A9 FF 48 28          set_stat $ff
002F05  1  DE 03 02             dec abst,x
002F08  1  08 BD 03 02          tst_absx rINC,fINC,$ff-fnz
002F0C  1  DD 40 02 D0  
002F10  1  FE 68 49 7D  
002F19  1  BD 03 02             lda abst,x
002F1C  1  CA                   dex
002F1D  1  30 08                bmi tdec17
002F1F  1  E0 01                cpx #1
002F21  1  D0 DB                bne tdec16
002F23  1  A9 81                lda #$81
002F25  1  D0 D7                bne tdec16
002F27  1               tdec17:
002F27  1  AD 00 02 C9          next_test
002F2B  1  25 D0 FE A9  
002F2F  1  26 8D 00 02  
002F33  1               
002F33  1               ; testing logical instructions - AND EOR ORA all addressing modes
002F33  1               ; AND
002F33  1  A2 03                ldx #3          ;immediate
002F35  1  B5 12        tand:   lda zpAN,x
002F37  1  8D 09 02             sta ex_andi+1   ;set AND # operand
002F3A  1  A9 00 48 BD          set_ax  absANa,0
002F3E  1  5A 02 28     
002F41  1  20 08 02             jsr ex_andi     ;execute AND # in RAM
002F44  1  08 DD 62 02          tst_ax  absrlo,absflo,0
002F48  1  D0 FE 68 49  
002F4C  1  30 DD 66 02  
002F52  1  CA                   dex
002F53  1  10 E0                bpl tand
002F55  1  A2 03                ldx #3
002F57  1  B5 12        tand1:  lda zpAN,x
002F59  1  8D 09 02             sta ex_andi+1   ;set AND # operand
002F5C  1  A9 FF 48 BD          set_ax  absANa,$ff
002F60  1  5A 02 28     
002F63  1  20 08 02             jsr ex_andi     ;execute AND # in RAM
002F66  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
002F6A  1  D0 FE 68 49  
002F6E  1  7D DD 66 02  
002F74  1  CA                   dex
002F75  1  10 E0                bpl tand1
002F77  1               
002F77  1  A2 03                ldx #3      ;zp
002F79  1  B5 12        tand2:  lda zpAN,x
002F7B  1  85 02                sta zpt
002F7D  1  A9 00 48 BD          set_ax  absANa,0
002F81  1  5A 02 28     
002F84  1  25 02                and zpt
002F86  1  08 DD 62 02          tst_ax  absrlo,absflo,0
002F8A  1  D0 FE 68 49  
002F8E  1  30 DD 66 02  
002F94  1  CA                   dex
002F95  1  10 E2                bpl tand2
002F97  1  A2 03                ldx #3
002F99  1  B5 12        tand3:  lda zpAN,x
002F9B  1  85 02                sta zpt
002F9D  1  A9 FF 48 BD          set_ax  absANa,$ff
002FA1  1  5A 02 28     
002FA4  1  25 02                and zpt
002FA6  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
002FAA  1  D0 FE 68 49  
002FAE  1  7D DD 66 02  
002FB4  1  CA                   dex
002FB5  1  10 E2                bpl tand3
002FB7  1               
002FB7  1  A2 03                ldx #3      ;abs
002FB9  1  B5 12        tand4:  lda zpAN,x
002FBB  1  8D 03 02             sta abst
002FBE  1  A9 00 48 BD          set_ax  absANa,0
002FC2  1  5A 02 28     
002FC5  1  2D 03 02             and abst
002FC8  1  08 DD 62 02          tst_ax  absrlo,absflo,0
002FCC  1  D0 FE 68 49  
002FD0  1  30 DD 66 02  
002FD6  1  CA                   dex
002FD7  1  10 E0                bpl tand4
002FD9  1  A2 03                ldx #3
002FDB  1  B5 12        tand5:  lda zpAN,x
002FDD  1  8D 03 02             sta abst
002FE0  1  A9 FF 48 BD          set_ax  absANa,$ff
002FE4  1  5A 02 28     
002FE7  1  2D 03 02             and abst
002FEA  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
002FEE  1  D0 FE 68 49  
002FF2  1  7D DD 66 02  
002FF8  1  CA                   dex
002FF9  1  10 02                bpl tand6
002FFB  1               
002FFB  1  A2 03                ldx #3      ;zp,x
002FFD  1               tand6:
002FFD  1  A9 00 48 BD          set_ax  absANa,0
003001  1  5A 02 28     
003004  1  35 12                and zpAN,x
003006  1  08 DD 62 02          tst_ax  absrlo,absflo,0
00300A  1  D0 FE 68 49  
00300E  1  30 DD 66 02  
003014  1  CA                   dex
003015  1  10 E6                bpl tand6
003017  1  A2 03                ldx #3
003019  1               tand7:
003019  1  A9 FF 48 BD          set_ax  absANa,$ff
00301D  1  5A 02 28     
003020  1  35 12                and zpAN,x
003022  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003026  1  D0 FE 68 49  
00302A  1  7D DD 66 02  
003030  1  CA                   dex
003031  1  10 E6                bpl tand7
003033  1               
003033  1  A2 03                ldx #3      ;abs,x
003035  1               tand8:
003035  1  A9 00 48 BD          set_ax  absANa,0
003039  1  5A 02 28     
00303C  1  3D 4E 02             and absAN,x
00303F  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003043  1  D0 FE 68 49  
003047  1  30 DD 66 02  
00304D  1  CA                   dex
00304E  1  10 E5                bpl tand8
003050  1  A2 03                ldx #3
003052  1               tand9:
003052  1  A9 FF 48 BD          set_ax  absANa,$ff
003056  1  5A 02 28     
003059  1  3D 4E 02             and absAN,x
00305C  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003060  1  D0 FE 68 49  
003064  1  7D DD 66 02  
00306A  1  CA                   dex
00306B  1  10 E5                bpl tand9
00306D  1               
00306D  1  A0 03                ldy #3      ;abs,y
00306F  1               tand10:
00306F  1  A9 00 48 B9          set_ay  absANa,0
003073  1  5A 02 28     
003076  1  39 4E 02             and absAN,y
003079  1  08 D9 62 02          tst_ay  absrlo,absflo,0
00307D  1  D0 FE 68 49  
003081  1  30 D9 66 02  
003087  1  88                   dey
003088  1  10 E5                bpl tand10
00308A  1  A0 03                ldy #3
00308C  1               tand11:
00308C  1  A9 FF 48 B9          set_ay  absANa,$ff
003090  1  5A 02 28     
003093  1  39 4E 02             and absAN,y
003096  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
00309A  1  D0 FE 68 49  
00309E  1  7D D9 66 02  
0030A4  1  88                   dey
0030A5  1  10 E5                bpl tand11
0030A7  1               
0030A7  1  A2 06                ldx #6      ;(zp,x)
0030A9  1  A0 03                ldy #3
0030AB  1               tand12:
0030AB  1  A9 00 48 B9          set_ay  absANa,0
0030AF  1  5A 02 28     
0030B2  1  21 30                and (indAN,x)
0030B4  1  08 D9 62 02          tst_ay  absrlo,absflo,0
0030B8  1  D0 FE 68 49  
0030BC  1  30 D9 66 02  
0030C2  1  CA                   dex
0030C3  1  CA                   dex
0030C4  1  88                   dey
0030C5  1  10 E4                bpl tand12
0030C7  1  A2 06                ldx #6
0030C9  1  A0 03                ldy #3
0030CB  1               tand13:
0030CB  1  A9 FF 48 B9          set_ay  absANa,$ff
0030CF  1  5A 02 28     
0030D2  1  21 30                and (indAN,x)
0030D4  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
0030D8  1  D0 FE 68 49  
0030DC  1  7D D9 66 02  
0030E2  1  CA                   dex
0030E3  1  CA                   dex
0030E4  1  88                   dey
0030E5  1  10 E4                bpl tand13
0030E7  1               
0030E7  1  A0 03                ldy #3      ;(zp),y
0030E9  1               tand14:
0030E9  1  A9 00 48 B9          set_ay  absANa,0
0030ED  1  5A 02 28     
0030F0  1  31 30                and (indAN),y
0030F2  1  08 D9 62 02          tst_ay  absrlo,absflo,0
0030F6  1  D0 FE 68 49  
0030FA  1  30 D9 66 02  
003100  1  88                   dey
003101  1  10 E6                bpl tand14
003103  1  A0 03                ldy #3
003105  1               tand15:
003105  1  A9 FF 48 B9          set_ay  absANa,$ff
003109  1  5A 02 28     
00310C  1  31 30                and (indAN),y
00310E  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003112  1  D0 FE 68 49  
003116  1  7D D9 66 02  
00311C  1  88                   dey
00311D  1  10 E6                bpl tand15
00311F  1  AD 00 02 C9          next_test
003123  1  26 D0 FE A9  
003127  1  27 8D 00 02  
00312B  1               
00312B  1               ; EOR
00312B  1  A2 03                ldx #3          ;immediate - self modifying code
00312D  1  B5 16        teor:   lda zpEO,x
00312F  1  8D 0C 02             sta ex_eori+1   ;set EOR # operand
003132  1  A9 00 48 BD          set_ax  absEOa,0
003136  1  5E 02 28     
003139  1  20 0B 02             jsr ex_eori     ;execute EOR # in RAM
00313C  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003140  1  D0 FE 68 49  
003144  1  30 DD 66 02  
00314A  1  CA                   dex
00314B  1  10 E0                bpl teor
00314D  1  A2 03                ldx #3
00314F  1  B5 16        teor1:  lda zpEO,x
003151  1  8D 0C 02             sta ex_eori+1   ;set EOR # operand
003154  1  A9 FF 48 BD          set_ax  absEOa,$ff
003158  1  5E 02 28     
00315B  1  20 0B 02             jsr ex_eori     ;execute EOR # in RAM
00315E  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003162  1  D0 FE 68 49  
003166  1  7D DD 66 02  
00316C  1  CA                   dex
00316D  1  10 E0                bpl teor1
00316F  1               
00316F  1  A2 03                ldx #3      ;zp
003171  1  B5 16        teor2:   lda zpEO,x
003173  1  85 02                sta zpt
003175  1  A9 00 48 BD          set_ax  absEOa,0
003179  1  5E 02 28     
00317C  1  45 02                eor zpt
00317E  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003182  1  D0 FE 68 49  
003186  1  30 DD 66 02  
00318C  1  CA                   dex
00318D  1  10 E2                bpl teor2
00318F  1  A2 03                ldx #3
003191  1  B5 16        teor3:  lda zpEO,x
003193  1  85 02                sta zpt
003195  1  A9 FF 48 BD          set_ax  absEOa,$ff
003199  1  5E 02 28     
00319C  1  45 02                eor zpt
00319E  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
0031A2  1  D0 FE 68 49  
0031A6  1  7D DD 66 02  
0031AC  1  CA                   dex
0031AD  1  10 E2                bpl teor3
0031AF  1               
0031AF  1  A2 03                ldx #3      ;abs
0031B1  1  B5 16        teor4:  lda zpEO,x
0031B3  1  8D 03 02             sta abst
0031B6  1  A9 00 48 BD          set_ax  absEOa,0
0031BA  1  5E 02 28     
0031BD  1  4D 03 02             eor abst
0031C0  1  08 DD 62 02          tst_ax  absrlo,absflo,0
0031C4  1  D0 FE 68 49  
0031C8  1  30 DD 66 02  
0031CE  1  CA                   dex
0031CF  1  10 E0                bpl teor4
0031D1  1  A2 03                ldx #3
0031D3  1  B5 16        teor5:  lda zpEO,x
0031D5  1  8D 03 02             sta abst
0031D8  1  A9 FF 48 BD          set_ax  absEOa,$ff
0031DC  1  5E 02 28     
0031DF  1  4D 03 02             eor abst
0031E2  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
0031E6  1  D0 FE 68 49  
0031EA  1  7D DD 66 02  
0031F0  1  CA                   dex
0031F1  1  10 02                bpl teor6
0031F3  1               
0031F3  1  A2 03                ldx #3      ;zp,x
0031F5  1               teor6:
0031F5  1  A9 00 48 BD          set_ax  absEOa,0
0031F9  1  5E 02 28     
0031FC  1  55 16                eor zpEO,x
0031FE  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003202  1  D0 FE 68 49  
003206  1  30 DD 66 02  
00320C  1  CA                   dex
00320D  1  10 E6                bpl teor6
00320F  1  A2 03                ldx #3
003211  1               teor7:
003211  1  A9 FF 48 BD          set_ax  absEOa,$ff
003215  1  5E 02 28     
003218  1  55 16                eor zpEO,x
00321A  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
00321E  1  D0 FE 68 49  
003222  1  7D DD 66 02  
003228  1  CA                   dex
003229  1  10 E6                bpl teor7
00322B  1               
00322B  1  A2 03                ldx #3      ;abs,x
00322D  1               teor8:
00322D  1  A9 00 48 BD          set_ax  absEOa,0
003231  1  5E 02 28     
003234  1  5D 52 02             eor absEO,x
003237  1  08 DD 62 02          tst_ax  absrlo,absflo,0
00323B  1  D0 FE 68 49  
00323F  1  30 DD 66 02  
003245  1  CA                   dex
003246  1  10 E5                bpl teor8
003248  1  A2 03                ldx #3
00324A  1               teor9:
00324A  1  A9 FF 48 BD          set_ax  absEOa,$ff
00324E  1  5E 02 28     
003251  1  5D 52 02             eor absEO,x
003254  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003258  1  D0 FE 68 49  
00325C  1  7D DD 66 02  
003262  1  CA                   dex
003263  1  10 E5                bpl teor9
003265  1               
003265  1  A0 03                ldy #3      ;abs,y
003267  1               teor10:
003267  1  A9 00 48 B9          set_ay  absEOa,0
00326B  1  5E 02 28     
00326E  1  59 52 02             eor absEO,y
003271  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003275  1  D0 FE 68 49  
003279  1  30 D9 66 02  
00327F  1  88                   dey
003280  1  10 E5                bpl teor10
003282  1  A0 03                ldy #3
003284  1               teor11:
003284  1  A9 FF 48 B9          set_ay  absEOa,$ff
003288  1  5E 02 28     
00328B  1  59 52 02             eor absEO,y
00328E  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003292  1  D0 FE 68 49  
003296  1  7D D9 66 02  
00329C  1  88                   dey
00329D  1  10 E5                bpl teor11
00329F  1               
00329F  1  A2 06                ldx #6      ;(zp,x)
0032A1  1  A0 03                ldy #3
0032A3  1               teor12:
0032A3  1  A9 00 48 B9          set_ay  absEOa,0
0032A7  1  5E 02 28     
0032AA  1  41 38                eor (indEO,x)
0032AC  1  08 D9 62 02          tst_ay  absrlo,absflo,0
0032B0  1  D0 FE 68 49  
0032B4  1  30 D9 66 02  
0032BA  1  CA                   dex
0032BB  1  CA                   dex
0032BC  1  88                   dey
0032BD  1  10 E4                bpl teor12
0032BF  1  A2 06                ldx #6
0032C1  1  A0 03                ldy #3
0032C3  1               teor13:
0032C3  1  A9 FF 48 B9          set_ay  absEOa,$ff
0032C7  1  5E 02 28     
0032CA  1  41 38                eor (indEO,x)
0032CC  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
0032D0  1  D0 FE 68 49  
0032D4  1  7D D9 66 02  
0032DA  1  CA                   dex
0032DB  1  CA                   dex
0032DC  1  88                   dey
0032DD  1  10 E4                bpl teor13
0032DF  1               
0032DF  1  A0 03                ldy #3      ;(zp),y
0032E1  1               teor14:
0032E1  1  A9 00 48 B9          set_ay  absEOa,0
0032E5  1  5E 02 28     
0032E8  1  51 38                eor (indEO),y
0032EA  1  08 D9 62 02          tst_ay  absrlo,absflo,0
0032EE  1  D0 FE 68 49  
0032F2  1  30 D9 66 02  
0032F8  1  88                   dey
0032F9  1  10 E6                bpl teor14
0032FB  1  A0 03                ldy #3
0032FD  1               teor15:
0032FD  1  A9 FF 48 B9          set_ay  absEOa,$ff
003301  1  5E 02 28     
003304  1  51 38                eor (indEO),y
003306  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
00330A  1  D0 FE 68 49  
00330E  1  7D D9 66 02  
003314  1  88                   dey
003315  1  10 E6                bpl teor15
003317  1  AD 00 02 C9          next_test
00331B  1  27 D0 FE A9  
00331F  1  28 8D 00 02  
003323  1               
003323  1               ; OR
003323  1  A2 03                ldx #3          ;immediate - self modifying code
003325  1  B5 0E        tora:   lda zpOR,x
003327  1  8D 0F 02             sta ex_orai+1   ;set ORA # operand
00332A  1  A9 00 48 BD          set_ax  absORa,0
00332E  1  56 02 28     
003331  1  20 0E 02             jsr ex_orai     ;execute ORA # in RAM
003334  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003338  1  D0 FE 68 49  
00333C  1  30 DD 66 02  
003342  1  CA                   dex
003343  1  10 E0                bpl tora
003345  1  A2 03                ldx #3
003347  1  B5 0E        tora1:  lda zpOR,x
003349  1  8D 0F 02             sta ex_orai+1   ;set ORA # operand
00334C  1  A9 FF 48 BD          set_ax  absORa,$ff
003350  1  56 02 28     
003353  1  20 0E 02             jsr ex_orai     ;execute ORA # in RAM
003356  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
00335A  1  D0 FE 68 49  
00335E  1  7D DD 66 02  
003364  1  CA                   dex
003365  1  10 E0                bpl tora1
003367  1               
003367  1  A2 03                ldx #3      ;zp
003369  1  B5 0E        tora2:  lda zpOR,x
00336B  1  85 02                sta zpt
00336D  1  A9 00 48 BD          set_ax  absORa,0
003371  1  56 02 28     
003374  1  05 02                ora zpt
003376  1  08 DD 62 02          tst_ax  absrlo,absflo,0
00337A  1  D0 FE 68 49  
00337E  1  30 DD 66 02  
003384  1  CA                   dex
003385  1  10 E2                bpl tora2
003387  1  A2 03                ldx #3
003389  1  B5 0E        tora3:  lda zpOR,x
00338B  1  85 02                sta zpt
00338D  1  A9 FF 48 BD          set_ax  absORa,$ff
003391  1  56 02 28     
003394  1  05 02                ora zpt
003396  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
00339A  1  D0 FE 68 49  
00339E  1  7D DD 66 02  
0033A4  1  CA                   dex
0033A5  1  10 E2                bpl tora3
0033A7  1               
0033A7  1  A2 03                ldx #3      ;abs
0033A9  1  B5 0E        tora4:  lda zpOR,x
0033AB  1  8D 03 02             sta abst
0033AE  1  A9 00 48 BD          set_ax  absORa,0
0033B2  1  56 02 28     
0033B5  1  0D 03 02             ora abst
0033B8  1  08 DD 62 02          tst_ax  absrlo,absflo,0
0033BC  1  D0 FE 68 49  
0033C0  1  30 DD 66 02  
0033C6  1  CA                   dex
0033C7  1  10 E0                bpl tora4
0033C9  1  A2 03                ldx #3
0033CB  1  B5 0E        tora5:  lda zpOR,x
0033CD  1  8D 03 02             sta abst
0033D0  1  A9 FF 48 BD          set_ax  absORa,$ff
0033D4  1  56 02 28     
0033D7  1  0D 03 02             ora abst
0033DA  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
0033DE  1  D0 FE 68 49  
0033E2  1  7D DD 66 02  
0033E8  1  CA                   dex
0033E9  1  10 02                bpl tora6
0033EB  1               
0033EB  1  A2 03                ldx #3      ;zp,x
0033ED  1               tora6:
0033ED  1  A9 00 48 BD          set_ax  absORa,0
0033F1  1  56 02 28     
0033F4  1  15 0E                ora zpOR,x
0033F6  1  08 DD 62 02          tst_ax  absrlo,absflo,0
0033FA  1  D0 FE 68 49  
0033FE  1  30 DD 66 02  
003404  1  CA                   dex
003405  1  10 E6                bpl tora6
003407  1  A2 03                ldx #3
003409  1               tora7:
003409  1  A9 FF 48 BD          set_ax  absORa,$ff
00340D  1  56 02 28     
003410  1  15 0E                ora zpOR,x
003412  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003416  1  D0 FE 68 49  
00341A  1  7D DD 66 02  
003420  1  CA                   dex
003421  1  10 E6                bpl tora7
003423  1               
003423  1  A2 03                ldx #3      ;abs,x
003425  1               tora8:
003425  1  A9 00 48 BD          set_ax  absORa,0
003429  1  56 02 28     
00342C  1  1D 4A 02             ora absOR,x
00342F  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003433  1  D0 FE 68 49  
003437  1  30 DD 66 02  
00343D  1  CA                   dex
00343E  1  10 E5                bpl tora8
003440  1  A2 03                ldx #3
003442  1               tora9:
003442  1  A9 FF 48 BD          set_ax  absORa,$ff
003446  1  56 02 28     
003449  1  1D 4A 02             ora absOR,x
00344C  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003450  1  D0 FE 68 49  
003454  1  7D DD 66 02  
00345A  1  CA                   dex
00345B  1  10 E5                bpl tora9
00345D  1               
00345D  1  A0 03                ldy #3      ;abs,y
00345F  1               tora10:
00345F  1  A9 00 48 B9          set_ay  absORa,0
003463  1  56 02 28     
003466  1  19 4A 02             ora absOR,y
003469  1  08 D9 62 02          tst_ay  absrlo,absflo,0
00346D  1  D0 FE 68 49  
003471  1  30 D9 66 02  
003477  1  88                   dey
003478  1  10 E5                bpl tora10
00347A  1  A0 03                ldy #3
00347C  1               tora11:
00347C  1  A9 FF 48 B9          set_ay  absORa,$ff
003480  1  56 02 28     
003483  1  19 4A 02             ora absOR,y
003486  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
00348A  1  D0 FE 68 49  
00348E  1  7D D9 66 02  
003494  1  88                   dey
003495  1  10 E5                bpl tora11
003497  1               
003497  1  A2 06                ldx #6      ;(zp,x)
003499  1  A0 03                ldy #3
00349B  1               tora12:
00349B  1  A9 00 48 B9          set_ay  absORa,0
00349F  1  56 02 28     
0034A2  1  01 40                ora (indOR,x)
0034A4  1  08 D9 62 02          tst_ay  absrlo,absflo,0
0034A8  1  D0 FE 68 49  
0034AC  1  30 D9 66 02  
0034B2  1  CA                   dex
0034B3  1  CA                   dex
0034B4  1  88                   dey
0034B5  1  10 E4                bpl tora12
0034B7  1  A2 06                ldx #6
0034B9  1  A0 03                ldy #3
0034BB  1               tora13:
0034BB  1  A9 FF 48 B9          set_ay  absORa,$ff
0034BF  1  56 02 28     
0034C2  1  01 40                ora (indOR,x)
0034C4  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
0034C8  1  D0 FE 68 49  
0034CC  1  7D D9 66 02  
0034D2  1  CA                   dex
0034D3  1  CA                   dex
0034D4  1  88                   dey
0034D5  1  10 E4                bpl tora13
0034D7  1               
0034D7  1  A0 03                ldy #3      ;(zp),y
0034D9  1               tora14:
0034D9  1  A9 00 48 B9          set_ay  absORa,0
0034DD  1  56 02 28     
0034E0  1  11 40                ora (indOR),y
0034E2  1  08 D9 62 02          tst_ay  absrlo,absflo,0
0034E6  1  D0 FE 68 49  
0034EA  1  30 D9 66 02  
0034F0  1  88                   dey
0034F1  1  10 E6                bpl tora14
0034F3  1  A0 03                ldy #3
0034F5  1               tora15:
0034F5  1  A9 FF 48 B9          set_ay  absORa,$ff
0034F9  1  56 02 28     
0034FC  1  11 40                ora (indOR),y
0034FE  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003502  1  D0 FE 68 49  
003506  1  7D D9 66 02  
00350C  1  88                   dey
00350D  1  10 E6                bpl tora15
00350F  1                   .if I_flag = 3
00350F  1  58                   cli
003510  1                   .endif
003510  1  AD 00 02 C9          next_test
003514  1  28 D0 FE A9  
003518  1  29 8D 00 02  
00351C  1               
00351C  1               ; full binary add/subtract test
00351C  1               ; iterates through all combinations of operands and carry input
00351C  1               ; uses increments/decrements to predict result & result flags
00351C  1  D8                   cld
00351D  1  A2 04                ldx #ad2        ;for indexed test
00351F  1  A0 FF                ldy #$ff        ;max range
003521  1  A9 00                lda #0          ;start with adding zeroes & no carry
003523  1  85 02                sta adfc        ;carry in - for diag
003525  1  85 03                sta ad1         ;operand 1 - accumulator
003527  1  85 04                sta ad2         ;operand 2 - memory or immediate
003529  1  8D 03 02             sta ada2        ;non zp
00352C  1  85 05                sta adrl        ;expected result bits 0-7
00352E  1  85 06                sta adrh        ;expected result bit 8 (carry out)
003530  1  A9 FF                lda #$ff        ;complemented operand 2 for subtract
003532  1  85 08                sta sb2
003534  1  8D 04 02             sta sba2        ;non zp
003537  1  A9 02                lda #2          ;expected Z-flag
003539  1  85 07                sta adrf
00353B  1  18           tadd:   clc             ;test with carry clear
00353C  1  20 87 35             jsr chkadd
00353F  1  E6 02                inc adfc        ;now with carry
003541  1  E6 05                inc adrl        ;result +1
003543  1  08                   php             ;save N & Z from low result
003544  1  08                   php
003545  1  68                   pla             ;accu holds expected flags
003546  1  29 82                and #$82        ;mask N & Z
003548  1  28                   plp
003549  1  D0 02                bne tadd1
00354B  1  E6 06                inc adrh        ;result bit 8 - carry
00354D  1  05 06        tadd1:  ora adrh        ;merge C to expected flags
00354F  1  85 07                sta adrf        ;save expected flags except overflow
003551  1  38                   sec             ;test with carry set
003552  1  20 87 35             jsr chkadd
003555  1  C6 02                dec adfc        ;same for operand +1 but no carry
003557  1  E6 03                inc ad1
003559  1  D0 E0                bne tadd        ;iterate op1
00355B  1  A9 00                lda #0          ;preset result to op2 when op1 = 0
00355D  1  85 06                sta adrh
00355F  1  EE 03 02             inc ada2
003562  1  E6 04                inc ad2
003564  1  08                   php             ;save NZ as operand 2 becomes the new result
003565  1  68                   pla
003566  1  29 82                and #$82        ;mask N00000Z0
003568  1  85 07                sta adrf        ;no need to check carry as we are adding to 0
00356A  1  C6 08                dec sb2         ;complement subtract operand 2
00356C  1  CE 04 02             dec sba2
00356F  1  A5 04                lda ad2
003571  1  85 05                sta adrl
003573  1  D0 C6                bne tadd        ;iterate op2
003575  1                   .if disable_decimal < 1
003575  1                       next_test
003575  1               
003575  1               ; decimal add/subtract test
003575  1               ; *** WARNING - tests documented behavior only! ***
003575  1               ;   only valid BCD operands are tested, N V Z flags are ignored
003575  1               ; iterates through all valid combinations of operands and carry input
003575  1               ; uses increments/decrements to predict result & carry flag
003575  1                       sed
003575  1                       ldx #ad2        ;for indexed test
003575  1                       ldy #$ff        ;max range
003575  1                       lda #$99        ;start with adding 99 to 99 with carry
003575  1                       sta ad1         ;operand 1 - accumulator
003575  1                       sta ad2         ;operand 2 - memory or immediate
003575  1                       sta ada2        ;non zp
003575  1                       sta adrl        ;expected result bits 0-7
003575  1                       lda #1          ;set carry in & out
003575  1                       sta adfc        ;carry in - for diag
003575  1                       sta adrh        ;expected result bit 8 (carry out)
003575  1                       lda #0          ;complemented operand 2 for subtract
003575  1                       sta sb2
003575  1                       sta sba2        ;non zp
003575  1               tdad:   sec             ;test with carry set
003575  1                       jsr chkdad
003575  1                       dec adfc        ;now with carry clear
003575  1                       lda adrl        ;decimal adjust result
003575  1                       bne tdad1       ;skip clear carry & preset result 99 (9A-1)
003575  1                       dec adrh
003575  1                       lda #$99
003575  1                       sta adrl
003575  1                       bne tdad3
003575  1               tdad1:  and #$f         ;lower nibble mask
003575  1                       bne tdad2       ;no decimal adjust needed
003575  1                       dec adrl        ;decimal adjust (?0-6)
003575  1                       dec adrl
003575  1                       dec adrl
003575  1                       dec adrl
003575  1                       dec adrl
003575  1                       dec adrl
003575  1               tdad2:  dec adrl        ;result -1
003575  1               tdad3:  clc             ;test with carry clear
003575  1                       jsr chkdad
003575  1                       inc adfc        ;same for operand -1 but with carry
003575  1                       lda ad1         ;decimal adjust operand 1
003575  1                       beq tdad5       ;iterate operand 2
003575  1                       and #$f         ;lower nibble mask
003575  1                       bne tdad4       ;skip decimal adjust
003575  1                       dec ad1         ;decimal adjust (?0-6)
003575  1                       dec ad1
003575  1                       dec ad1
003575  1                       dec ad1
003575  1                       dec ad1
003575  1                       dec ad1
003575  1               tdad4:  dec ad1         ;operand 1 -1
003575  1                       jmp tdad        ;iterate op1
003575  1               
003575  1               tdad5:  lda #$99        ;precharge op1 max
003575  1                       sta ad1
003575  1                       lda ad2         ;decimal adjust operand 2
003575  1                       beq tdad7       ;end of iteration
003575  1                       and #$f         ;lower nibble mask
003575  1                       bne tdad6       ;skip decimal adjust
003575  1                       dec ad2         ;decimal adjust (?0-6)
003575  1                       dec ad2
003575  1                       dec ad2
003575  1                       dec ad2
003575  1                       dec ad2
003575  1                       dec ad2
003575  1                       inc sb2         ;complemented decimal adjust for subtract (?9+6)
003575  1                       inc sb2
003575  1                       inc sb2
003575  1                       inc sb2
003575  1                       inc sb2
003575  1                       inc sb2
003575  1               tdad6:  dec ad2         ;operand 2 -1
003575  1                       inc sb2         ;complemented operand for subtract
003575  1                       lda sb2
003575  1                       sta sba2        ;copy as non zp operand
003575  1                       lda ad2
003575  1                       sta ada2        ;copy as non zp operand
003575  1                       sta adrl        ;new result since op1+carry=00+carry +op2=op2
003575  1                       inc adrh        ;result carry
003575  1                       bne tdad        ;iterate op2
003575  1               tdad7:
003575  1                       next_test
003575  1               
003575  1               ; decimal/binary switch test
003575  1               ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
003575  1               ;   tables
003575  1                       clc
003575  1                       cld
003575  1                       php
003575  1                       lda #$55
003575  1                       adc #$55
003575  1                       cmp #$aa
003575  1                       trap_ne         ;expected binary result after cld
003575  1                       clc
003575  1                       sed
003575  1                       php
003575  1                       lda #$55
003575  1                       adc #$55
003575  1                       cmp #$10
003575  1                       trap_ne         ;expected decimal result after sed
003575  1                       cld
003575  1                       plp
003575  1                       lda #$55
003575  1                       adc #$55
003575  1                       cmp #$10
003575  1                       trap_ne         ;expected decimal result after plp D=1
003575  1                       plp
003575  1                       lda #$55
003575  1                       adc #$55
003575  1                       cmp #$aa
003575  1                       trap_ne         ;expected binary result after plp D=0
003575  1                       clc
003575  1                       lda #>bin_rti_ret ;emulated interrupt for rti
003575  1                       pha
003575  1                       lda #<bin_rti_ret
003575  1                       pha
003575  1                       php
003575  1                       sed
003575  1                       lda #>dec_rti_ret ;emulated interrupt for rti
003575  1                       pha
003575  1                       lda #<dec_rti_ret
003575  1                       pha
003575  1                       php
003575  1                       cld
003575  1                       rti
003575  1               dec_rti_ret:
003575  1                       lda #$55
003575  1                       adc #$55
003575  1                       cmp #$10
003575  1                       trap_ne         ;expected decimal result after rti D=1
003575  1                       rti
003575  1               bin_rti_ret:
003575  1                       lda #$55
003575  1                       adc #$55
003575  1                       cmp #$aa
003575  1                       trap_ne         ;expected binary result after rti D=0
003575  1                   .endif
003575  1               
003575  1  AD 00 02             lda test_case
003578  1  C9 29                cmp #test_num
00357A  1  D0 FE                trap_ne         ;previous test is out of sequence
00357C  1  A9 F0                lda #$f0        ;mark opcode testing complete
00357E  1  8D 00 02             sta test_case
003581  1               
003581  1               ; final RAM integrity test
003581  1               ;   verifies that none of the previous tests has altered RAM outside of the
003581  1               ;   designated write areas.
003581  1                       check_ram
003581  1               ; *** DEBUG INFO ***
003581  1               ; to debug checksum errors uncomment check_ram in the next_test macro to
003581  1               ; narrow down the responsible opcode.
003581  1               ; may give false errors when monitor, OS or other background activity is
003581  1               ; allowed during previous tests.
003581  1               
003581  1               
003581  1               ; S U C C E S S ************************************************
003581  1               ; -------------
003581  1  4C 81 35             success         ;if you get here everything went well
003584  1               ; -------------
003584  1               ; S U C C E S S ************************************************
003584  1  4C 00 06             jmp start       ;run again
003587  1               
003587  1                   .if disable_decimal < 1
003587  1               ; core subroutine of the decimal add/subtract test
003587  1               ; *** WARNING - tests documented behavior only! ***
003587  1               ;   only valid BCD operands are tested, N V Z flags are ignored
003587  1               ; iterates through all valid combinations of operands and carry input
003587  1               ; uses increments/decrements to predict result & carry flag
003587  1               chkdad:
003587  1               ; decimal ADC / SBC zp
003587  1                       php             ;save carry for subtract
003587  1                       lda ad1
003587  1                       adc ad2         ;perform add
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1                       php             ;save carry for next add
003587  1                       lda ad1
003587  1                       sbc sb2         ;perform subtract
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad flags
003587  1                       plp
003587  1               ; decimal ADC / SBC abs
003587  1                       php             ;save carry for subtract
003587  1                       lda ad1
003587  1                       adc ada2        ;perform add
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1                       php             ;save carry for next add
003587  1                       lda ad1
003587  1                       sbc sba2        ;perform subtract
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1               ; decimal ADC / SBC #
003587  1                       php             ;save carry for subtract
003587  1                       lda ad2
003587  1                       sta ex_adci+1   ;set ADC # operand
003587  1                       lda ad1
003587  1                       jsr ex_adci     ;execute ADC # in RAM
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1                       php             ;save carry for next add
003587  1                       lda sb2
003587  1                       sta ex_sbci+1   ;set SBC # operand
003587  1                       lda ad1
003587  1                       jsr ex_sbci     ;execute SBC # in RAM
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1               ; decimal ADC / SBC zp,x
003587  1                       php             ;save carry for subtract
003587  1                       lda ad1
003587  1                       adc 0,x         ;perform add
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1                       php             ;save carry for next add
003587  1                       lda ad1
003587  1                       sbc sb2-ad2,x   ;perform subtract
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1               ; decimal ADC / SBC abs,x
003587  1                       php             ;save carry for subtract
003587  1                       lda ad1
003587  1                       adc ada2-ad2,x  ;perform add
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1                       php             ;save carry for next add
003587  1                       lda ad1
003587  1                       sbc sba2-ad2,x  ;perform subtract
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1               ; decimal ADC / SBC abs,y
003587  1                       php             ;save carry for subtract
003587  1                       lda ad1
003587  1                       adc ada2-$ff,y  ;perform add
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1                       php             ;save carry for next add
003587  1                       lda ad1
003587  1                       sbc sba2-$ff,y  ;perform subtract
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1               ; decimal ADC / SBC (zp,x)
003587  1                       php             ;save carry for subtract
003587  1                       lda ad1
003587  1                       adc (<adi2-ad2,x) ;perform add
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1                       php             ;save carry for next add
003587  1                       lda ad1
003587  1                       sbc (<sbi2-ad2,x) ;perform subtract
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1               ; decimal ADC / SBC (abs),y
003587  1                       php             ;save carry for subtract
003587  1                       lda ad1
003587  1                       adc (adiy2),y   ;perform add
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1                       php             ;save carry for next add
003587  1                       lda ad1
003587  1                       sbc (sbiy2),y   ;perform subtract
003587  1                       php
003587  1                       cmp adrl        ;check result
003587  1                       trap_ne         ;bad result
003587  1                       pla             ;check flags
003587  1                       and #1          ;mask carry
003587  1                       cmp adrh
003587  1                       trap_ne         ;bad carry
003587  1                       plp
003587  1                       rts
003587  1                   .endif
003587  1               
003587  1               ; core subroutine of the full binary add/subtract test
003587  1               ; iterates through all combinations of operands and carry input
003587  1               ; uses increments/decrements to predict result & result flags
003587  1  A5 07        chkadd: lda adrf        ;add V-flag if overflow
003589  1  29 83                and #$83        ;keep N-----ZC / clear V
00358B  1  48                   pha
00358C  1  A5 03                lda ad1         ;test sign unequal between operands
00358E  1  45 04                eor ad2
003590  1  30 0A                bmi ckad1       ;no overflow possible - operands have different sign
003592  1  A5 03                lda ad1         ;test sign equal between operands and result
003594  1  45 05                eor adrl
003596  1  10 04                bpl ckad1       ;no overflow occured - operand and result have same sign
003598  1  68                   pla
003599  1  09 40                ora #$40        ;set V
00359B  1  48                   pha
00359C  1  68           ckad1:  pla
00359D  1  85 07                sta adrf        ;save expected flags
00359F  1               ; binary ADC / SBC zp
00359F  1  08                   php             ;save carry for subtract
0035A0  1  A5 03                lda ad1
0035A2  1  65 04                adc ad2         ;perform add
0035A4  1  08                   php
0035A5  1  C5 05                cmp adrl        ;check result
0035A7  1  D0 FE                trap_ne         ;bad result
0035A9  1  68                   pla             ;check flags
0035AA  1  29 C3                and #$c3        ;mask NV----ZC
0035AC  1  C5 07                cmp adrf
0035AE  1  D0 FE                trap_ne         ;bad flags
0035B0  1  28                   plp
0035B1  1  08                   php             ;save carry for next add
0035B2  1  A5 03                lda ad1
0035B4  1  E5 08                sbc sb2         ;perform subtract
0035B6  1  08                   php
0035B7  1  C5 05                cmp adrl        ;check result
0035B9  1  D0 FE                trap_ne         ;bad result
0035BB  1  68                   pla             ;check flags
0035BC  1  29 C3                and #$c3        ;mask NV----ZC
0035BE  1  C5 07                cmp adrf
0035C0  1  D0 FE                trap_ne         ;bad flags
0035C2  1  28                   plp
0035C3  1               ; binary ADC / SBC abs
0035C3  1  08                   php             ;save carry for subtract
0035C4  1  A5 03                lda ad1
0035C6  1  6D 03 02             adc ada2        ;perform add
0035C9  1  08                   php
0035CA  1  C5 05                cmp adrl        ;check result
0035CC  1  D0 FE                trap_ne         ;bad result
0035CE  1  68                   pla             ;check flags
0035CF  1  29 C3                and #$c3        ;mask NV----ZC
0035D1  1  C5 07                cmp adrf
0035D3  1  D0 FE                trap_ne         ;bad flags
0035D5  1  28                   plp
0035D6  1  08                   php             ;save carry for next add
0035D7  1  A5 03                lda ad1
0035D9  1  ED 04 02             sbc sba2        ;perform subtract
0035DC  1  08                   php
0035DD  1  C5 05                cmp adrl        ;check result
0035DF  1  D0 FE                trap_ne         ;bad result
0035E1  1  68                   pla             ;check flags
0035E2  1  29 C3                and #$c3        ;mask NV----ZC
0035E4  1  C5 07                cmp adrf
0035E6  1  D0 FE                trap_ne         ;bad flags
0035E8  1  28                   plp
0035E9  1               ; binary ADC / SBC #
0035E9  1  08                   php             ;save carry for subtract
0035EA  1  A5 04                lda ad2
0035EC  1  8D 12 02             sta ex_adci+1   ;set ADC # operand
0035EF  1  A5 03                lda ad1
0035F1  1  20 11 02             jsr ex_adci     ;execute ADC # in RAM
0035F4  1  08                   php
0035F5  1  C5 05                cmp adrl        ;check result
0035F7  1  D0 FE                trap_ne         ;bad result
0035F9  1  68                   pla             ;check flags
0035FA  1  29 C3                and #$c3        ;mask NV----ZC
0035FC  1  C5 07                cmp adrf
0035FE  1  D0 FE                trap_ne         ;bad flags
003600  1  28                   plp
003601  1  08                   php             ;save carry for next add
003602  1  A5 08                lda sb2
003604  1  8D 15 02             sta ex_sbci+1   ;set SBC # operand
003607  1  A5 03                lda ad1
003609  1  20 14 02             jsr ex_sbci     ;execute SBC # in RAM
00360C  1  08                   php
00360D  1  C5 05                cmp adrl        ;check result
00360F  1  D0 FE                trap_ne         ;bad result
003611  1  68                   pla             ;check flags
003612  1  29 C3                and #$c3        ;mask NV----ZC
003614  1  C5 07                cmp adrf
003616  1  D0 FE                trap_ne         ;bad flags
003618  1  28                   plp
003619  1               ; binary ADC / SBC zp,x
003619  1  08                   php             ;save carry for subtract
00361A  1  A5 03                lda ad1
00361C  1  75 00                adc 0,x         ;perform add
00361E  1  08                   php
00361F  1  C5 05                cmp adrl        ;check result
003621  1  D0 FE                trap_ne         ;bad result
003623  1  68                   pla             ;check flags
003624  1  29 C3                and #$c3        ;mask NV----ZC
003626  1  C5 07                cmp adrf
003628  1  D0 FE                trap_ne         ;bad flags
00362A  1  28                   plp
00362B  1  08                   php             ;save carry for next add
00362C  1  A5 03                lda ad1
00362E  1  F5 04                sbc sb2-ad2,x   ;perform subtract
003630  1  08                   php
003631  1  C5 05                cmp adrl        ;check result
003633  1  D0 FE                trap_ne         ;bad result
003635  1  68                   pla             ;check flags
003636  1  29 C3                and #$c3        ;mask NV----ZC
003638  1  C5 07                cmp adrf
00363A  1  D0 FE                trap_ne         ;bad flags
00363C  1  28                   plp
00363D  1               ; binary ADC / SBC abs,x
00363D  1  08                   php             ;save carry for subtract
00363E  1  A5 03                lda ad1
003640  1  7D FF 01             adc ada2-ad2,x  ;perform add
003643  1  08                   php
003644  1  C5 05                cmp adrl        ;check result
003646  1  D0 FE                trap_ne         ;bad result
003648  1  68                   pla             ;check flags
003649  1  29 C3                and #$c3        ;mask NV----ZC
00364B  1  C5 07                cmp adrf
00364D  1  D0 FE                trap_ne         ;bad flags
00364F  1  28                   plp
003650  1  08                   php             ;save carry for next add
003651  1  A5 03                lda ad1
003653  1  FD 00 02             sbc sba2-ad2,x  ;perform subtract
003656  1  08                   php
003657  1  C5 05                cmp adrl        ;check result
003659  1  D0 FE                trap_ne         ;bad result
00365B  1  68                   pla             ;check flags
00365C  1  29 C3                and #$c3        ;mask NV----ZC
00365E  1  C5 07                cmp adrf
003660  1  D0 FE                trap_ne         ;bad flags
003662  1  28                   plp
003663  1               ; binary ADC / SBC abs,y
003663  1  08                   php             ;save carry for subtract
003664  1  A5 03                lda ad1
003666  1  79 04 01             adc ada2-$ff,y  ;perform add
003669  1  08                   php
00366A  1  C5 05                cmp adrl        ;check result
00366C  1  D0 FE                trap_ne         ;bad result
00366E  1  68                   pla             ;check flags
00366F  1  29 C3                and #$c3        ;mask NV----ZC
003671  1  C5 07                cmp adrf
003673  1  D0 FE                trap_ne         ;bad flags
003675  1  28                   plp
003676  1  08                   php             ;save carry for next add
003677  1  A5 03                lda ad1
003679  1  F9 05 01             sbc sba2-$ff,y  ;perform subtract
00367C  1  08                   php
00367D  1  C5 05                cmp adrl        ;check result
00367F  1  D0 FE                trap_ne         ;bad result
003681  1  68                   pla             ;check flags
003682  1  29 C3                and #$c3        ;mask NV----ZC
003684  1  C5 07                cmp adrf
003686  1  D0 FE                trap_ne         ;bad flags
003688  1  28                   plp
003689  1               ; binary ADC / SBC (zp,x)
003689  1  08                   php             ;save carry for subtract
00368A  1  A5 03                lda ad1
00368C  1  61 44                adc (<adi2-ad2,x) ;perform add
00368E  1  08                   php
00368F  1  C5 05                cmp adrl        ;check result
003691  1  D0 FE                trap_ne         ;bad result
003693  1  68                   pla             ;check flags
003694  1  29 C3                and #$c3        ;mask NV----ZC
003696  1  C5 07                cmp adrf
003698  1  D0 FE                trap_ne         ;bad flags
00369A  1  28                   plp
00369B  1  08                   php             ;save carry for next add
00369C  1  A5 03                lda ad1
00369E  1  E1 46                sbc (<sbi2-ad2,x) ;perform subtract
0036A0  1  08                   php
0036A1  1  C5 05                cmp adrl        ;check result
0036A3  1  D0 FE                trap_ne         ;bad result
0036A5  1  68                   pla             ;check flags
0036A6  1  29 C3                and #$c3        ;mask NV----ZC
0036A8  1  C5 07                cmp adrf
0036AA  1  D0 FE                trap_ne         ;bad flags
0036AC  1  28                   plp
0036AD  1               ; binary ADC / SBC (abs),y
0036AD  1  08                   php             ;save carry for subtract
0036AE  1  A5 03                lda ad1
0036B0  1  71 4C                adc (adiy2),y   ;perform add
0036B2  1  08                   php
0036B3  1  C5 05                cmp adrl        ;check result
0036B5  1  D0 FE                trap_ne         ;bad result
0036B7  1  68                   pla             ;check flags
0036B8  1  29 C3                and #$c3        ;mask NV----ZC
0036BA  1  C5 07                cmp adrf
0036BC  1  D0 FE                trap_ne         ;bad flags
0036BE  1  28                   plp
0036BF  1  08                   php             ;save carry for next add
0036C0  1  A5 03                lda ad1
0036C2  1  F1 4E                sbc (sbiy2),y   ;perform subtract
0036C4  1  08                   php
0036C5  1  C5 05                cmp adrl        ;check result
0036C7  1  D0 FE                trap_ne         ;bad result
0036C9  1  68                   pla             ;check flags
0036CA  1  29 C3                and #$c3        ;mask NV----ZC
0036CC  1  C5 07                cmp adrf
0036CE  1  D0 FE                trap_ne         ;bad flags
0036D0  1  28                   plp
0036D1  1  60                   rts
0036D2  1               
0036D2  1               ; target for the jump absolute test
0036D2  1  88                   dey
0036D3  1  88                   dey
0036D4  1               test_far:
0036D4  1  08                   php             ;either SP or Y count will fail, if we do not hit
0036D5  1  88                   dey
0036D6  1  88                   dey
0036D7  1  88                   dey
0036D8  1  28                   plp
0036D9  1  B0 FE                trap_cs         ;flags loaded?
0036DB  1  70 FE                trap_vs
0036DD  1  30 FE                trap_mi
0036DF  1  F0 FE                trap_eq
0036E1  1  C9 46                cmp #'F'        ;registers loaded?
0036E3  1  D0 FE                trap_ne
0036E5  1  E0 41                cpx #'A'
0036E7  1  D0 FE                trap_ne
0036E9  1  C0 4F                cpy #('R'-3)
0036EB  1  D0 FE                trap_ne
0036ED  1  48                   pha             ;save a,x
0036EE  1  8A                   txa
0036EF  1  48                   pha
0036F0  1  BA                   tsx
0036F1  1  E0 FD                cpx #$fd        ;check SP
0036F3  1  D0 FE                trap_ne
0036F5  1  68                   pla             ;restore x
0036F6  1  AA                   tax
0036F7  1  A9 FF 48 28          set_stat $ff
0036FB  1  68                   pla             ;restore a
0036FC  1  E8                   inx             ;return registers with modifications
0036FD  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
0036FF  1  4C 0F 0B             jmp far_ret
003702  1               
003702  1               ; target for the jump indirect test
003702  1               ;       .align 2
003702  1                       .if * & 1       ; workaround for problems with .align 2
003702  1                           .byte 0     ;
003702  1                       .endif          ;
003702  1               ptr_tst_ind:
003702  1  0B 37                .word   test_ind
003704  1               ptr_ind_ret:
003704  1  64 0B                .word   ind_ret
003706  1  4C 06 37             trap            ;runover protection
003709  1  88                   dey
00370A  1  88                   dey
00370B  1               test_ind:
00370B  1  08                   php             ;either SP or Y count will fail, if we do not hit
00370C  1  88                   dey
00370D  1  88                   dey
00370E  1  88                   dey
00370F  1  28                   plp
003710  1  B0 FE                trap_cs         ;flags loaded?
003712  1  70 FE                trap_vs
003714  1  30 FE                trap_mi
003716  1  F0 FE                trap_eq
003718  1  C9 49                cmp #'I'        ;registers loaded?
00371A  1  D0 FE                trap_ne
00371C  1  E0 4E                cpx #'N'
00371E  1  D0 FE                trap_ne
003720  1  C0 41                cpy #('D'-3)
003722  1  D0 FE                trap_ne
003724  1  48                   pha             ;save a,x
003725  1  8A                   txa
003726  1  48                   pha
003727  1  BA                   tsx
003728  1  E0 FD                cpx #$fd        ;check SP
00372A  1  D0 FE                trap_ne
00372C  1  68                   pla             ;restore x
00372D  1  AA                   tax
00372E  1  A9 FF 48 28          set_stat $ff
003732  1  68                   pla             ;restore a
003733  1  E8                   inx             ;return registers with modifications
003734  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
003736  1  6C 04 37             jmp (ptr_ind_ret)
003739  1  4C 39 37             trap            ;runover protection
00373C  1  4C 00 06             jmp start       ;catastrophic error - cannot continue
00373F  1               
00373F  1               ; target for the jump subroutine test
00373F  1  88                   dey
003740  1  88                   dey
003741  1               test_jsr:
003741  1  08                   php             ;either SP or Y count will fail, if we do not hit
003742  1  88                   dey
003743  1  88                   dey
003744  1  88                   dey
003745  1  28                   plp
003746  1  B0 FE                trap_cs         ;flags loaded?
003748  1  70 FE                trap_vs
00374A  1  30 FE                trap_mi
00374C  1  F0 FE                trap_eq
00374E  1  C9 4A                cmp #'J'        ;registers loaded?
003750  1  D0 FE                trap_ne
003752  1  E0 53                cpx #'S'
003754  1  D0 FE                trap_ne
003756  1  C0 4F                cpy #('R'-3)
003758  1  D0 FE                trap_ne
00375A  1  48                   pha             ;save a,x
00375B  1  8A                   txa
00375C  1  48                   pha
00375D  1  BA                   tsx             ;sp -4? (return addr,a,x)
00375E  1  E0 FB                cpx #$fb
003760  1  D0 FE                trap_ne
003762  1  AD FF 01             lda $1ff        ;propper return on stack
003765  1  C9 0B                cmp #>jsr_ret
003767  1  D0 FE                trap_ne
003769  1  AD FE 01             lda $1fe
00376C  1  C9 9A                cmp #<jsr_ret
00376E  1  D0 FE                trap_ne
003770  1  A9 FF 48 28          set_stat $ff
003774  1  68                   pla             ;pull x,a
003775  1  AA                   tax
003776  1  68                   pla
003777  1  E8                   inx             ;return registers with modifications
003778  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
00377A  1  60                   rts
00377B  1  4C 7B 37             trap            ;runover protection
00377E  1  4C 00 06             jmp start       ;catastrophic error - cannot continue
003781  1               
003781  1               ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
003781  1               nmi_trap:
003781  1  4C 81 37             trap            ;check stack for conditions at NMI
003784  1  4C 00 06             jmp start       ;catastrophic error - cannot continue
003787  1               res_trap:
003787  1  4C 87 37             trap            ;unexpected RESET
00378A  1  4C 00 06             jmp start       ;catastrophic error - cannot continue
00378D  1               
00378D  1  88                   dey
00378E  1  88                   dey
00378F  1               irq_trap:               ;BRK test or unextpected BRK or IRQ
00378F  1  08                   php             ;either SP or Y count will fail, if we do not hit
003790  1  88                   dey
003791  1  88                   dey
003792  1  88                   dey
003793  1                       ;next traps could be caused by unexpected BRK or IRQ
003793  1                       ;check stack for BREAK and originating location
003793  1                       ;possible jump/branch into weeds (uninitialized space)
003793  1  C9 BD                cmp #$ff-'B'    ;BRK pass 2 registers loaded?
003795  1  F0 42                beq break2
003797  1  C9 42                cmp #'B'        ;BRK pass 1 registers loaded?
003799  1  D0 FE                trap_ne
00379B  1  E0 52                cpx #'R'
00379D  1  D0 FE                trap_ne
00379F  1  C0 48                cpy #'K'-3
0037A1  1  D0 FE                trap_ne
0037A3  1  85 00                sta irq_a       ;save registers during break test
0037A5  1  86 01                stx irq_x
0037A7  1  BA                   tsx             ;test break on stack
0037A8  1  BD 02 01             lda $102,x
0037AB  1  C9 30                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
0037AD  1  D0 FE                trap_ne         ; - no break flag on stack
0037AF  1  68                   pla
0037B0  1  C9 34                cmp_flag intdis ;should have added interrupt disable
0037B2  1  D0 FE                trap_ne
0037B4  1  BA                   tsx
0037B5  1  E0 FC                cpx #$fc        ;sp -3? (return addr, flags)
0037B7  1  D0 FE                trap_ne
0037B9  1  AD FF 01             lda $1ff        ;propper return on stack
0037BC  1  C9 0B                cmp #>brk_ret0
0037BE  1  D0 FE                trap_ne
0037C0  1  AD FE 01             lda $1fe
0037C3  1  C9 DC                cmp #<brk_ret0
0037C5  1  D0 FE                trap_ne
0037C7  1  A9 FF                load_flag $ff
0037C9  1  48                   pha
0037CA  1  A6 01                ldx irq_x
0037CC  1  E8                   inx             ;return registers with modifications
0037CD  1  A5 00                lda irq_a
0037CF  1  49 AA                eor #$aa
0037D1  1  28                   plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
0037D2  1  40                   rti
0037D3  1  4C D3 37             trap            ;runover protection
0037D6  1  4C 00 06             jmp start       ;catastrophic error - cannot continue
0037D9  1               
0037D9  1               break2:                 ;BRK pass 2
0037D9  1  E0 AD                cpx #$ff-'R'
0037DB  1  D0 FE                trap_ne
0037DD  1  C0 B1                cpy #$ff-'K'-3
0037DF  1  D0 FE                trap_ne
0037E1  1  85 00                sta irq_a       ;save registers during break test
0037E3  1  86 01                stx irq_x
0037E5  1  BA                   tsx             ;test break on stack
0037E6  1  BD 02 01             lda $102,x
0037E9  1  C9 FF                cmp_flag $ff    ;break test should have B=1
0037EB  1  D0 FE                trap_ne         ; - no break flag on stack
0037ED  1  68                   pla
0037EE  1  09 08                ora #decmode    ;ignore decmode cleared if 65c02
0037F0  1  C9 FF                cmp_flag $ff    ;actual passed flags
0037F2  1  D0 FE                trap_ne
0037F4  1  BA                   tsx
0037F5  1  E0 FC                cpx #$fc        ;sp -3? (return addr, flags)
0037F7  1  D0 FE                trap_ne
0037F9  1  AD FF 01             lda $1ff        ;propper return on stack
0037FC  1  C9 0C                cmp #>brk_ret1
0037FE  1  D0 FE                trap_ne
003800  1  AD FE 01             lda $1fe
003803  1  C9 0B                cmp #<brk_ret1
003805  1  D0 FE                trap_ne
003807  1  A9 04                load_flag intdis
003809  1  48                   pha
00380A  1  A6 01                ldx irq_x
00380C  1  E8                   inx             ;return registers with modifications
00380D  1  A5 00                lda irq_a
00380F  1  49 AA                eor #$aa
003811  1  28                   plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
003812  1  40                   rti
003813  1  4C 13 38             trap            ;runover protection
003816  1  4C 00 06             jmp start       ;catastrophic error - cannot continue
003819  1               
003819  1                   .if report = 1
003819  1                       include "report.i65"
003819  1                   .endif
003819  1               
003819  1               ;copy of data to initialize BSS segment
003819  1                   .if load_data_direct <> 1
003819  1               zp_init:
003819  1               zp1_:   .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
003819  1               zp7f_:  .byte   $7f             ;test pattern for compare
003819  1               ;logical zeropage operands
003819  1               zpOR_:  .byte   0,$1f,$71,$80   ;test pattern for OR
003819  1               zpAN_:  .byte   $0f,$ff,$7f,$80 ;test pattern for AND
003819  1               zpEO_:  .byte   $ff,$0f,$8f,$8f ;test pattern for EOR
003819  1               ;indirect addressing pointers
003819  1               ind1_:  .word   abs1            ;indirect pointer to pattern in absolute memory
003819  1                       .word   abs1+1
003819  1                       .word   abs1+2
003819  1                       .word   abs1+3
003819  1                       .word   abs7f
003819  1               inw1_:  .word   abs1-$f8        ;indirect pointer for wrap-test pattern
003819  1               indt_:  .word   abst            ;indirect pointer to store area in absolute memory
003819  1                       .word   abst+1
003819  1                       .word   abst+2
003819  1                       .word   abst+3
003819  1               inwt_:  .word   abst-$f8        ;indirect pointer for wrap-test store
003819  1               indAN_: .word   absAN           ;indirect pointer to AND pattern in absolute memory
003819  1                       .word   absAN+1
003819  1                       .word   absAN+2
003819  1                       .word   absAN+3
003819  1               indEO_: .word   absEO           ;indirect pointer to EOR pattern in absolute memory
003819  1                       .word   absEO+1
003819  1                       .word   absEO+2
003819  1                       .word   absEO+3
003819  1               indOR_: .word   absOR           ;indirect pointer to OR pattern in absolute memory
003819  1                       .word   absOR+1
003819  1                       .word   absOR+2
003819  1                       .word   absOR+3
003819  1               ;add/subtract indirect pointers
003819  1               adi2_:  .word   ada2            ;indirect pointer to operand 2 in absolute memory
003819  1               sbi2_:  .word   sba2            ;indirect pointer to complemented operand 2 (SBC)
003819  1               adiy2_: .word   ada2-$ff        ;with offset for indirect indexed
003819  1               sbiy2_: .word   sba2-$ff
003819  1               zp_end:
003819  1                   .if (zp_end - zp_init) <> (zp_bss_end - zp_bss)
003819  1                       ;force assembler error if size is different
003819  1                       .error "mismatch between bss and zeropage data"
003819  1                   .endif
003819  1               data_init:
003819  1               ex_and_:and #0              ;execute immediate opcodes
003819  1                       rts
003819  1               ex_eor_:eor #0              ;execute immediate opcodes
003819  1                       rts
003819  1               ex_ora_:ora #0              ;execute immediate opcodes
003819  1                       rts
003819  1               ex_adc_:adc #0              ;execute immediate opcodes
003819  1                       rts
003819  1               ex_sbc_:sbc #0              ;execute immediate opcodes
003819  1                       rts
003819  1               abs1_:  .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
003819  1               abs7f_: .byte   $7f             ;test pattern for compare
003819  1               ;loads
003819  1               fLDx_:  .byte   fn,fn,0,fz      ;expected flags for load
003819  1               ;shifts
003819  1               rASL_:                      ;expected result ASL & ROL -carry
003819  1               rROL_:  .byte   $86,$04,$82,0   ; "
003819  1               rROLc_: .byte   $87,$05,$83,1   ;expected result ROL +carry
003819  1               rLSR_:                      ;expected result LSR & ROR -carry
003819  1               rROR_:  .byte   $61,$41,$20,0   ; "
003819  1               rRORc_: .byte   $e1,$c1,$a0,$80 ;expected result ROR +carry
003819  1               fASL_:                      ;expected flags for shifts
003819  1               fROL_:  .byte   fnc,fc,fn,fz    ;no carry in
003819  1               fROLc_: .byte   fnc,fc,fn,0     ;carry in
003819  1               fLSR_:
003819  1               fROR_:  .byte   fc,0,fc,fz      ;no carry in
003819  1               fRORc_: .byte   fnc,fn,fnc,fn   ;carry in
003819  1               ;increments (decrements)
003819  1               rINC_:  .byte   $7f,$80,$ff,0,1 ;expected result for INC/DEC
003819  1               fINC_:  .byte   0,fn,fn,fz,0    ;expected flags for INC/DEC
003819  1               ;logical memory operand
003819  1               absOR_: .byte   0,$1f,$71,$80   ;test pattern for OR
003819  1               absAN_: .byte   $0f,$ff,$7f,$80 ;test pattern for AND
003819  1               absEO_: .byte   $ff,$0f,$8f,$8f ;test pattern for EOR
003819  1               ;logical accu operand
003819  1               absORa_:.byte   0,$f1,$1f,0     ;test pattern for OR
003819  1               absANa_:.byte   $f0,$ff,$ff,$ff ;test pattern for AND
003819  1               absEOa_:.byte   $ff,$f0,$f0,$0f ;test pattern for EOR
003819  1               ;logical results
003819  1               absrlo_:.byte   0,$ff,$7f,$80
003819  1               absflo_:.byte   fz,fn,0,fn
003819  1               data_end
003819  1                   .if (data_end - data_init) <> (data_bss_end - data_bss)
003819  1                       ;force assembler error if size is different
003819  1                       .error "mismatch between bss and data"
003819  1                   .endif
003819  1               
003819  1               vec_init
003819  1                       .word   nmi_trap
003819  1                       .word   res_trap
003819  1                       .word   irq_trap
003819  1               vec_bss equ $fffa
003819  1                   .endif                   ;end of RAM init data
003819  1               
003819  1                   .if (load_data_direct = 1) & (ROM_vectors = 1)
003819  1                       .segment "VECTORS"
003819  1                       .org $fffa       ;vectors
003819  1                       .word   nmi_trap
003819  1                       .word   res_trap
003819  1                       .word   irq_trap
003819  1                   .endif
003819  1               
